# 力扣刷题笔记（五）

[TOC]

## [227. 基本计算器 II](https://leetcode-cn.com/problems/basic-calculator-ii/)

难度：中等:star::star::star::star:

### 题目

给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。

整数除法仅保留整数部分。

你可以假设给定的表达式总是有效的。所有中间结果将在 [-231, 231 - 1] 的范围内。

注意：不允许使用任何将字符串作为数学表达式计算的内置函数，比如 eval() 。

 

示例 1：

```
输入：s = "3+2*2"
输出：7
```

示例 2：

```
输入：s = " 3/2 "
输出：1
```

示例 3：

```
输入：s = " 3+5 / 2 "
输出：5
```


提示：

- 1 <= s.length <= 3 * 10^5^
- s 由整数和算符 ('+', '-', '*', '/') 组成，中间由一些空格隔开
- s 表示一个 有效表达式
- 表达式中的所有整数都是非负整数，且在范围 [0, 2^31^ - 1] 内
- 题目数据保证答案是一个 32-bit 整数

### 代码

- 官方题解-一个栈

```java
class Solution {
    public int calculate(String s) {
        Deque<Integer> stack = new LinkedList<Integer>();
        char preSign = '+';
        int num = 0;
        int n = s.length();
        for(int i = 0; i < n; i++) {
            char a = s.charAt(i);
            if (Character.isDigit(a)) {
                num = num * 10 + (a - '0');
            }
            if (!Character.isDigit(a) && a != ' ' || i == n - 1) {
                // 这里判断的是num前面的符号
                switch(preSign) {
                    case '+':
                        stack.push(num);
                        break;
                    case '-':
                        stack.push(-num);
                        break;
                    case '*':
                        stack.push(stack.pop() * num);
                        break;
                    case '/':
                        stack.push(stack.pop() / num);
                        break;
                }
                preSign = a;
                num = 0;
            }
        }
        int res = 0;
        while(!stack.isEmpty()) {
            res += stack.pop();
        }
        return res;
    }
    
}
```

### 笔记

- 技巧：
  - 在前面加上一个'+'号
  - 先算乘除
  - '-'后面的数字，存其相反数
  - 最后在全部加起来

## [78. 子集](https://leetcode-cn.com/problems/subsets/)

难度：中等:star::star::star::star:

### 题目

给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

 

示例 1：

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

示例 2：

```
输入：nums = [0]
输出：[[],[0]]
```


提示：

- 1 <= nums.length <= 10
- -10 <= nums[i] <= 10
- nums 中的所有元素 互不相同

### 代码

- 回溯

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        List<Integer> sub = new ArrayList<>();
        backtrack(nums, 0, sub);
        return res;
    }
    public void backtrack(int[] nums, int start, List<Integer> sub) {
        // 这里要保存一个新的
        res.add(new ArrayList<>(sub));
        for(int i = start; i < nums.length; i++) {
            sub.add(nums[i]);
            System.out.println(sub.toString());
            backtrack(nums, i + 1, sub);
            sub.remove(sub.size() - 1);
            System.out.println(sub.toString());
        }
    }

}
```

### 笔记

- 回溯算法的模板：

  ```java
  public void backtrack(参数) {
  	if (终止条件) {
  		保存结果;
  		return;
  	}
  	for (选择: 本层集合中的元素) {
  		处理结点;
  		backtrack(参数); // 递归
  		回溯; // 撤销处理结果
  	}
  }
  ```

## [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

难度：中等:star::star::star::star:

### 题目

给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。

 

示例 1：

```
输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
```

示例 2：

```
输入：nums = [0]
输出：[[],[0]]
```


提示：

- 1 <= nums.length <= 10
- -10 <= nums[i] <= 10

### 代码

- 排序+回溯

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        List<Integer> sub = new ArrayList<>();
        backtrack(nums, 0, sub);
        return res;
    }
    public void backtrack(int[] nums, int start, List<Integer> sub) {
        if (!res.contains(sub)) {
            res.add(new ArrayList<>(sub));
        }
        for(int i = start; i < nums.length; i++) {
            sub.add(nums[i]);
            backtrack(nums, i + 1, sub);
            sub.remove(sub.size() - 1);
        }
    }
}
```

- 排序+回溯+剪枝

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        // 排序，方便后面跳过相同元素
        Arrays.sort(nums);
        List<Integer> sub = new ArrayList<>();
        backtrack(nums, 0, sub);
        return res;
    }
    public void backtrack(int[] nums, int start, List<Integer> sub) {
        res.add(new ArrayList<>(sub));
        for(int i = start; i < nums.length; i++) {
            // 跳过单个相同元素
            if (i > start && nums[i] == nums[i-1]) {
                continue;
            }
            sub.add(nums[i]);
            backtrack(nums, i + 1, sub);
            sub.remove(sub.size() - 1);
        }
    }
}
```

- 排序+回溯+HashSet

```java
class Solution {
    HashSet<List<Integer>> res = new HashSet<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        // 排序，方便后面跳过相同元素
        Arrays.sort(nums);
        List<Integer> sub = new ArrayList<>();
        backtrack(nums, 0, sub);
        return new ArrayList<>(res);
    }
    public void backtrack(int[] nums, int start, List<Integer> sub) {
        res.add(new ArrayList<>(sub));
        for(int i = start; i < nums.length; i++) {
            sub.add(nums[i]);
            backtrack(nums, i + 1, sub);
            sub.remove(sub.size() - 1);
        }
    }
}
```

### 笔记

- 排序+回溯+HashSet：可以将res定义为HashSet，这样往res中add的时候会自动去重。
  HashSet转List：

  ```java
  HashSet<List<Integer>> res = new HashSet<>();
  return new ArrayList<>(res);
  ```

## [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

难度：中等:star::star::star::star:

### 题目

找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：

- 只使用数字1到9
- 每个数字 最多使用一次 

返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

 

示例 1:

```
输入: k = 3, n = 7
输出: [[1,2,4]]
解释:
1 + 2 + 4 = 7
没有其他符合的组合了。
```

示例 2:

```
输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]
解释:
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
没有其他符合的组合了。
```

示例 3:

```
输入: k = 4, n = 1
输出: []
解释: 不存在有效的组合。
在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。
```


提示:

- 2 <= k <= 9
- 1 <= n <= 60

### 代码

- 回溯+剪枝

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum3(int k, int n) {
        List<Integer> path = new ArrayList<>();
        backtrack(k, n, 1, path);
        return res;
    }
    public void backtrack(int k, int n, int start, List<Integer> path) {
        if (path.size() == k) {
            if (n == 0) {
                res.add(new ArrayList<>(path));
            }
            return;
        }
        for(int i = start; i <= 9 && i <= n; i++) {
            path.add(i);
            backtrack(k, n - i, i + 1, path);
            path.remove(path.size() - 1);
        }
    }
}
```

### 笔记

## [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

难度：中等:star::star::star::star:

### 题目

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](noteImage/200px-telephone-keypad2svg.png)

 

示例 1：

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

示例 2：

```
输入：digits = ""
输出：[]
```

示例 3：

```
输入：digits = "2"
输出：["a","b","c"]
```


提示：

- 0 <= digits.length <= 4
- digits[i] 是范围 ['2', '9'] 的一个数字。

### 代码

- 回溯法

```java
class Solution {
    private List<String> res = new ArrayList<>();
    private static HashMap<Character, String[]> map = new HashMap<>(){{
        put('2', new String[]{"a", "b", "c"});
        put('3', new String[]{"d", "e", "f"});
        put('4', new String[]{"g", "h", "i"});
        put('5', new String[]{"j", "k", "l"});
        put('6', new String[]{"m", "n", "o"});
        put('7', new String[]{"p", "q", "r", "s"});
        put('8', new String[]{"t", "u", "v"});
        put('9', new String[]{"w", "x", "y", "z"});
    }};
    public List<String> letterCombinations(String digits) {
        if (digits.length() == 0) {
            return res;
        }
        StringBuilder word = new StringBuilder();
        backtrack(digits, word, 0);
        return res;
    }
    public void backtrack(String digits, StringBuilder word, int start) {
        if (word.length() == digits.length()) {
            res.add(new String(word.toString()));
            return;
        }
        for(int i = start; i < digits.length(); i++) {
            String[] value =  map.get(digits.charAt(i));
            for(int j = 0; j < value.length; j++) {
                word.append(value[j]);
                backtrack(digits, word, i + 1);
                word.delete(word.length() - 1, word.length());
            }
        }
    }
}
```

### 笔记

## [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

难度：中等:star::star::star::star:

### 题目

给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 target 的不同组合数少于 150 个。

 

示例 1：

```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

示例 2：

```
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
```

示例 3：

```
输入: candidates = [2], target = 1
输出: []
```


提示：

- 1 <= candidates.length <= 30
- 1 <= candidates[i] <= 200
- candidate 中的每个元素都 互不相同
- 1 <= target <= 500

### 代码

- 排序+回溯

```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<Integer> path = new ArrayList<>();
        backtrack(candidates, target, 0, path, 0);
        return res;
    }
    public void backtrack(int[] candidates, int target, int start, List<Integer> path, int sum) {
        if (sum > target) {
            return;
        }
        if (sum == target) {
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = start; i < candidates.length; i++) {
            if (candidates[i] > target) {
                break;
            }
            path.add(candidates[i]);
            backtrack(candidates, target, i, path, sum + candidates[i]);
            path.remove(path.size() - 1);
        }
    }
}
```

- 回溯

```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<Integer> path = new ArrayList<>();
        backtrack(candidates, target, 0, path, 0);
        return res;
    }
    public void backtrack(int[] candidates, int target, int start, List<Integer> path, int sum) {
        if (sum > target) {
            return;
        }
        if (sum == target) {
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = start; i < candidates.length; i++) {
            path.add(candidates[i]);
            backtrack(candidates, target, i, path, sum + candidates[i]);
            path.remove(path.size() - 1);
        }
    }
}
```

### 笔记

## [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

难度：中等:star::star::star::star:

### 题目

给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的每个数字在每个组合中只能使用 一次 。

注意：解集不能包含重复的组合。 

 

示例 1:

```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
[1,1,6],
[1,2,5],
[1,7],
[2,6]
]
```

示例 2:

```
输入: candidates = [2,5,2,1,2], target = 5,
输出:
[
[1,2,2],
[5]
]
```


提示:

- 1 <= candidates.length <= 100
- 1 <= candidates[i] <= 50
- 1 <= target <= 30

### 代码

- 回溯+剪枝

```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        List<Integer> path = new ArrayList<>();
        backtrack(candidates, target, path, 0, 0);
        return res;
    }
    public void backtrack(int[] candidates, int target, List<Integer> path, int start, int sum) {
        if (sum > target) {
            return;
        }
        if (sum == target) {
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = start; i < candidates.length; i++) {
            // 剪枝，跳过递归树中横向的（同一层的）相同值
            if (i > start && candidates[i] == candidates[i-1]) {
                // System.out.println(start + ", " + i);
                continue;
            }
            path.add(candidates[i]);
            backtrack(candidates, target, path, i + 1, sum + candidates[i]);
            path.remove(path.size() - 1);
        }
    }
}
```

### 笔记

- 剪枝时，和前一个元素相比，可以去掉重复的元素。

## [131. 分割回文串](https://leetcode-cn.com/problems/palindrome-partitioning/submissions/)

难度：中等:star::star::star::star:

### 题目

给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。

回文串 是正着读和反着读都一样的字符串。

 

示例 1：

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

示例 2：

```
输入：s = "a"
输出：[["a"]]
```


提示：

- 1 <= s.length <= 16
- s 仅由小写英文字母组成

### 代码

- 回溯

```java
class Solution {
    private List<List<String>> res = new ArrayList<>();
    public List<List<String>> partition(String s) {
        List<String> sub = new ArrayList<>();
        backtrack(s, sub, 0);
        return res;
    }
    public boolean isPalindrome(String t) {
        int i = 0;
        int j = t.length() - 1;
        while(i <= j) {
            if (t.charAt(i) != (t.charAt(j))) {
                return false;
            }
            i++;
            j--;
        }
        return true;
    }
    public void backtrack(String s, List<String> sub, int start) {
        if (start == s.length()) {
            res.add(new ArrayList<>(sub));
            return;
        }
        for (int i = start; i < s.length(); i++) {
            // 这里获取子串是从start到i+1
            if (isPalindrome(s.substring(start, i + 1))) {
                sub.add(s.substring(start, i + 1));
                backtrack(s, sub, i + 1);
                sub.remove(sub.size() - 1);
            } else {
                continue;
            }
        }
    }
}
```

- 动态规划+回溯

```java
class Solution {
    private List<List<String>> res = new ArrayList<>();
    private boolean[][] f;
    private int n;
    public List<List<String>> partition(String s) {
        // 动态规划预处理
        n = s.length();
        f = new boolean[n][n];
        for(int i = 0; i < n; i++) {
            Arrays.fill(f[i], true);
        }
        // 从左下角往右上角动规
        for(int i = n - 1; i >= 0; i--) {
            for (int j = i + 1; j < n; j++) {
                f[i][j] = (s.charAt(i) == s.charAt(j)) && f[i + 1][j - 1];
            }
        }
        List<String> sub = new ArrayList<>();
        backtrack(s, sub, 0);
        return res;
    }
    public void backtrack(String s, List<String> sub, int start) {
        if (start == n) {
            res.add(new ArrayList<>(sub));
            return;
        }
        for (int i = start; i < n; i++) {
            // 这里只需要判断子串[start, i]
            if (f[start][i]) {
                sub.add(s.substring(start, i + 1));
                backtrack(s, sub, i + 1);
                sub.remove(sub.size() - 1);
            } else {
                continue;
            }
        }
    }
}
```

### 笔记

- 回溯：注意这里获取子串时的写法

- 动规+回溯：每次截取子串耗时，可以先把所有的回文子串存到dp数组里。

  ```
  if i==j; dp[i][j] = true;
  if i < j && s[i]==s[j]; dp[i][j] = f[i+1][j-1]
  ```



## [93. 复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)

难度：中等:star::star::star::star:

### 题目

有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效 IP 地址。
给定一个只包含数字的字符串 s ，用以表示一个 IP 地址，返回所有可能的有效 IP 地址，这些地址可以通过在 s 中插入 '.' 来形成。你 不能 重新排序或删除 s 中的任何数字。你可以按 任何 顺序返回答案。

 

示例 1：

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

示例 2：

```
输入：s = "0000"
输出：["0.0.0.0"]
```

示例 3：

```
输入：s = "101023"
输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
```

提示：

- 1 <= s.length <= 20
- s 仅由数字组成

### 代码

- 回溯

```java
class Solution {
    private List<String> res = new ArrayList<>();
    public List<String> restoreIpAddresses(String s) {
        StringBuilder ip = new StringBuilder();
        backtrack(s, ip, 0, 0);
        return res;
    }
    public boolean isValid(String t) {
        // 只有一个数
        if (t.length() == 1) {
            return true;
        }
        // 多个数，含有前导0
        if (t.charAt(0) == '0') {
            return false;
        }
        int num = Integer.parseInt(t);
        // 在0到255范围内
        if (num > 255 || num < 0) {
            return false;
        }
        return true;
    }
    public void backtrack(String s, StringBuilder ip, int start, int pointNum) {
        if (pointNum == 4) {
            if (ip.length() - 4 == s.length()) {
                // 删除末尾的点
                res.add(ip.toString().substring(0, ip.length() - 1));
            }
            return;
        }
        for(int i = start; i < s.length(); i++) {
            String sub = s.substring(start, i + 1);
            if (isValid(sub)) {
                ip.append(sub + ".");
                pointNum++;
                backtrack(s, ip, i + 1, pointNum);
                ip.delete(ip.length() - sub.length() - 1, ip.length());
                pointNum--;
            } else {
                break;
            }
        }
    }
}
```

### 笔记

## [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

难度：中等:star::star::star::star:

### 题目

给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。

 

示例 1：

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

示例 2：

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```


提示：

- 1 <= nums.length <= 8
- -10 <= nums[i] <= 10

### 代码

- 回溯【推荐】

```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    private HashSet<Integer> set = new HashSet<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        List<Integer> path = new ArrayList<>();
        backtrack(nums, path);
        return res;
    }
    public void backtrack(int[] nums, List<Integer> path) {
        if (path.size() == nums.length) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if (i > 0 && nums[i] == nums[i - 1] && !set.contains(i - 1)) {
                continue;
            }
            if (!set.contains(i)) {
                path.add(nums[i]);
                set.add(i);
                backtrack(nums, path);
                path.remove(path.size() - 1);
                set.remove(i);
            }
            
        }
    }
}
```

- 回溯

```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    private HashSet<Integer> set = new HashSet<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        List<Integer> path = new ArrayList<>();
        backtrack(nums, path);
        return res;
    }
    public void backtrack(int[] nums, List<Integer> path) {
        if (path.size() == nums.length) {
            res.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            if (i > 0 && nums[i] == nums[i - 1] && set.contains(i - 1)) {
                continue;
            }
            if (!set.contains(i)) {
                path.add(nums[i]);
                set.add(i);
                backtrack(nums, path);
                path.remove(path.size() - 1);
                set.remove(i);
            }
            
        }
    }
}
```

### 笔记

- 难点：去重，`set.contains(i - 1)`和`!set.contains(i - 1)`都可以:
  - `set.contains(i - 1)`表示同一个树枝上，第i个的前一个已经用过了。
  - `!set.contains(i - 1)`表示同一个树层上，第i个的前一个没有用过。【推荐】效率更高

## [51. N 皇后](https://leetcode-cn.com/problems/n-queens/)

难度：困难:star::star::star::star::star:

### 题目

n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。

每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。

 

示例 1：

![img](noteImage/queens.jpg)

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

示例 2：

```
输入：n = 1
输出：[["Q"]]
```


提示：

- 1 <= n <= 9

### 代码

- 回溯法

```java
class Solution {
    private List<List<String>> res = new ArrayList<>();
    private char[][] chessboard;
    public List<List<String>> solveNQueens(int n) {
        // 构造棋盘
        chessboard = new char[n][n];
        for(int i = 0; i < n; i++) {
            Arrays.fill(chessboard[i], '.');
        }
        // 回溯
        backtrack(n, 0);
        return res;
    }
    public boolean isValid(int row, int col, int n) {
        // 检查正上方的列
        for (int i = 0; i < row; i++) {
            if (chessboard[i][col] == 'Q') {
                return false;
            }
        }

        // 检查左上方的对角线
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }

        // 检查右上方的对角线
        for (int i = row - 1, j = col + 1; i >= 0 && j <= n - 1; i--, j++) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }
        return true;
    }
    public List<String> char2List(char[][] ch) {
        List<String> list = new ArrayList<>();
        for(char[] c : ch) {
            list.add(String.copyValueOf(c));
        }
        return list;
    }
    public void backtrack(int n, int row) {
        if (row == n) {
            res.add(char2List(chessboard));
            return;
        }
        for (int col = 0; col < n; col++) {
            if (isValid(row, col, n)) {
                chessboard[row][col] = 'Q';
                backtrack(n, row + 1);
                chessboard[row][col] = '.';
            }
        }
    }
}
```

### 笔记

- char数组转字符串：

  ``` java
  char[] c;
  String.copyValueOf(c); // 返回char数组参数的字符串表示形式。 复制字符数组的内容; 后续修改字符数组不会影响返回的字符串。
  ```

- 二维数组赋初始值：

  ``` java
  char[][] chessboard = new char[n][n];
  for(int i = 0; i < n; i++) {
  	Arrays.fill(chessboard[i], '.'); // 将指定的char值分配给指定的chars数组的每个元素。
  }
  ```

- 关于isValid函数：因为皇后是从上往下一行一行放置的，所以只用检查正上方，左上方，右下方三个方向。

## [37. 解数独](https://leetcode-cn.com/problems/sudoku-solver/)

难度：困难:star::star::star::star::star:

### 题目

编写一个程序，通过填充空格来解决数独问题。

数独的解法需 遵循如下规则：

数字 1-9 在每一行只能出现一次。
数字 1-9 在每一列只能出现一次。
数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）
数独部分空格内已填入了数字，空白格用 '.' 表示。

 

示例 1：

![img](noteImage/250px-sudoku-by-l2g-20050714svg.png)

```
输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
```


解释：输入的数独如上图所示，唯一有效的解决方案如下所示：

![img](noteImage/250px-sudoku-by-l2g-20050714_solutionsvg.png)


提示：

- board.length == 9
- board[i].length == 9
- board[i][j] 是一位数字或者 '.'
- 题目数据 保证 输入数独仅有一个解

### 代码

- 回溯法

```java
class Solution {
    public void solveSudoku(char[][] board) {
        backtrack(board, 0, 0);
    }
    public boolean isValid(char[][] board, int row, int col, char ch) {
        for (int i = 0; i < 9; i++) {
            // 同行或同列有重复数字
            if (board[row][i] == ch || board[i][col] == ch) {
                return false;
            }
        }
        // 9宫格是否有重复
        int startRow = (row / 3) * 3;
        int startCol = (col / 3) * 3;
        for(int i = startRow; i < startRow + 3; i++) {
            for (int j = startCol; j < startCol + 3; j++) {
                if (board[i][j] == ch) {
                    return false;
                }
            }
        }
        return true;
    }
    public boolean backtrack(char[][] board, int row, int col) {
        if (col == 9) {
            // 开始下一行
            return backtrack(board, row + 1, 0);
        }
        if (row == 9) {
            // 行结束
            return true;
        }
        if (board[row][col] != '.') {
            // 当前格是数字，跳到下一列
            return backtrack(board, row, col + 1);
        }
        for (char ch = '1'; ch <= '9'; ch++) {
            if (isValid(board, row, col, ch)) {
                board[row][col] = ch;
                // 找到一个可行解立即结束
                if (backtrack(board, row, col + 1)) {
                    return true;
                }
                board[row][col] = '.';
            }
        }
        // 当前格子1-9都不行，那就要前一个格子换个数
        return false;
    }
}
```

- 回溯法

```java
class Solution {
    public void solveSudoku(char[][] board) {
        backtrack(board);
    }
    public boolean isValid(char[][] board, int row, int col, char ch) {
        for (int i = 0; i < 9; i++) {
            // 同行或同列有重复数字
            if (board[row][i] == ch || board[i][col] == ch) {
                return false;
            }
        }
        // 9宫格是否有重复
        int startRow = (row / 3) * 3;
        int startCol = (col / 3) * 3;
        for(int i = startRow; i < startRow + 3; i++) {
            for (int j = startCol; j < startCol + 3; j++) {
                if (board[i][j] == ch) {
                    return false;
                }
            }
        }
        return true;
    }
    public boolean backtrack(char[][] board) {
        // 遍历行
        for (int i = 0; i < 9; i++) {
            // 遍历列
            for (int j = 0; j < 9; j++) {
                // 跳过数字
                if (board[i][j] != '.') {
                    continue;
                }
                for (char ch = '1'; ch <= '9'; ch++) {
                    if (isValid(board, i, j, ch)) {
                        board[i][j] = ch;
                        // 找到一个解立即返回
                        if (backtrack(board)) {
                            return true;
                        }
                        board[i][j] = '.';
                    }
                }
                // 9个数都试完了，都不行，就返回false
                return false;
            }
        }
        return true;
    }
}
```

### 笔记

- char类型也可以遍历：

  ```java
  for (char ch = '1'; ch <= '9'; ch++) {
      // do something
  }
  ```

## [491. 递增子序列](https://leetcode-cn.com/problems/increasing-subsequences/)

难度：中等:star::star::star::star:

### 题目

给你一个整数数组 nums ，找出并返回所有该数组中不同的递增子序列，递增子序列中 至少有两个元素 。你可以按 任意顺序 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

 

示例 1：

```
输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
```

示例 2：

```
输入：nums = [4,4,3,2,1]
输出：[[4,4]]
```


提示：

- 1 <= nums.length <= 15
- -100 <= nums[i] <= 100

### 代码

- 回溯+剪枝

```java
class Solution {
    private List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        List<Integer> path = new ArrayList<>();
        backtrack(nums, path, 0);
        return res;
    }
    public void backtrack(int[] nums, List<Integer> path, int start) {
        if (path.size() >= 2) {
            res.add(new ArrayList<>(path));
        }
        // 记录本层的HashSet
        HashSet<Integer> set = new HashSet<>();
        for (int i = start; i < nums.length; i++) {
            if (set.contains(nums[i])) {
                continue;
            }
            // 保持递增，要大于path中的最后一个
            if (path.isEmpty() || (i >= start && nums[i] >= path.get(path.size() - 1))) {
                path.add(nums[i]);
                set.add(nums[i]);
                backtrack(nums, path, i + 1);
                path.remove(path.size() - 1);
            }
        }
    }
}
```

### 笔记

- 使用一个内部的HashSet来记录树同一层的元素，进行去重，并且同一层，添加到set中的元素是没有remove的。

## [306. 累加数](https://leetcode-cn.com/problems/additive-number/)

难度：中等:star::star::star::star:

### 题目

累加数 是一个字符串，组成它的数字可以形成累加序列。

一个有效的 累加序列 必须 至少 包含 3 个数。除了最开始的两个数以外，序列中的每个后续数字必须是它之前两个数字之和。

给你一个只包含数字 '0'-'9' 的字符串，编写一个算法来判断给定输入是否是 累加数 。如果是，返回 true ；否则，返回 false 。

说明：累加序列里的数，除数字 0 之外，不会 以 0 开头，所以不会出现 1, 2, 03 或者 1, 02, 3 的情况。

 

示例 1：

```
输入："112358"
输出：true 
解释：累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8
```

示例 2：

```
输入："199100199"
输出：true 
解释：累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199
```


提示：

- 1 <= num.length <= 35
- num 仅由数字（0 - 9）组成

进阶：你计划如何处理由过大的整数输入导致的溢出?

### 代码

- 回溯

```java
class Solution {
    private int n;
    private List<String> res = new ArrayList<>();
    public boolean isAdditiveNumber(String num) {
        n = num.length();
        return backtrack(num, 0);
    }
    public String addStr(String num1, String num2) {
        StringBuilder result = new StringBuilder();
        int i = num1.length() - 1;
        int j = num2.length() - 1;
        int carry = 0;
        while(i >= 0 || j >= 0) {
            int a = i >= 0 ? num1.charAt(i) - '0' : 0;
            int b = j >= 0 ? num2.charAt(j) - '0' : 0;
            int sum = a + b + carry;
            carry = sum / 10;
            result.append(sum % 10);
            i--;
            j--;
        }
        if (carry > 0) {
            result.append(carry);
        }
        return result.reverse().toString();
    }
    public boolean isValid(String num) {
        if (num.length() > 1 && num.charAt(0) == '0') {
            return false;
        }
        return true;
    }
    public boolean backtrack(String num, int start) {
        int m = res.size();
        if (m >= 3) {
            // 相等就什么也不会返回，会继续递归
            if (!res.get(m - 1).equals(addStr(res.get(m - 2), res.get(m - 3)))) {
                return false;
            }
            // 一直到了结尾，前面没有提前返回，说明找到了一组解
            if (start == n) {
                return true;
            }
        }
        for (int i = start; i < n; i++) {
            String sub = num.substring(start, i + 1);
            if (isValid(sub)) {
                res.add(sub);
                // System.out.println(res.toString());
                // 找到了一组解就提前结束
                if (backtrack(num, i + 1)) {
                    return true;
                }
                res.remove(res.size() - 1);
            }
        }
        return false;
    }
}
```

- 回溯

```java
class Solution {
    private int n;
    private List<List<Integer>> res = new ArrayList<>();
    public boolean isAdditiveNumber(String num) {
        n = num.length();
        return backtrack(num, 0);
    }
    public boolean check(List<Integer> a, List<Integer> b, List<Integer> c) {
        List<Integer> ans = new ArrayList<>();
        int t = 0;
        for (int i = 0; i < a.size() || i < b.size(); i++) {
            if (i < a.size()) {
                t += a.get(i);
            }
            if (i < b.size()) {
                t += b.get(i);
            }
            ans.add(t % 10);
            t /= 10;
        }
        if (t > 0) {
            ans.add(t);
        }
        boolean ok = c.size() == ans.size();
        for (int i = 0; i < c.size() && ok; i++) {
            if (c.get(i) != ans.get(i)) {
                ok = false;
            }
        }
        return ok;
    }
    public boolean backtrack(String num, int start) {
        int m = res.size();
        if (start == n) {
            return m >= 3;
        }
        int max = num.charAt(start) == '0' ? start + 1 : n;
        List<Integer> cur = new ArrayList<>();
        for (int i = start; i < max; i++) {
            cur.add(0, num.charAt(i) - '0');
            if (m < 2 || check(res.get(m - 2), res.get(m - 1), cur)) {
                res.add(cur);
                if (backtrack(num, i + 1)) {
                    return true;
                }
                res.remove(res.size() - 1);
            }
        }
        return false;
    }
}
```

### 笔记

## [1137. 第 N 个泰波那契数](https://leetcode-cn.com/problems/n-th-tribonacci-number/)

难度：简单:star::star::star:

### 题目

泰波那契序列 Tn 定义如下： 

T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2

给你整数 n，请返回第 n 个泰波那契数 Tn 的值。

 

示例 1：

```
输入：n = 4
输出：4
解释：
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4
```

示例 2：

```
输入：n = 25
输出：1389537
```


提示：

- 0 <= n <= 37
- 答案保证是一个 32 位整数，即 answer <= 2^31 - 1。

### 代码

- 动态规划

```java
class Solution {
    public int tribonacci(int n) {
        if (n < 2) {
            return n;
        }
        if (n == 2) {
            return 1;
        }
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        dp[2] = 1;
        for(int i = 3; i <= n; i++) {
            dp[i] = dp[i-1] + dp[i-2] + dp[i-3];
        }
        return dp[n];
    }
}
```

- 动规+状态压缩

```java
class Solution {
    public int tribonacci(int n) {
        if (n < 2) {
            return n;
        }
        if (n == 2) {
            return 1;
        }
        int t0 = 0, t1 = 1, t2 = 1;
        int t3 = 0;;
        for(int i = 3; i <= n; i++) {
            t3 = t0 + t1 + t2;
            t0 = t1;
            t1 = t2;
            t2 = t3;
        }
        return t3;
    }
}
```

### 笔记

## [746. 使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

难度：简单:star::star::star:

### 题目

给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

 

示例 1：

```
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```

示例 2：

```
输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。

- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
  总花费为 6 。
```


提示：

- 2 <= cost.length <= 1000
- 0 <= cost[i] <= 999

### 代码

- 动态规划

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 0;
        for (int i = 2; i <= n; i++) {
            dp[i] = Math.min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]);
        }
        return dp[n];
    }
}
```

- 动规+状态压缩

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int dp0 = 0, dp1 = 0, dpn = 0;
        for (int i = 2; i <= cost.length; i++) {
            dpn = Math.min(dp0 + cost[i-2], dp1 + cost[i-1]);
            dp0 = dp1;
            dp1 = dpn;
        }
        return dpn;
    }
}
```

### 笔记

## [213. 打家劫舍 II](https://leetcode-cn.com/problems/house-robber-ii/)

难度：中等:star::star::star::star:

### 题目

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

 

示例 1：

```
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

示例 2：

```
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

示例 3：

```
输入：nums = [1,2,3]
输出：3
```


提示：

- 1 <= nums.length <= 100
- 0 <= nums[i] <= 1000

### 代码

- 动态规划

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) {
            return nums[0];
        }
        if (n == 2) {
            return Math.max(nums[0], nums[1]);
        }
        int[] dp = new int[n];
        // 考虑第一个，不考虑最后一个。范围：[0, n-2]
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i <= n - 2; i++) {
            dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);
        }
        int res1 = dp[n-2];
        // 不考虑第一个，考虑最后一个。范围：[1, n-1]
        dp[1] = nums[1];
        dp[2] = Math.max(nums[1], nums[2]);
        for (int i = 3; i <= n - 1; i++) {
            dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);
        }
        int res2 = dp[n-1];
        return Math.max(res1, res2);
    } 
}
```

- 动态规划

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) {
            return nums[0];
        }
        if (n == 2) {
            return Math.max(nums[0], nums[1]);
        }
        // 考虑第一个，不考虑最后一个。范围：[0, n-2]
        int res1 = rob1(nums, 0, n-2);
        // 不考虑第一个，考虑最后一个。范围：[1, n-1]
        int res2 = rob1(nums, 1, n-1);
        return Math.max(res1, res2);
    }
    public int rob1(int[] nums, int start, int end) {
        int[] dp = new int[nums.length];
        dp[start] = nums[start];
        dp[start + 1] = Math.max(nums[start], nums[start + 1]);
        for (int i = start + 2; i <= end; i++) {
            dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);
        }
        return dp[end];
    }
}
```

- 动态规划+状态压缩

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 1) {
            return nums[0];
        }
        if (n == 2) {
            return Math.max(nums[0], nums[1]);
        }
        // 考虑第一个，不考虑最后一个。范围：[0, n-2]
        int res1 = rob1(nums, 0, n-2);
        // 不考虑第一个，考虑最后一个。范围：[1, n-1]
        int res2 = rob1(nums, 1, n-1);
        return Math.max(res1, res2);
    }
    public int rob1(int[] nums, int start, int end) {
        int first = nums[start];
        int second = Math.max(nums[start], nums[start + 1]);
        // 注意，这里的res初始值是second
        int res = second;
        for (int i = start + 2; i <= end; i++) {
            res = Math.max(first + nums[i], second);
            first = second;
            second = res;
        }
        return res;
    }
}
```

### 笔记

- 动态规划：把此环状排列房间问题约化为两个单排排列房间子问题：
  - 考虑第一个，不考虑最后一个。范围：`[0, n-2]`
  - 不考虑第一个，考虑最后一个。范围：`[1, n-1]`
  考虑第一个和考虑最后一个不代表一定选，只是放到考虑范围内。
  对于第二种情况，是要改变初始状态和for循环的初始索引。
- 动态规划：可以把两个for循环封装成一个函数。

## [740. 删除并获得点数](https://leetcode-cn.com/problems/delete-and-earn/)

难度：中等:star::star::star::star:

### 题目

你一个整数数组 nums ，你可以对它进行一些操作。

每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。之后，你必须删除 所有 等于 nums[i] - 1 和 nums[i] + 1 的元素。

开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

 

示例 1：

```
输入：nums = [3,4,2]
输出：6
解释：
删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。
```

示例 2：

```
输入：nums = [2,2,3,3,3,4]
输出：9
解释：
删除 3 获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数。
```


提示：

- 1 <= nums.length <= 2 * 10^4^
- 1 <= nums[i] <= 10^4^

### 代码

- 动态规划

```java
class Solution {
    public int deleteAndEarn(int[] nums) {
        int max = 0;
        for(int i : nums) {
            max = Math.max(max, i);
        }
        // 记录所有相同点数的和
        int[] count = new int[max + 1];
        for(int i : nums) {
            count[i] += i;
        }
        // 转化为打家劫舍
        int[] dp = new int[max + 1];
        dp[0] = count[0];
        dp[1] = Math.max(count[0], count[1]);
        for (int i = 2; i < max + 1; i++) {
            dp[i] = Math.max(count[i] + dp[i-2], dp[i-1]);
        }
        return dp[max];
    }
}
```

### 笔记

- 动态规划：选择了 x，所有等于 x的元素也应一同被选择，以尽可能多地获得点数。记录数组 nums 中所有相同元素之和，选择了x，就是选择了所有相同的x，且不能选择所有的x-1和所有的x+1。这和打家劫舍是一样的了。

## [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

难度：中等:star::star::star::star:

### 题目

给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

 

示例 1：

```
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```

示例 2：

```
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```


提示：

- 1 <= nums.length <= 3 * 10^4^
- 0 <= nums[i] <= 10^5^

### 代码

- 贪心算法

```java
class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        int cover = 0;
        for (int i = 0; i < n; i++) {
            // 超过cover的下标肯定到不了
            if (i > cover) {
                return false;
            }
            // cover是当前能够到的最远下标
            // i + nums[i]是从i开始能够到的最远下标
            cover = Math.max(cover, i + nums[i]);
            if (cover >= n - 1) {
                return true;
            }
        }
        return false;
    }
}
```

### 笔记

## [45. 跳跃游戏 II](https://leetcode-cn.com/problems/jump-game-ii/)

难度：中等:star::star::star::star:

### 题目

给你一个非负整数数组 nums ，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。

 

示例 1:

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

示例 2:

```
输入: nums = [2,3,0,1,4]
输出: 2
```


提示:

- 1 <= nums.length <= 10^4^
- 0 <= nums[i] <= 1000

### 代码

- 贪心

```java
class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        int cover = 0;
        int end = 0; // 每次能够到达的最远的边界的下标
        int step = 0;
        // n - 1 + nums[n-1]没有什么意义，不需要用来计算cover
        for (int i = 0; i < n - 1; i++) {
            // 从位置i能够到达的最远位置
            cover = Math.max(cover, i + nums[i]);
            // 到达边界，更新边界，并计算步数，到达一次边界，算一步
            if (i == end) {
                end = cover;
                step++;
            }
        }
        return step;
    }
}
```

- 贪心+动规

```java
class Solution {
    public int jump(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        dp[0] = 0;
        for (int i = 1, j = 0; i < n; i++) {
            // j在i的左边。出while循环说明j是i左边第一个能够到达i的下标
            while(j + nums[j] < i) {
                j++;
            }
            // 从j是能够一步到达i
            dp[i] = dp[j] + 1;
        }
        return dp[n-1];
    }
}
```

### 笔记

- 贪心：在遍历数组时，我们不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。
- 贪心+动规：
  状态转移方程：
  `dp[i] = dp[j] + 1;`，dp[i]就是能够到达i需要的最少跳跃次数，就等于能够到达j需要的最少跳跃次数，其中从j是能够一步到达i的。
  在状态转移方程中，其实j可以是i左边的任意一个能够到达i的下标，为了找到跳跃的最少次数，我们通过贪心策略，寻找i左边第一个能够一步到达i的j。

## [918. 环形子数组的最大和](https://leetcode-cn.com/problems/maximum-sum-circular-subarray/)

难度：中等:star::star::star::star:

### 题目

给定一个长度为 n 的环形整数数组 nums ，返回 nums 的非空 子数组 的最大可能和 。

环形数组 意味着数组的末端将会与开头相连呈环状。形式上， nums[i] 的下一个元素是 nums[(i + 1) % n] ， nums[i] 的前一个元素是 nums[(i - 1 + n) % n] 。

子数组 最多只能包含固定缓冲区 nums 中的每个元素一次。形式上，对于子数组 nums[i], nums[i + 1], ..., nums[j] ，不存在 i <= k1, k2 <= j 其中 k1 % n == k2 % n 。

 

示例 1：

```
输入：nums = [1,-2,3,-2]
输出：3
解释：从子数组 [3] 得到最大和 3
```

示例 2：

```
输入：nums = [5,-3,5]
输出：10
解释：从子数组 [5,5] 得到最大和 5 + 5 = 10
```

示例 3：

```
输入：nums = [3,-2,2,-3]
输出：3
解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3
```


提示：

- n == nums.length
- 1 <= n <= 3 * 10^4^
- -3 * 10^4^ <= nums[i] <= 3 * 10^4^

### 代码

- 动态规划

```java
class Solution {
    public int maxSubarraySumCircular(int[] nums) {
        int n = nums.length;
        int[] dp = new int[n];
        dp[0] = nums[0];
        int pre = nums[0];
        int sum = nums[0];
        // 求[0, n-1]的最大子数组和
        for (int i = 1; i < n; i++) {
            pre = Math.max(pre + nums[i], nums[i]);
            dp[i] = Math.max(pre, dp[i - 1]);
            sum += nums[i];
        }
        int maxSub = dp[n - 1];
        // System.out.println(maxSub);
        // 求[0, n-1]的最小子数组和
        pre = nums[0];
        for (int i = 1; i < n; i++) {
            pre = Math.min(pre + nums[i], nums[i]);
            dp[i] = Math.min(pre, dp[i-1]);
        }
        int minSub = dp[n - 1];
        // System.out.println(minSub);
        // System.out.println(sum);
        return maxSub < 0 ? maxSub : Math.max(maxSub, sum - minSub);
        
    }
}
```

- 动规+状态压缩

```java
class Solution {
    public int maxSubarraySumCircular(int[] nums) {
        int n = nums.length;
        int dp0 = nums[0];
        int dp1 = nums[0];
        int preMax = nums[0];
        int preMin = nums[0];
        int sum = nums[0];
        int maxSub = nums[0];
        int minSub = nums[0];
        for (int i = 1; i < n; i++) {
            preMax = Math.max(preMax + nums[i], nums[i]);
            preMin = Math.min(preMin + nums[i], nums[i]);
            maxSub = Math.max(preMax, dp0);
            minSub = Math.min(preMin, dp1);
            dp0 = maxSub;
            dp1 = minSub;
            sum += nums[i];
        }
        // System.out.println(sum + "," + maxSub + "," + minSub);
        return maxSub < 0 ? maxSub : Math.max(maxSub, sum - minSub);
    }
}
```

### 笔记

- 最大的环形子数组和 = max(最大子数组和，数组总和-最小子数组和)
  极端情况：如果说这数组的所有数都是负数，即最大子数组和小于0，则直接返回最大子数组和（数组所有负数中最大的负数）
  （记住吧，公式证明起来有点啰嗦）
- 动规+状态压缩：就是把动规中求最大子数组和、最小子数组和放在了一个for循环中，并且将dp数组改为变量（因为dp数组中dp[i]只和dp[i-1]有关）

## [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

难度：中等:star::star::star::star:

### 题目

给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 32-位 整数。

子数组 是数组的连续子序列。

 

示例 1:

```
输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

示例 2:

```
输入: nums = [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```


提示:

- 1 <= nums.length <= 2 * 10^4^
- -10 <= nums[i] <= 10
- nums 的任何前缀或后缀的乘积都 保证 是一个 32-位 整数

### 代码

- 动态规划

```java
class Solution {
    public int maxProduct(int[] nums) {
        int n = nums.length;
        int[] maxDp = new int[n];
        int[] minDp = new int[n];
        maxDp[0] = nums[0];
        minDp[0] = nums[0];
        for (int i = 1; i < n; i++) {
            if (nums[i] > 0) {
                maxDp[i] = Math.max(maxDp[i-1] * nums[i], nums[i]);
                minDp[i] = Math.min(minDp[i-1] * nums[i], nums[i]);
            } else {
                // 负数的话，最大值变最小值，最小值变最大值
                maxDp[i] = Math.max(minDp[i-1] * nums[i], nums[i]);
                minDp[i] = Math.min(maxDp[i-1] * nums[i], nums[i]);
            }
        }
        int res = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            res = Math.max(res, maxDp[i]);
        }
        return res;
    }
}
```

- 动态规划+状态压缩

```java
class Solution {
    public int maxProduct(int[] nums) {
        int n = nums.length;
        int maxDp0 = nums[0];
        int minDp0 = nums[0];
        int maxDp = nums[0];
        int minDp = nums[0];
        int res = nums[0];
        for (int i = 1; i < n; i++) {
            if (nums[i] > 0) {
                maxDp = Math.max(maxDp0 * nums[i], nums[i]);
                minDp = Math.min(minDp0 * nums[i], nums[i]);
            } else {
                // 负数的话，最大值变最小值，最小值变最大值
                maxDp = Math.max(minDp0 * nums[i], nums[i]);
                minDp = Math.min(maxDp0 * nums[i], nums[i]);
            }
            res = Math.max(res, maxDp);
            maxDp0 = maxDp;
            minDp0 = minDp;
        }
        return res;
    }
}
```

### 笔记

- 动态规划：`maxDp[i] = Math.max(maxDp[i-1] * nums[i], nums[i]);`这种方式是和nums[i]相比，最后要遍历一遍数组，找到最大值。真正的最大值可能在dp数组中间。

## [1567. 乘积为正数的最长子数组长度](https://leetcode-cn.com/problems/maximum-length-of-subarray-with-positive-product/)

难度：中等:star::star::star::star:

### 题目

给你一个整数数组 nums ，请你求出乘积为正数的最长子数组的长度。

一个数组的子数组是由原数组中零个或者更多个连续数字组成的数组。

请你返回乘积为正数的最长子数组长度。

 

示例  1：

```
输入：nums = [1,-2,-3,4]
输出：4
解释：数组本身乘积就是正数，值为 24 。
```

示例 2：

```
输入：nums = [0,1,-2,-3,-4]
输出：3
解释：最长乘积为正数的子数组为 [1,-2,-3] ，乘积为 6 。
注意，我们不能把 0 也包括到子数组中，因为这样乘积为 0 ，不是正数。
```

示例 3：

```
输入：nums = [-1,-2,-3,0,1]
输出：2
解释：乘积为正数的最长子数组是 [-1,-2] 或者 [-2,-3] 。
```


提示：

- 1 <= nums.length <= 10^5^
- -10^9^ <= nums[i] <= 10^9^

### 代码

- 动态规划

```java
class Solution {
    public int getMaxLen(int[] nums) {
        int n = nums.length;
        int[] poDp = new int[n];
        int[] neDp = new int[n];
        if (nums[0] > 0) {
            poDp[0] = 1;
        } else if (nums[0] < 0) {
            neDp[0] = 1;
        }
        int res = poDp[0];
        for (int i = 1; i < n; i++) {
            if (nums[i] > 0) {
               poDp[i] = poDp[i - 1] + 1;
               neDp[i] = neDp[i - 1] > 0 ? neDp[i - 1] + 1 : 0;
            } else if (nums[i] < 0) {
                poDp[i] = neDp[i - 1] > 0 ? neDp[i - 1] + 1 : 0;
                neDp[i] = poDp[i - 1] + 1;
            } else {
                poDp[i] = 0;
                neDp[i] = 0;
            }
            res = Math.max(res, poDp[i]);
        }
        return res;
    }
}
```

- 动规+状态压缩

```java
class Solution {
    public int getMaxLen(int[] nums) {
        int n = nums.length;
        int poDp0 = 0;
        int neDp0 = 0;
        int poDp;
        int neDp;
        if (nums[0] > 0) {
            poDp0 = 1;
        } else if (nums[0] < 0) {
            neDp0 = 1;
        }
        int res = poDp0;
        for (int i = 1; i < n; i++) {
            if (nums[i] > 0) {
               poDp = poDp0 + 1;
               neDp = neDp0 > 0 ? neDp0 + 1 : 0;
            } else if (nums[i] < 0) {
                poDp = neDp0 > 0 ? neDp0 + 1 : 0;
                neDp = poDp0 + 1;
            } else {
                poDp = 0;
                neDp = 0;
            }
            poDp0 = poDp;
            neDp0 = neDp;
            res = Math.max(res, poDp);
        }
        return res;
    }
}
```

### 笔记

- 动态规划：poDp[i]表示以下标i结尾的乘积（必须乘以nums[i]）为正数的最长子数组长度。
  neDp[i]表示以下标i结尾的乘积（必须乘以nums[i]）为负数的最长子数组长度。

## [1014. 最佳观光组合](https://leetcode-cn.com/problems/best-sightseeing-pair/)

难度：中等:star::star::star::star:

### 题目

给你一个正整数数组 values，其中 values[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的 距离 为 j - i。

一对景点（i < j）组成的观光组合的得分为 values[i] + values[j] + i - j ，也就是景点的评分之和 减去 它们两者之间的距离。

返回一对观光景点能取得的最高分。

 

示例 1：

```
输入：values = [8,1,5,2,6]
输出：11
解释：i = 0, j = 2, values[i] + values[j] + i - j = 8 + 5 + 0 - 2 = 11
```

示例 2：

```
输入：values = [1,2]
输出：2
```


提示：

- 2 <= values.length <= 5 * 10^4^
- 1 <= values[i] <= 1000

### 代码

- 动态规划

```java
class Solution {
    public int maxScoreSightseeingPair(int[] values) {
        int res = 0;
        int preMax = values[0] + 0;
        for (int j = 1; j < values.length; j++) {
            // 求对每一个j的最大值 = max(values[i] + i) + values[j] - j
            res = Math.max(res, preMax + values[j] - j);
            // 求values[i] + i的最大值
            preMax = Math.max(preMax, values[j] + j);
        }
        return res;
    }
}
```

### 笔记

- 思路：已知题目要求 res = A[i] + A[j] + i - j （i < j） 的最大值，
  而对于输入中的每一个 A[j] 来说， 它的值 A[j] 和它的下标 j 都是固定的，
  所以 A[j] - j 的值也是固定的。
  因此，对于每个 A[j] 而言， 想要求 res 的最大值，也就是要求 A[i] + i （i < j） 的最大值，
  所以不妨用一个变量 pre_max 记录当前元素 A[j] 之前的 A[i] + i 的最大值，
  这样对于每个 A[j] 来说，都有 最大得分 = pre_max + A[j] - j，
  再从所有 A[j] 的最大得分里挑出最大值返回即可。
  参考：https://leetcode-cn.com/problems/best-sightseeing-pair/solution/python-jie-fa-by-jiayangwu/

## [122. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

难度：中等:star::star::star::star:

### 题目

给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。

返回 你能获得的 最大 利润 。

 

示例 1：

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
     总利润为 4 + 3 = 7 。
```

示例 2：

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
     总利润为 4 。
```

示例 3：

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
```


提示：

- 1 <= prices.length <= 3 * 10^4^
- 0 <= prices[i] <= 10^4^

### 代码

- 贪心算法

```java
class Solution {
    public int maxProfit(int[] prices) {
        int res = 0;
        int pre = prices[0];
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] > pre) {
                res += prices[i] - pre;
            } 
            pre = prices[i];
        }
        return res;
    }
}
```

- 动态规划

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for (int i = 1; i < n; i++) {
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i-1][0] - prices[i], dp[i-1][1]);
        }
        return dp[n-1][0];
    }
}
```

- 动态规划+状态压缩

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int dp00 = 0;
        int dp01 = -prices[0];
        int dpi0 = 0;
        int dpi1 = -prices[0];
        for (int i = 1; i < n; i++) {
            dpi0 = Math.max(dp00, dp01 + prices[i]);
            dpi1 = Math.max(dp00 - prices[i], dp01);
            dp00 = dpi0;
            dp01 = dpi1;
        }
        return dpi0;
    }
}
```

### 笔记

- 贪心算法：针对这道问题的特殊解法
  贪心算法的直觉：由于不限制交易次数，只要今天股价比昨天高，就交易。
  下面对这个算法进行几点说明：

  - 该算法**仅可以用于计算**，但 **计算的过程并不是真正交易的过程**，但可以用贪心算法计算题目要求的最大利润。下面说明等价性：以 [1, 2, 3, 4] 为例，这 4 天的股价依次上升，按照贪心算法，得到的最大利润是：
  ```
  res =  (prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])
      =  prices[3] - prices[0]
  ```
  仔细观察上面的式子，按照贪心算法，在下标为 1、2、3 的这三天，我们做的操作应该是买进昨天的，卖出今天的，虽然**这种操作题目并不允许**，但是它等价于：在下标为 0 的那一天买入，在下标为 3 的那一天卖出。可以用于计算题目要求的最大利润

  作者：liweiwei1419
  链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/solution/tan-xin-suan-fa-by-liweiwei1419-2/

- 动态规划: 

  - `dp[i][0]`表示到第i天结束，手中**没有股票**时的最大利润。
  - `dp[i][1]`表示到第i天结束，手中**有股票**时的最大利润。

  `dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])`，即如果前一天手中没有股票，那么今天就不用卖出股票，今天就没有新的收入，今天的利润还是等于昨天的利润。如果前一天手中有股票，而今天手中是没有股票的，那么今天要卖出股票，今天的收入就是prices[i]，那今天的利润就是昨天的利润加上今天的收入。所以，今天手中没有股票时的最大利润就前一天手中有股票和前一天手中没有股票两种情况的最大值。
  `dp[i][1] = max(dp[i-1][0] - prices[i], dp[i-1][1])`，即如果前一天手中没有股票，那么今天就要买进股票，今天的支出是prices[i]，今天的利润就是前一天的利润减去今天的支出。如果前一天手中有股票，那么今天就不能再买入股票，今天的利润还是等于昨天的利润。所以，今天手中有股票时的最大利润就是前一天手中有股票和前一天手中没有股票两种情况的最大值。

## [123. 买卖股票的最佳时机 III](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)

难度：困难:star::star::star::star::star:

### 题目

给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1:

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。
```

示例 2：

```
输入：prices = [1,2,3,4,5]
输出：4
解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。   
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。   
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
```

示例 3：

```
输入：prices = [7,6,4,3,1] 
输出：0 
解释：在这个情况下, 没有交易完成, 所以最大利润为 0。
```

示例 4：

```
输入：prices = [1]
输出：0
```


提示：

- 1 <= prices.length <= 10^5^
- 0 <= prices[i] <= 10^5^

### 代码

- 动态规划

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][][] dp = new int[n][3][2];
        dp[0][2][0] = 0;
        dp[0][2][1] = -prices[0];
        dp[0][1][0] = 0;
        dp[0][1][1] = -prices[0];
        dp[0][0][0] = 0;
        for (int i = 1; i < n; i++) {
            dp[i][2][0] = Math.max(dp[i-1][2][0], dp[i-1][2][1] + prices[i]);
            dp[i][2][1] = Math.max(dp[i-1][1][0] - prices[i], dp[i-1][2][1]);
            dp[i][1][0] = Math.max(dp[i-1][1][0], dp[i-1][1][1] + prices[i]);
            dp[i][1][1] = Math.max(dp[i-1][0][0] - prices[i], dp[i-1][1][1]);
        }
        return dp[n-1][2][0];
    }
}
```

- 动规+状态压缩

```java
class Solution {
    public int maxProfit(int[] prices) {
        int dp_i10 = 0;
        int dp_i11 = -prices[0];
        int dp_i20 = 0;
        int dp_i21 = -prices[0];
        for (int price : prices) {
            dp_i20 = Math.max(dp_i20, dp_i21 + price);
            dp_i21 = Math.max(dp_i21, dp_i10 - price);
            dp_i10 = Math.max(dp_i10, dp_i11 + price);
            dp_i11 = Math.max(dp_i11, -price);
        }
        return dp_i20;
    }
}
```

### 笔记

- 动态规划：https://leetcode-cn.com/circle/article/qiAgHn/
  https://labuladong.gitee.io/algo/1/12/

- 买进才算一次交易，卖出不算一次交易

## [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

难度：中等:star::star::star::star:

### 题目

给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

示例 1:

```
输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

示例 2:

```
输入: prices = [1]
输出: 0
```


提示：

- 1 <= prices.length <= 5000
- 0 <= prices[i] <= 1000

### 代码

- 动态规划

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for (int i = 1; i < n; i++) {
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
            dp[i][1] = Math.max((i >= 2 ? dp[i - 2][0] : 0) - prices[i], dp[i-1][1]);
        }
        return dp[n-1][0];
    }
}
```

- 动规+状态压缩

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int dp_00 = 0;
        int dp_01 = -prices[0];
        int dp_i0 = 0;
        int dp_i1 = 0;
        int pre = 0;
        for (int i = 1; i < n; i++) {
            dp_i0 = Math.max(dp_00, dp_01 + prices[i]);
            dp_i1 = Math.max(pre - prices[i], dp_01);
            pre = dp_00;
            dp_00 = dp_i0;
            dp_01 = dp_i1;
        }
        return dp_i0;
    }
}
```

### 笔记

- 动态规划：在有「冷却时间」的情况下，如果在第 i - 1 天卖出了股票，就不能在第 i 天买入股票。因此，如果要在第 i 天买入股票，第二个状态转移方程中就不能使用 `dp[i - 1][0]`，而应该使用 `dp[i - 2][0]`。

## [714. 买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

难度：中等:star::star::star::star:

### 题目

给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

 

示例 1：

```
输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
输出：8
解释：能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
```

示例 2：

```
输入：prices = [1,3,7,5,10,3], fee = 3
输出：6
```


提示：

- 1 <= prices.length <= 5 * 10^4^
- 1 <= prices[i] < 5 * 10^4^
- 0 <= fee < 5 * 10^4^

### 代码

- 动态规划

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for (int i = 1; i < n; i++) {
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i] - fee);
            dp[i][1] = Math.max(dp[i-1][0] - prices[i], dp[i-1][1]);
        }
        return dp[n-1][0];
    }
}
```

- 动态规划

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int n = prices.length;
        int[][] dp = new int[n][2];
        dp[0][0] = 0;
        dp[0][1] = - prices[0] - fee;
        for (int i = 1; i < n; i++) {
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i-1][0] - prices[i] - fee, dp[i-1][1]);
        }
        return dp[n-1][0];
    }
}
```

- 动态规划+状态压缩

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int n = prices.length;
        int dp_00 = 0;
        int dp_01 = -prices[0];
        int dp_i0 = 0;
        int dp_i1 = -prices[0];
        for (int i = 1; i < n; i++) {
            dp_i0 = Math.max(dp_00, dp_01 + prices[i] - fee);
            dp_i1 = Math.max(dp_00 - prices[i], dp_01);
            dp_00 = dp_i0;
            dp_01 = dp_i1;
        }
        return dp_i0;
    }
}
```

- 动态规划+状态压缩

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int n = prices.length;
        int dp_00 = 0;
        int dp_01 = -prices[0]- fee;
        int dp_i0 = 0;
        int dp_i1 = -prices[0];
        for (int i = 1; i < n; i++) {
            dp_i0 = Math.max(dp_00, dp_01 + prices[i]);
            dp_i1 = Math.max(dp_00 - prices[i] - fee, dp_01);
            dp_00 = dp_i0;
            dp_01 = dp_i1;
        }
        return dp_i0;
    }
}
```

- 贪心算法

```java
class Solution {
    public int maxProfit(int[] prices, int fee) {
        int res = 0;
        int minPrice = prices[0];
        for (int i = 1; i < prices.length; i++) {
            minPrice = Math.min(minPrice, prices[i]);
            // 扣除手续费后仍有利润
            if (prices[i] > minPrice + fee) {
                res += prices[i] - minPrice - fee;
                // 要更新最低价，防止在明天收获利润时多减一次手续费
                minPrice = prices[i] - fee;
            }
        }
        return res;
    }
}
```

### 笔记

- 动态规划：

  - 在卖出的时候支付手续费：
  ```
  dp[0][0] = 0;
  dp[0][1] = -prices[0];
  dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i] - fee);
  dp[i][1] = Math.max(dp[i-1][0] - prices[i], dp[i-1][1]);
  ```
  - 在买入的时候支付手续费：
  ```
  dp[0][0] = 0;
  dp[0][1] = - prices[0] - fee; // 注意，第一次买入的时候也要支付手续费
  dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
  dp[i][1] = Math.max(dp[i-1][0] - prices[i] - fee, dp[i-1][1]);
  ```

- 贪心算法：使用贪心策略，就是最低值买，最高值（如果算上手续费还盈利）就卖。

## [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

难度：中等:star::star::star::star:

### 题目

给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

 

示例 1：

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

示例 2：

```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
```

示例 3：

```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```


提示：

- 1 <= s.length <= 300
- 1 <= wordDict.length <= 1000
- 1 <= wordDict[i].length <= 20
- s 和 wordDict[i] 仅有小写英文字母组成
- wordDict 中的所有字符串 互不相同

### 代码

- 动态规划

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        HashSet<String> set = new HashSet<>(wordDict);
        int n = s.length();
        boolean[] dp = new boolean[n + 1];
        dp[0] = true;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                String sub = s.substring(j, i);
                if (dp[j] && set.contains(sub)) {
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[n];
    }
}
```

### 笔记

- 动规：`dp[i] `表示前 i 个字符组成的字符串` s[0...i-1] `能否拆分成若干个字典中出现的单词。
  如果确定`dp[j] `是true，且` [j, i] `这个区间的子串出现在字典里，那么`dp[i]`一定是true。（j < i ）。
  所以递推公式是` if([j, i] 这个区间的子串出现在字典里 && dp[j]是true)` 那么 `dp[i] = true`。

- List转HashSet：

  ``` java
  List<String> wordDict = new ArrayList<>();
  HashSet<String> set = new HashSet<>(wordDict);
  ```

## [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

难度：困难:star::star::star::star::star:

### 题目

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

 

示例 1：

![img](noteImage/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

示例 2：

```
输入：height = [4,2,0,3,2,5]
输出：9
```


提示：

- n == height.length
- 1 <= n <= 2 * 10^4^
- 0 <= height[i] <= 10^5^

### 代码

- 动态规划

```java
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        // 正向遍历，确定每个位置左边的最大值
        int[] leftMax = new int[n];
        leftMax[0] = height[0];
        for (int i = 1; i < n; i++) {
            leftMax[i] = Math.max(leftMax[i-1], height[i]);
        }
        // 反向遍历，确定每个位置右边的最大值
        int[] rightMax = new int[n];
        rightMax[n-1] = height[n-1];
        for (int i = n-2; i > 0; i--) {
            rightMax[i] = Math.max(rightMax[i+1], height[i]);
        }
        int res = 0;
        for (int i = 1; i < n - 1; i++) {
            res += (Math.min(leftMax[i], rightMax[i]) - height[i]);
        }
        return res;
    }
}
```

- 双指针

```java
class Solution {
    public int trap(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int leftMax = 0;
        int rightMax = 0;
        int res = 0;
        while (left < right) {
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);
            if (leftMax < rightMax) {
                res += (leftMax - height[left]);
                left++;
            } else {
                res += (rightMax - height[right]);
                right--;
            }
        }
        return res;
    }
}
```

### 笔记

- 动态规划：`dp[i] = dp[i-1] + min(max([0, ..., i]), max([i, ... , n-1])) - height[i]`
  dp[i]表示截止到第i个位置总共能接到的雨水 = 截止到第i-1个位置总共能接到的雨水 + 第i个位置能接到的雨水。
  第i个位置能接到的雨水 = min(i左边的最高柱子，i右边的最高柱子) - height[i]
  第0个位置和第n-1个位置不能接雨水。
- 双指针的思路是将动规中的leftMax数组和rightMax数组改为了变量。（不太好理解）

## [413. 等差数列划分](https://leetcode.cn/problems/arithmetic-slices/)

难度：中等:star::star::star::star:

### 题目

如果一个数列 至少有三个元素 ，并且任意两个相邻元素之差相同，则称该数列为等差数列。

例如，[1,3,5,7,9]、[7,7,7,7] 和 [3,-1,-5,-9] 都是等差数列。
给你一个整数数组 nums ，返回数组 nums 中所有为等差数组的 子数组 个数。

子数组 是数组中的一个连续序列。

 

示例 1：

```
输入：nums = [1,2,3,4]
输出：3
解释：nums 中有三个子等差数组：[1, 2, 3]、[2, 3, 4] 和 [1,2,3,4] 自身。
```

示例 2：

```
输入：nums = [1]
输出：0
```


提示：

- 1 <= nums.length <= 5000
- -1000 <= nums[i] <= 1000

### 代码

- 动态规划

```java
class Solution {
    public int numberOfArithmeticSlices(int[] nums) {
        int n = nums.length;
        if (n < 3) {
            return 0;
        }
        int[] dp = new int[n];
        dp[0] = 0;
        dp[1] = 0;
        for (int i = 2; i < n; i++) {
            if (nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) {
                dp[i] = dp[i-1] + 1;
            } else {
                dp[i] = 0;
            }
        }
        int res = 0;
        for (int i : dp) {
            res += i;
        }
        return res;
    }

}
```

- 动规+状态压缩

```java
class Solution {
    public int numberOfArithmeticSlices(int[] nums) {
        int n = nums.length;
        if (n < 3) {
            return 0;
        }
        int dp0 = 0;
        int dpi = 0;
        int res = 0;
        for (int i = 2; i < n; i++) {
            if (nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) {
                dpi = dp0 + 1;
            } else {
                dpi = 0;
            }
            dp0 = dpi;
            res += dpi;
        }
        return res;
    }

}
```

### 笔记

- 动态规划：设 dp[i] 表示**以 i 结尾的数组**构成的等差数列的个数。这个数列必须含有nums[i]，所以最后要返回dp数组元素之和。

  如果 nums[i] - nums[i-1] ≠ nums[i-1] - nums[i-2]，说明以 i 结尾的数组无法构成等差数列，dp[i] = 0；否则 dp[i] = 1 + dp[i - 1]。

  结果返回 dp 数组所有元素之和即可。

## [91. 解码方法](https://leetcode.cn/problems/decode-ways/)

难度：中等:star::star::star::star:

### 题目

一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

```
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
```


要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

- "AAJF" ，将消息分组为 (1 1 10 6)
- "KJF" ，将消息分组为 (11 10 6)
  注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。

 

示例 1：

```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```

示例 2：

```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

示例 3：

```
输入：s = "0"
输出：0
解释：没有字符映射到以 0 开头的数字。
含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。
```


提示：

- 1 <= s.length <= 100
- s 只包含数字，并且可能包含前导零。

### 代码

- 动态规划

```java
class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            if (s.charAt(i - 1) != '0') {
                dp[i] = dp[i-1];
            }
            if (i >= 2 && s.charAt(i-2) != '0' && (s.charAt(i-2) - '0') * 10 + (s.charAt(i-1) - '0') <= 26) {
                dp[i] += dp[i-2];
            }
        }
        return dp[n];
    }
}
```

- 动态规划+状态压缩

```java
class Solution {
    public int numDecodings(String s) {
        int n = s.length();
        int dp0 = 1; // i - 2
        int dp1 = 1; // i - 1
        int dpi = 0;
        for (int i = 1; i <= n; i++) {
            dpi = 0;
            if (s.charAt(i - 1) != '0') {
                dpi = dp1;
            }
            if (i >= 2 && s.charAt(i-2) != '0' && (s.charAt(i-2) - '0') * 10 + (s.charAt(i-1) - '0') <= 26) {
                dpi += dp0;
            }
            dp0 = dp1;
            dp1 = dpi;
        }
        return dpi;
    }
}
```

### 笔记

- 动态规划：dp[i]表示字符串s中前i个字符的解码方法总数。对应字符串中的下标是0到i-1。
  考虑到第i个字符（下标为i-1）时的解码方法：
  - 只使用第i个字符。则需要第i个字符不为‘0’。这时的解码方法总数=dp[i-1]，这时方法数是不变的，因为这是一种确定的解码方案，不会增加解码方法的总数。
  - 只使用第i个字符和第i-1个字符。则需要第i-1个字符不为‘0’。并且需要第i-1个字符和第i个字符组成的字符串解码出的数字小于等于26。这时的解码方法总数=dp[i-2]。这也是一种确定的解码方案，不会增加解码方法的总数。
  - 如果对于第i个字符，既可以只使用它自己，也可以使用它和它的前一个一起，那么，dp[i]应该是要把上面两种方案加起来。
  - 注意，dp[0]=1。
- 这种题，对于最后一个状态的考虑，第i个字符要么选，要么个前一个一起选，要么不选（不选的时候，两个if都没进，就跳过了）

## [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)

难度：中等:star::star::star::star:

### 题目

给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。

 

示例 1：

![img](noteImage/uniquebstn3.jpg)

```
输入：n = 3
输出：5
```

示例 2：

```
输入：n = 1
输出：1
```


提示：

- 1 <= n <= 19

### 代码

- 动态规划

```java
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
}
```

### 笔记

- 动态规划：dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]。dp[i] += dp[j - 1] * dp[i - j]; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量

## [264. 丑数 II](https://leetcode.cn/problems/ugly-number-ii/)

难度：中等:star::star::star::star:

### 题目

给你一个整数 n ，请你找出并返回第 n 个 丑数 。

丑数 就是只包含质因数 2、3 和/或 5 的正整数。

 

示例 1：

```
输入：n = 10
输出：12
解释：[1, 2, 3, 4, 5, 6, 8, 9, 10, 12] 是由前 10 个丑数组成的序列。
```

示例 2：

```
输入：n = 1
输出：1
解释：1 通常被视为丑数。
```


提示：

- 1 <= n <= 1690

### 代码

- 优先队列

```java
class Solution {
    private int[] nums = new int[]{2, 3, 5};
    public int nthUglyNumber(int n) {
        HashSet<Long> set = new HashSet<>();
        PriorityQueue<Long> priQueue = new PriorityQueue<>();
        set.add(1L);
        priQueue.add(1L);
        for (int i = 1; i <= n; i++) {
            long x = priQueue.poll();
            if (i == n) {
                return (int)x;
            }
            for (int num : nums) {
                long t = num * x;
                if (!set.contains(t)) {
                    set.add(t);
                    priQueue.add(t);
                }
            }
        }
        return -1;
    }
}
```

- 动态规划

```java
class Solution {
    public int nthUglyNumber(int n) {
        int[] dp = new int[n];
        dp[0] = 1;
        int p2 = 0, p3 = 0, p5 = 0;
        for (int i = 1; i < n; ++i) {
            int next2 = dp[p2] * 2;
            int next3 = dp[p3] * 3;
            int next5 = dp[p5] * 5;
            dp[i] = Math.min(next2, Math.min(next3, next5));
            if (dp[i] == next2) p2++;
            if (dp[i] == next3) p3++;
            if (dp[i] == next5) p5++;
        }
        return dp[n-1];
    }
}
```

### 笔记

- 优先队列：根据丑数的定义，我们有如下结论：
  - 1 是最小的丑数。
  - 对于任意一个丑数 x，其与任意的质因数（2、3、5）相乘，结果（2x、3x、5x）仍为丑数。
  优先队列（小根堆）解法：
  有了基本的分析思路，一个简单的解法是使用优先队列：
  - 起始先将最小丑数 1 放入队列
  - 每次从队列取出最小值 x，然后将 x所对应的丑数 2x、3x 和 5x 进行入队。
  - 对步骤 2 循环多次，第 n次出队的值即是答案。
  为了防止同一丑数多次进队，我们需要使用数据结构 Set 来记录入过队列的丑数。
- 做这样的题目，如果是逐个判断自然数是否为丑数，一定是会超时的。常见的办法是用生成的办法。
- 动态规划：要生成第 n 个丑数，我们必须从第一个丑数 1 开始，向后逐渐的寻找。丑数只包含 2， 3，5 三个因子，所以生成方式就是在已经生成的丑数集合中乘以 [2, 3, 5] 而得到新的丑数。
  现在的问题是在已经生成的丑数集合中，用哪个数字乘以 2？ 用哪个数字乘以 3？用哪个数字乘以 5？
  很显然的一个结论：用还没乘过 2 的最小丑数乘以 2；用还没乘过 3 的最小丑数乘以 3；用还没乘过 5 的最小丑数乘以 5。然后在得到的数字中取最小，就是新的丑数。
  实现的方法是用动态规划：
  - 我们需要定义 3 个指针 index2, index3, index5 分别表示丑数集合中还没乘过 2，3，5 的丑数位置。
  - 然后每次新的丑数 dp[i] = min(dp[index2] * 2, dp[index3] * 3, dp[index5] * 5) 。
  - 然后根据 dp[i] 是由 index2, index3, index5 中的哪个相乘得到的，对应的把此 index + 1，表示还没乘过该 index 的最小丑数变大了。

## [931. 下降路径最小和](https://leetcode.cn/problems/minimum-falling-path-sum/)

难度：中等:star::star::star::star:

### 题目

给你一个 n x n 的 方形 整数数组 matrix ，请你找出并返回通过 matrix 的下降路径 的 最小和 。

下降路径 可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。

 

示例 1：

![img](noteImage/failing1-grid.jpg)

```
输入：matrix = [[2,1,3],[6,5,4],[7,8,9]]
输出：13
解释：如图所示，为和最小的两条下降路径
```


示例 2：

![img](noteImage/failing2-grid.jpg)

```
输入：matrix = [[-19,57],[-40,-5]]
输出：-59
解释：如图所示，为和最小的下降路径
```


提示：

- n == matrix.length == matrix[i].length
- 1 <= n <= 100
- -100 <= matrix[i][j] <= 100

### 代码

- 动态规划

```java
class Solution {
    public int minFallingPathSum(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int[][] dp = new int[m][n];
        for (int i = 0; i < n; i++) {
            dp[0][i] = matrix[0][i];
        }
        for (int i = 1; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (j == 0) {
                    dp[i][j] = Math.min(dp[i-1][j], dp[i-1][j+1]) + matrix[i][j];
                }
                if (j > 0 && j < n - 1) {
                    dp[i][j] = Math.min(dp[i-1][j-1], Math.min(dp[i-1][j], dp[i-1][j+1])) + matrix[i][j];
                }
                if (j == n-1) {
                    dp[i][j] = Math.min(dp[i-1][j-1], dp[i-1][j]) + matrix[i][j];
                }
            }
        }
        int res = Integer.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            // System.out.println(dp[m-1][i]);
            res = Math.min(res, dp[m-1][i]);
        }
        return res;
    }
}
```

### 笔记



## [1314. 矩阵区域和](https://leetcode.cn/problems/matrix-block-sum/)

难度：中等:star::star::star::star:

### 题目

给你一个 m x n 的矩阵 mat 和一个整数 k ，请你返回一个矩阵 answer ，其中每个 answer[i][j] 是所有满足下述条件的元素 mat[r][c] 的和： 

- i - k <= r <= i + k,
- j - k <= c <= j + k 且
- (r, c) 在矩阵内。

示例 1：

```
输入：mat = [[1,2,3],[4,5,6],[7,8,9]], k = 1
输出：[[12,21,16],[27,45,33],[24,39,28]]
```

示例 2：

```
输入：mat = [[1,2,3],[4,5,6],[7,8,9]], k = 2
输出：[[45,45,45],[45,45,45],[45,45,45]]
```


提示：

- m == mat.length
- n == mat[i].length
- 1 <= m, n, k <= 100
- 1 <= mat [i] [j] <= 100

### 代码

- 暴力法

```java
class Solution {
    public int[][] matrixBlockSum(int[][] mat, int k) {
        int m = mat.length;
        int n = mat[0].length;
        int[][] answer = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                for (int r = i - k; r <= i + k; r++) {
                    for (int c = j - k; c <= j + k; c++) {
                        if (r >= 0 && r < m && c >= 0 && c < n) {
                            answer[i][j] += mat[r][c];
                        }
                    }
                }
            }
        }
        return answer;
    }
}
```

- 二维前缀和

```java
class Solution {
    public int[][] matrixBlockSum(int[][] mat, int k) {
        int m = mat.length;
        int n = mat[0].length;
        int[][] dp = new int[m + 1][n + 1];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dp[i+1][j+1] = dp[i][j+1] + dp[i+1][j] + mat[i][j] - dp[i][j];
            }
        }
        int[][] answer = new int[m][n];
        int x1, y1, x2, y2;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                x1 = Math.max(0, i - k);
                y1 = Math.max(0, j - k);
                x2 = Math.min(m, i + k + 1);
                y2 = Math.min(n, j + k + 1);
                answer[i][j] = dp[x2][y2] - dp[x1][y2] - dp[x2][y1] + dp[x1][y1];
            }
        }
        return answer;
    }
}
```

### 笔记

- 二维前缀和：用数组 P 表示数组 mat 的二维前缀和，P 的维数为 (m + 1) * (n + 1)，其中 P[i][j] 表示数组 mat 中以 (0, 0) 为左上角，(i - 1, j - 1) 为右下角的矩形子数组的元素之和。
  题目需要对数组 mat 中的每个位置，计算以 (i - K, j - K) 为左上角，(i + K, j + K) 为右下角的矩形子数组的元素之和，我们可以在前缀和数组的帮助下，通过：
  `sum = P[i + K + 1][j + K + 1] - P[i - K][j + K + 1] - P[i + K + 1][j - K] + P[i - K][j - K]`
  得到元素之和。注意到 i + K + 1、j + K - 1、i - K 和 j - K 这些下标有可能不在矩阵内，因此对于所有的横坐标，我们需要将其规范在 [0, m] 的区间内；对于所有的纵坐标，我们需要将其规范在 [0, n] 的区间内。具体地：
  - i + K + 1 和 j + K - 1 分别可能超过 m 和 n，因此我们需要对这两个坐标与 m 和 n 取较小值，忽略不在矩阵内的部分；
  - i - K 和 j - K 可能小于 0，因此我们需要对这两个坐标与 0 取较大值，忽略不在矩阵内的部分。

## [304. 二维区域和检索](https://leetcode.cn/problems/range-sum-query-2d-immutable/)

难度：中等:star::star::star::star:

### 题目

给定一个二维矩阵 matrix，以下类型的多个请求：

- 计算其子矩形范围内元素的总和，该子矩阵的 左上角 为 (row1, col1) ，右下角 为 (row2, col2) 。

实现 NumMatrix 类：

- NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化
- int sumRegion(int row1, int col1, int row2, int col2) 返回 左上角 (row1, col1) 、右下角 (row2, col2) 所描述的子矩阵的元素 总和 。


示例 1：

![img](noteImage/1626332422-wUpUHT-image.png)

```
输入: 
["NumMatrix","sumRegion","sumRegion","sumRegion"]
[[[[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]],[2,1,4,3],[1,1,2,2],[1,2,2,4]]
输出: 
[null, 8, 11, 12]

解释:
NumMatrix numMatrix = new NumMatrix([[3,0,1,4,2],[5,6,3,2,1],[1,2,0,1,5],[4,1,0,1,7],[1,0,3,0,5]]);
numMatrix.sumRegion(2, 1, 4, 3); // return 8 (红色矩形框的元素总和)
numMatrix.sumRegion(1, 1, 2, 2); // return 11 (绿色矩形框的元素总和)
numMatrix.sumRegion(1, 2, 2, 4); // return 12 (蓝色矩形框的元素总和)
```


提示：

- m == matrix.length
- n == matrix[i].length
- 1 <= m, n <= 200
- -10^5^ <= matrix[i][j] <= 10^5^
- 0 <= row1 <= row2 < m
- 0 <= col1 <= col2 < n
- 最多调用 10^4^ 次 sumRegion 方法

### 代码

- 二维前缀和

```java
class NumMatrix {
    private int[][] dp;
    public NumMatrix(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        // 计算matrix中以(0, 0)为起点到(i-1, j-1)的矩形区域和
        // 周围填充一圈0，避免判断边界
        dp = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1] + matrix[i-1][j-1] - dp[i-1][j-1];
            }
        }
    }
    
    public int sumRegion(int row1, int col1, int row2, int col2) {
        return dp[row2+1][col2+1] - dp[row1][col2+1] - dp[row2+1][col1] + dp[row1][col1];
    }
}

/**
 * Your NumMatrix object will be instantiated and called as such:
 * NumMatrix obj = new NumMatrix(matrix);
 * int param_1 = obj.sumRegion(row1,col1,row2,col2);
 */
```

### 笔记

- 二维前缀和模板：(三叶姐yyds)

  ```java
  // 预处理前缀和数组
  {
      sum = new int[n + 1][m + 1];
      for (int i = 1; i <= n; i++) {
          for (int j = 1; j <= m; j++) {
              // 当前格子(和) = 上方的格子(和) + 左边的格子(和) - 左上角的格子(和) + 当前格子(值)【和是指对应的前缀和，值是指原数组中的值】
              sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + matrix[i - 1][j - 1];
          }
      }
  }
  
  // 首先我们要令左上角为 (x1, y1) 右下角为 (x2, y2)
  // 计算 (x1, y1, x2, y2) 的结果
  {
      // 前缀和是从 1 开始，原数组是从 0 开始，上来先将原数组坐标全部 +1，转换为前缀和坐标
      x1++; y1++; x2++; y2++;
      // 记作 22 - 12 - 21 + 11，然后 不减，减第一位，减第二位，减两位
      // 也可以记作 22 - 12(x - 1) - 21(y - 1) + 11(x y 都 - 1)
      ans = sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1];
  }
  ```

## [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

难度：中等:star::star::star::star:

### 题目

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 

示例 1：

![img](noteImage/robot_maze.png)

```
输入：m = 3, n = 7
输出：28
```

示例 2：

```
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。

1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

示例 3：

```
输入：m = 7, n = 3
输出：28
```

示例 4：

```
输入：m = 3, n = 3
输出：6
```


提示：

- 1 <= m, n <= 100
- 题目数据保证答案小于等于 2 * 10^9^

### 代码

- 动态规划

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (i == 0 || j == 0) {
                    dp[i][j] = 1;
                } else {
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }
            }
        }
        return dp[m-1][n-1];
    }
}
```

### 笔记

## [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)

难度：中等:star::star::star::star:

### 题目

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 1 和 0 来表示。

 

示例 1：

![img](noteImage/robot1.jpg)

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：

1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

示例 2：

![img](noteImage/robot2.jpg)

```
输入：obstacleGrid = [[0,1],[0,0]]
输出：1
```


提示：

- m == obstacleGrid.length
- n == obstacleGrid[i].length
- 1 <= m, n <= 100
- obstacleGrid[i][j] 为 0 或 1

### 代码

- 动态规划

```java
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        int[][] dp = new int[m][n];
        // 初始化dp状态
        for (int i = 0; i < m; i++) {
            if (obstacleGrid[i][0] == 1) {
                dp[i][0] = 0;
                break;
            } else {
                dp[i][0] = 1;
            }
        }
        for (int j = 0; j < n; j++) {
            if (obstacleGrid[0][j] == 1) {
                dp[0][j] = 0;
                break;
            } else {
                dp[0][j] = 1;
            }
        }
        // 状态转移
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 1) {
                    dp[i][j] = 0;
                } else {
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }
            }
        }
        return dp[m-1][n-1];
    }
}
```

### 笔记

- 注意：如果第0行和第0列中某个位置有障碍物，则该位置后面的位置都不能到达

## [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

难度：中等:star::star::star::star:

### 题目

给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

 

示例 1：

![img](noteImage/minpath.jpg)

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

示例 2：

```
输入：grid = [[1,2,3],[4,5,6]]
输出：12
```


提示：

- m == grid.length
- n == grid[i].length
- 1 <= m, n <= 200
- 0 <= grid[i] [j] <= 100

### 代码

- 动态规划

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] dp = new int[m][n];
        dp[0][0] = grid[0][0];
        for (int i = 1; i < m; i++) {
            dp[i][0] = dp[i-1][0] + grid[i][0];
        }
        for (int j = 1; j < n; j++) {
            dp[0][j] = dp[0][j-1] + grid[0][j];
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
            }
        }
        return dp[m-1][n-1];
    }
}
```

### 笔记

## [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

难度：中等:star::star::star::star:

### 题目

给你一个字符串 s，找到 s 中最长的回文子串。

 

示例 1：

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

示例 2：

```
输入：s = "cbbd"
输出："bb"
```


提示：

- 1 <= s.length <= 1000
- s 仅由数字和英文字母组成

### 代码

- 动态规划

```java
class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        int dis = 0;
        int start = 0;
        int end = 0;
        for (int i = n-1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                if (i == j) {
                    dp[i][j] = true;
                }
                else if (s.charAt(i) == s.charAt(j)) {
                    if (j - i >= 2) {
                        dp[i][j] = dp[i+1][j-1];
                    } else {
                        dp[i][j] = true;
                    }
                } 
                else if (s.charAt(i) != s.charAt(j)) {
                    dp[i][j] = false;
                }
                if (dp[i][j] && (j - i > dis)) {
                    dis = j - i;
                    start = i;
                    end = j;
                }
            }
        }
        return s.substring(start, end+1);
    }
}
```

- 中心扩展

```java
class Solution {
    private int start = 0;
    private int end = 0;
    public String longestPalindrome(String s) {
        for (int i = 0; i < s.length(); i++) {
            // 回文串是奇数
            int l = i - 1;
            int r = i + 1;
            int[] sub = getSub(s, l, r);
            if (sub[1] - sub[0] > end - start) {
                start = sub[0];
                end = sub[1];
            }
            // 回文串是偶数
            l = i - 1;
            r = i + 1 - 1;
            sub = getSub(s, l, r);
            if (sub[1] - sub[0] > end - start) {
                start = sub[0];
                end = sub[1];
            }
        }
        return s.substring(start, end + 1);
    }

    public int[] getSub(String s, int l, int r) {
        while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {
            l--;
            r++;
        }
        // 返回当前最长回文子串的左右下标
        return new int[]{l + 1, r - 1};
    }
}
```



### 笔记

- 动态规划：`dp[i][j]`表示字符串s中的子串`s[i : j]`(含有第i个字符和第j个字符）是否是回文子串，如果是，则为true，如果不是，则为false。
  初始条件：对角线元素都为true，即`i==j,dp[i][j]=true`，因为只有一个字符。
  状态转移：`if s[i] == s[j]: dp[i][j]=dp[i+1][j-1]`。即如果第i个字符和第j个字符相等，则i到j的子串是否为回文子串就取决于从i+1到j-1的子串是否为回文子串。
  `if s[i] != s[j]: dp[i][j]=false`。即如果第i个字符和第j个字符不相等，则i到j的子串一定不是回文子串。

  注意：
  - `j >= i`。j在右边，i在左边。
  - `dp[i][j]`依赖于`dp[i+1][j-1]`，所以i要从后往前遍历，j要从前往后遍历，又j需要大于等于i，所以j从i开始往后遍历
  - 一个技巧，可以在循环中初始化对角线。
  - 一些特殊情况，比如对于`cbbd`，i=1,j=2的时候(s[1]==s[2])，按照上面的转移方程，`dp[1][2]=dp[2][1]`，这时`dp[2][1]`是没有被算出来，也是不合法的，因为我们要j>=i。这时就不能按照转移方程来推导，要单独处理。即如果j=i+1，并且s[i]==s[j]时，`dp[i][j]=true`。

- 子串一定是连续的，子序列不一定是连续的。
  子串用bool类型，子序列用长度。
  这种题都是讨论s.charAt(i)和s.charAt(j)是否相等，相等时的状态转移方程是什么什么，不相等时的状态转移方程是什么什么。

- 中心扩展：三叶姐：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/shua-chuan-lc-po-su-jie-fa-manacher-suan-i2px/

  首先枚举回文串的中心 i，然后分两种情况向两边扩展边界，直到达到边界或者不满足回文串定义为止：
  - 回文串长度是奇数，则依次判断 s[i − k] == s[i + k], k = 1,2,3…
  - 回文串长度是偶数，则依次判断 s[i − k] == s[i + k − 1], k = 1,2,3…

## [516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/)

难度：中等:star::star::star::star:

### 题目

给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。

 

示例 1：

```
输入：s = "bbbab"
输出：4
解释：一个可能的最长回文子序列为 "bbbb" 。
```

示例 2：

```
输入：s = "cbbd"
输出：2
解释：一个可能的最长回文子序列为 "bb" 。
```


提示：

- 1 <= s.length <= 1000
- s 仅由小写英文字母组成

### 代码

- 动态规划

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[][] dp = new int[n][n];
        int res = 1;
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i; j < n; j++) {
                // 对角线都是1
                if (i == j) {
                    dp[i][j] = 1;
                    continue;
                }
                // 状态转移
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i+1][j-1] + 2;
                }
                else {
                    dp[i][j] = Math.max(dp[i][j-1], dp[i+1][j]);
                }
                res = Math.max(res, dp[i][j]);
            }
        }
        return res;
    }
}
```

### 笔记

- 动态规划：`dp[i][j]`表示字符串s中的闭区间i到j的最长回文子序列的长度。如果第i个字符和第j个字符相等，那么从i到j的最长回文子序列的长度就等于从i+1到j-1的最长回文子序列的长度加2。**如果第i个字符和第j个字符不相等，那么从i到j的最长回文子序列的长度就等于从i到j-1的最长回文子序列长度或者从i+1到j的最长回文子序列的长度，具体来说，就是取两者的最大值**。
- 子序列是可以不连续的，定义dp数组时，`dp[i][j]`通常定义为子序列的长度

## [300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

难度：中等:star::star::star::star:

### 题目

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例 1：

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

示例 2：

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

示例 3：

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```


提示：

- 1 <= nums.length <= 2500
- -10^4^ <= nums[i] <= 10^4^


进阶：

- 你能将算法的时间复杂度降低到 O(n log(n)) 吗?

### 代码

- 动态规划

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        // dp[i]表示以nums[i]这个数结尾的最长递增子序列的长度
        int[] dp = new int[n];
        // 初始化
        Arrays.fill(dp, 1);
        for (int i = 1; i < n; i++) {
            // dp[j]是i之前的数组中以nums[j]结尾的最长递增子序列
            for (int j = 0; j < i; j++) {
                // 可以把nums[i]接在nums[j]后面
                if (nums[i] > nums[j]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
        }
        // 找dp[i]中的最大值
        int res = 0;
        for (int i = 0; i < n; i++) {
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

- 贪心+二分

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        int[] d = new int[n+1];
        d[1] = nums[0];
        int size = 1;
        for (int i = 1; i < n; i++) {
            if (nums[i] > d[size]) {
                d[++size] = nums[i];
            } else {
                int left = 1, right = size;
                while (left < right) {
                    int mid = (left + right) >> 1;
                    if (d[mid] >= nums[i]) {
                        right = mid;
                    } else {
                        left = mid + 1;
                    }
                }
                int p = d[left] >= nums[i] ? left : 1;
                d[p] = nums[i];
            }
        }
        return size;
    }
}
```

### 笔记

- 动态规划：dp[i]表示**以nums[i]这个数结尾**的最长递增子序列的长度

- 贪心算法：一个新员工一个老员工价值相当，老员工就可以走了，因为新员工被榨取的剩余空间更多。

  整个算法流程为：
  设当前已求出的最长上升子序列的长度为 len（初始时为 1），从前往后遍历数组 nums，在遍历到nums[i] 时：
  - 如果 nums[i] > d[len] ，则直接加入到 d 数组末尾，并更新len=len+1；
  - 否则，在 d 数组中二分查找，找到第一个比nums[i] 小的数 d[k]，并更新 d[k+1]=nums[i]。

  注意：贪心算法是需要证明的，比较复杂，就不证明了。但从算法流程上来说，比较直观。

## [376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)

难度：中等:star::star::star::star:

### 题目

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 摆动序列 。第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。

- 相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。

 

示例 1：

```
输入：nums = [1,7,4,9,2,5]
输出：6
解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
```

示例 2：

```
输入：nums = [1,17,5,10,13,15,10,5,16,8]
输出：7
解释：这个序列包含几个长度为 7 摆动序列。
其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
```

示例 3：

```
输入：nums = [1,2,3,4,5,6,7,8,9]
输出：2
```


提示：

- 1 <= nums.length <= 1000
- 0 <= nums[i] <= 1000


进阶：你能否用 O(n) 时间复杂度完成此题?

### 代码

- 动态规划

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int n = nums.length;
        if (n < 2) {
            return n;
        }
        int[] up = new int[n];
        int[] down = new int[n];
        up[0] = 1;
        down[0] = 1;
        for (int i = 1; i < n; i++) {
            if (nums[i] < nums[i-1]) {
                up[i] = up[i-1];
                down[i] = Math.max(up[i - 1] + 1, down[i - 1]);
            } else if (nums[i] > nums[i-1]) {
                up[i] = Math.max(up[i - 1], down[i - 1] + 1);
                down[i] = down[i - 1];
            } else {
                up[i] = up[i-1];
                down[i] = down[i-1];
            }
        }
        return Math.max(up[n-1], down[n-1]);
    }
}
```

- 动态规划+状态压缩

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int n = nums.length;
        if (n < 2) {
            return n;
        }
        int up = 1, down = 1;
        for (int i = 1; i < n; i++) {
            if (nums[i] < nums[i-1]) {
                down = Math.max(up + 1, down);
            } else if (nums[i] > nums[i-1]) {
                up = Math.max(up, down + 1);
            }
        }
        return Math.max(up, down);
    }
}
```

- 动态规划+状态压缩

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int n = nums.length;
        if (n < 2) {
            return n;
        }
        int up = 1, down = 1;
        for (int i = 1; i < n; i++) {
            if (nums[i] < nums[i-1]) {
                down = up + 1;
            } else if (nums[i] > nums[i-1]) {
                up = down + 1;
            }
        }
        return Math.max(up, down);
    }
}
```

- 贪心

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int n = nums.length;
        if (n < 2) {
            return n;
        }
        int curDiff = 0; // 当前一对差值
        int preDiff = 0; // 前一对差值
        int res = 1; // 记录峰值个数， 默认序列最右边有一个峰值
        for (int i = 0; i < n - 1; i++) {
            curDiff = nums[i+1] - nums[i];
            // 出现峰值
            if ((curDiff > 0 && preDiff <= 0) || (curDiff < 0 && preDiff >= 0)) {
                res++;
                preDiff = curDiff;
            }
        }
        return res;
    }
}
```

### 笔记

- 动态规划：
  - 某个序列被称为「上升摆动序列」，**当且仅当该序列是摆动序列，且最后一个元素呈上升趋势**。
  - 某个序列被称为「下降摆动序列」，**当且仅当该序列是摆动序列，且最后一个元素呈下降趋势**。
  - 特别地，对于长度为 1 的序列，它既是「上升摆动序列」，也是「下降摆动序列」。
  - up[i] 表示以前 i 个元素中的某一个为结尾的最长的「上升摆动序列」的长度。
  - down[i] 表示以前 ii 个元素中的某一个为结尾的最长的「下降摆动序列」的长度。
    状态转移：
  - up[i]的状态转移：
  	- if nums[i] <= nums[i-1]，则nums[i]不能被添加到up[i-1]的后面，up[i] = up[i-1]。
  	- if nums[i] > nums[i-1]，则nums[i]可以被添加到down[i-1]的后面得到一个新的上升摆动序列，up[i]=max(up[i-1], down[i-1]+1)
  - down[i]的状态转移：
  	- if nums[i] >= nums[i-1]，则nums{i]不能被添加到down[i]的后面，down[i] = down[i-1]
  	- if nums[i] < nums[i-1]，则nums[i]可以被添加到up[i-1]的后面得到一个新的下降摆动序列，down[i]=max(down[i-1], up[i-1]+1)
- 状态压缩：过程中 down 与 up 的差的绝对值值恒不大于 1，即 up≤down+1 且down≤up+1，于是有max(up,down+1)=down+1 且 max(up+1,down)=up+1。这样我们可以省去不必要的比较大小的过程。
- 贪心：我们只需要统计该序列中「峰」与「谷」的数量即可（注意序列两端的数也是「峰」或「谷」），但需要注意处理相邻的相同元素。
  在实际代码中，我们记录当前序列的上升下降趋势。每次加入一个新元素时，用新的上升下降趋势与之前对比，如果出现了「峰」或「谷」，答案加一，并更新当前序列的上升下降趋势。

## [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

难度：中等:star::star::star::star:

### 题目

给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

 

示例 1：

```
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
```

示例 2：

```
输入：text1 = "abc", text2 = "abc"
输出：3
解释：最长公共子序列是 "abc" ，它的长度为 3 。
```

示例 3：

```
输入：text1 = "abc", text2 = "def"
输出：0
解释：两个字符串没有公共子序列，返回 0 。
```


提示：

- 1 <= text1.length, text2.length <= 1000
- text1 和 text2 仅由小写英文字符组成。

### 代码

- 动态规划

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][] dp = new int[m+1][n+1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (text1.charAt(i-1) == text2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i][j-1], dp[i-1][j]);
                }
            }
        }
        return dp[m][n];
    }
}
```

### 笔记

- 动态规划：`dp[i][j]`表示text1中从0到i的子串与text2中从0到j的子串的最长公共子序列的长度。
  状态转移：
  - `if text1[i] == text2[j]: dp[i][j] = dp[i-1][j-1] + 1`。如果text1中的第i个字符和text2中的第j个字符相同，说明该字符可以加入到公共子序列中，则长度就等于两个子串除去该字符后的最长公共子序列长度加1。
  - `if text1[i] != text2[j]: dp[i][j] = max(dp[i][j-1], dp[i-1][j]`。如果text1中的第i个字符和text2中的第j个字符不相同，说明该字符不可以加入到公共子序列中，则长度就等于第1个子串除去该字符后与第2个子串的最长公共子序列长度或者第1个子串与第2个子串的最长公共子序列长度。具体取哪一个呢？取两者的最大值即可。

## [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

难度：困难:star::star::star::star::star:

### 题目

给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数  。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

示例 1：

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

示例 2：

```
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```


提示：

- 0 <= word1.length, word2.length <= 500
- word1 和 word2 由小写英文字母组成

### 代码

- 动态规划

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        int[][] dp = new int[m+1][n+1];
        // 初始化
        for (int i = 0; i <= m; i++) {
            dp[i][0] = i;
        }
        for (int j = 0; j <= n; j++) {
            dp[0][j] = j;
        }
        // 状态转移
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (word1.charAt(i-1) == word2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;
                }
            }
        }
        return dp[m][n];
    }
}
```

### 笔记

- 动态规划：设 `dp[i][j]` 表示将 word1 前 i 个字符组成的字符串 `word1[0...i-1]` 转换成 word2 前 j 个字符组成的字符串 `word2[0...j-1]` 的最小操作次数。m, n 分别表示 word1, word2 的长度。
  初始化 `dp[i][0] = i（i∈[0, m]），dp[0][j] = j （j∈[0, m]）`。
  i, j 分别从 1 开始遍历，判断 `word1[i - 1]` 与 `word2[j - 1] `是否相等：
  - 若 `word1[i - 1] == word2[j - 1]`，则` dp[i][j] = dp[i - 1][j - 1]`。
  - 若 `word1[i - 1] != word2[j - 1]`，则 `dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1`。其中` dp[i - 1][j] + 1 `对应插入操作，`dp[i][j - 1] + 1 `对应删除操作，`dp[i - 1][j - 1] + 1 `对应替换操作。取三者的最小值即可。

## [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

难度：中等:star::star::star::star:

### 题目

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

 

示例 1：

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

示例 2：

```
输入：coins = [2], amount = 3
输出：-1
```

示例 3：

```
输入：coins = [1], amount = 0
输出：0
```


提示：

- 1 <= coins.length <= 12
- 1 <= coins[i] <= 2^31^ - 1
- 0 <= amount <= 10^4

### 代码

- 动态规划

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int j = 0; j < coins.length; j++) {
                if (i >= coins[j]) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] == amount + 1 ? -1 : dp[amount];
    }
}
```

### 笔记

- 当看到题目是给定一些「物品」，让我们从中进行选择，以达到「最大价值」或者「特定价值」时，我们应该联想到「背包问题」。

- 动态规划：dp[i]表示凑出金额i需要的最少硬币个数。
  对于：`coins = [1, 2, 5], amount = 11`来说。
  `dp[11]=min(dp[10], dp[9], dp[6]) + 1`。即，凑出11所需要的最少硬币数等于：

  - 凑出10所需要的最少硬币数加1（已经凑出10块，再用一个1块的就够了）
  - 凑出9所需要的最少硬币数加1（已经凑出9块，再用一个2块的就够了）
  - 凑出6所需要的最少硬币数加1（已经凑出6块，再用一个5块的就够了）
  - 那么到底选上面哪一种方案呢？肯定选这3种方案中需要硬币数最少的那一个方案了。
  写成一般形式：
  dp[i] = min(dp[i-1], dp[i-2], dp[i-5]) + 1。i=0,1,...,11，i表示目标金额是0,1,2,...,11。
  更一般的状态转移方程：
  `dp[i] = min(dp[i-coins[j]])+1`。`0<=j<coins.length`;。在代码实现上，可以在循环中这么写：`dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);`

  关于初始化：dp[0] = 0。表示凑出目标金额为0,需要0个硬币。由于在循环中要和dp[i]比较取最小值，所以dp的其它值初始化为一个较大的值，这里是取amount+1，表示凑出目标金额需要的最多的硬币个数加1（全部使用面额为1的，需要amount个，再加1，就确保在比较时一定会取dp[i - coins[j]] + 1）。

## [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-2/)

难度：中等

### 题目

给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。

假设每一种面额的硬币有无限个。 

题目数据保证结果符合 32 位带符号整数。

 

示例 1：

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

示例 2：

```
输入：amount = 3, coins = [2]
输出：0
解释：只用面额 2 的硬币不能凑成总金额 3 。
```

示例 3：

```
输入：amount = 10, coins = [10] 
输出：1
```


提示：

- 1 <= coins.length <= 300
- 1 <= coins[i] <= 5000
- coins 中的所有值 互不相同
- 0 <= amount <= 5000

### 代码

- 动态规划

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int j = 0; j < coins.length; j++) {
            for (int i = 1; i <= amount; i++) {
                if (i >= coins[j]) {
                    dp[i] += dp[i-coins[j]];
                    // System.out.println(dp[i]);
                }
            }
        }
        return dp[amount];
    }
}
```

### 笔记

- 动态规划：`dp[i] += dp[i-coins[j]], j = 0, 1, ..., n-1;`，dp[i]表示凑出金额i的硬币组合数。dp[0]=1；表示凑出0块的**组合数为1**，
- **如果求组合数就是外层for循环遍历物品，内层for遍历背包。
  如果求排列数就是外层for遍历背包，内层for循环遍历物品。**
- 关于遍历顺序：例如，coins[1,2]，对于dp[3]的计算，一定是先遍历硬币面额1（coins[0]），后遍历面额2（coins[1]）,只会出现以下2中组合：
  3 = 1 + 1 + 1
  3 = 1 + 2
  硬币面额2不能出现在硬币面额1之前，即不会重复计算3=2+1的情况。

## [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)

难度：中等:star::star::star::star:

### 题目



给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

 

示例 1：

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

示例 2：

```
输入：nums = [9], target = 3
输出：0
```


提示：

- 1 <= nums.length <= 200
- 1 <= nums[i] <= 1000
- nums 中的所有元素 互不相同
- 1 <= target <= 1000

进阶：如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？

### 代码

- 动态规划

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target + 1];
        dp[0] = 1;
        for (int i = 1; i <= target; i++) {
            for (int j = 0; j < nums.length; j++) {
                if (i >= nums[j]) {
                    dp[i] += dp[i - nums[j]];
                }
            }
        }
        return dp[target];
    }
}
```

### 笔记

- 动态规划：nums的每个元素可以选取多次，且需要考虑选取元素的顺序。由于需要考虑选取元素的顺序，因此这道题需要计算的是选取元素的排列数。
  dp[i]表示选取的元素之和等于i的方案数。由于考虑顺序，(1, 3)
  3, 1)都是可行的，所以对每一个目标金额，都是从nums[0]开始遍历。查找可行的方案数。



## [343. 整数拆分](https://leetcode.cn/problems/integer-break/)

难度：中等:star::star::star::star:

### 题目

给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。

返回 你可以获得的最大乘积 。

 

示例 1:

```
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

示例 2:

```
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```


提示:

- 2 <= n <= 58

### 代码

- 动态规划

```java
class Solution {
    public int integerBreak(int n) {
        int[] dp = new int[n+1];
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 0; j <= i; j++) {
                dp[i] = Math.max(dp[i], Math.max(dp[i-j], i-j) * j);
            }
        }
        return dp[n];
    }
}
```

### 笔记

- 动态规划：dp[i]表示拆分整数i可以得到的最大乘积。
  一般来说：`dp[i] = max(dp[i-j] * j), j=0,1,..., i`，这个好理解，就是凑成i能得到的最大乘积就等于凑成i-j的最大乘积乘以j。举例来说：
  dp[0] = 0,表示凑成0的k个整数的乘积最大值为0；
  dp[1] = 1，表示凑成1的k个整数的乘积最大值为1；
  j为什么可以取0，举例来说明：
  dp[2] = max(dp[2] * 0, dp[1] * 1) = max(0, 1) = 1;
  dp[3] = max(dp[3] * 0, dp[2] * 1, dp[1] * 2)? 确定吗？dp[3]真是这样转移的吗？
  dp[2]=1是没错，但是，当计算dp[3]的时候，取dp[3] = dp[2] * 1 = 1 * 1 = 1的时候，dp[2]表示2被拆成1+1，也即3被拆成1+1+1。其实，3应该被拆成2 + 1或者1 + 2，乘积才是最大的。总的来说，计算dp[3]的时候，不是直接取dp[2]，而是应该看dp[2]和2谁大谁小，取大的那一个，对于3来说，要看2是取被拆还是不被拆，两者的最大值。
  所以，dp[3] = max(dp[3] * 0, max(dp[2], 2) * 1, max(dp[1], 1) * 2) = max(0, 2, 2) = 2。
  所以，真正的状态转移方程是：`dp[i] = max(max(d[i-j], i-j) * j), j=0,1,..., i`

















