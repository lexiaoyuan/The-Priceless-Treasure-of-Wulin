[TOC]

# 力扣刷题笔记（三）

## [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

难度：简单:star::star::star:

### 题目

给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。

示例 1：

![img](noteImage/removelinked-list.jpg)

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

示例 2：

```
输入：head = [], val = 1
输出：[]
```

示例 3：

```
输入：head = [7,7,7,7], val = 7
输出：[]
```

提示：

- 列表中的节点数目在范围 [0, 10^4^] 内
- 1 <= Node.val <= 50
- 0 <= val <= 50

### 代码

- 哑巴节点+快慢指针

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode();
        dummy.next = head;
        ListNode fast = head;
        ListNode slow = dummy;
        while (fast != null) {
            if(fast.val == val) {
                fast = fast.next;
                slow.next = fast;
            } else {
                fast = fast.next;
                slow = slow.next;
            }
        }
        return dummy.next;
    }
}
```

- 递归

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        if (head == null) {
            return head;
        }
        head.next = removeElements(head.next, val);
        if (head.val == val) {
            return head.next;
        } else {
            return head;
        }
    }
}
```

### 笔记

- 递归法：**链表的定义具有递归的性质，因此链表题目常可以用递归的方法求解。**
  首先递归的删除head后面的结点，然后判断head自己是否需要删除。
  对于给定的链表，**首先对除了头节点 head 以外的节点进行删除操作**，然后判断head 的节点值是否等于给定的 val。如果 head 的节点值等于val，则 head 需要被删除，因此删除操作后的头节点为 head.next；如果head 的节点值不等于val，则 head 保留，因此删除操作后的头节点还是head。上述过程是一个递归的过程。
  
  递归的终止条件是head 为空，此时直接返回 head。当 head 不为空时，递归地进行删除操作，然后判断head 的节点值是否等于 val 并决定是否要删除head。

## [205. 同构字符串](https://leetcode-cn.com/problems/isomorphic-strings/)

难度：简单:star::star::star:

### 题目

给定两个字符串 s 和 t ，判断它们是否是同构的。

如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。

每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。

示例 1:

```
输入：s = "egg", t = "add"
输出：true
```

示例 2：

```
输入：s = "foo", t = "bar"
输出：false
```

示例 3：

```
输入：s = "paper", t = "title"
输出：true
```

提示：

- 1 <= s.length <= 5 * 104
- t.length == s.length
- s 和 t 由任意有效的 ASCII 字符组成

### 代码

- 哈希表

```java
class Solution {
    public boolean isIsomorphic(String s, String t) {
        HashMap<Character, Character> map = new HashMap<>();
        for(int i = 0; i < s.length(); i++) {
            if (map.containsKey(s.charAt(i))) {
                if (map.get(s.charAt(i)) != t.charAt(i)) {
                    return false;
                }
            } else {
                if (map.containsValue(t.charAt(i))) {
                    return false;
                }
                map.put(s.charAt(i), t.charAt(i));
            }
        }
        return true;
    }
}
```

- 巧妙法

```java
class Solution {
    public boolean isIsomorphic(String s, String t) {
        for(int i = 0; i < s.length(); i++) {
            if(s.indexOf(s.charAt(i)) != t.indexOf(t.charAt(i))) {
                return false;
            }
        }
        return true;
    }
}
```

### 笔记

- 哈希表本身就是反映映射关系的，看到映射关系就要想到哈希表。这个题就是一个构造特殊一点的哈希表，即相同的键对应相同的值（相同字符只能映射到同一个字符上），相同的值对应相同的键（不同字符不能映射到同一个字符上）。能构造成功，即存在某种映射关系，就返回true，否则就返回false。
- 巧妙的方法：同一个位置的字符第一次出现的下标是一样的就是同构，否则就不同构。

## [217. 存在重复元素](https://leetcode-cn.com/problems/contains-duplicate/)

难度：简单:star::star::star:

### 题目

给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true ；如果数组中每个元素互不相同，返回 false 。

示例 1：

```
输入：nums = [1,2,3,1]
输出：true
```

示例 2：

```
输入：nums = [1,2,3,4]
输出：false
```

示例 3：

```
输入：nums = [1,1,1,3,3,4,3,2,4,2]
输出：true
```

提示：

- 1 <= nums.length <= 10^5^
- -10^9^ <= nums[i] <= 10^9^

### 代码

- HashSet

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        HashSet<Integer> set = new HashSet<>();
        for(int num : nums) {
            set.add(num);
        }
        return set.size() < nums.length;
    }
}
```

- HashMap

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int num: nums) {
            if (map.containsKey(num)) {
                map.put(num, map.get(num) + 1);
                if (map.get(num) >= 2) {
                    return true;
                }
            }
            else {
                map.put(num, 1);
            }
        }
        return false;
    }
}
```

- 优化HashSet

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        HashSet<Integer> set = new HashSet<>();
        for(int num : nums) {
            if (set.contains(num)) {
                return true;
            }
            set.add(num);
        }
        return false;
    }
}
```

- 排序

```java
class Solution {
    public boolean containsDuplicate(int[] nums) {
        Arrays.sort(nums);
        for(int i=0; i < nums.length - 1; i++) {
            if (nums[i] == nums[i+1]) {
                return true;
            }
        }
        return false;
    }
}
```

### 笔记

- 对数组进行排序：

```java
Arrays.sort(nums); // 升序
```

## [219. 存在重复元素 II](https://leetcode-cn.com/problems/contains-duplicate-ii/)

难度：简单:star::star::star:

### 题目

给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) <= k 。如果存在，返回 true ；否则，返回 false 。

示例 1：

```
输入：nums = [1,2,3,1], k = 3
输出：true
```

示例 2：

```
输入：nums = [1,0,1,1], k = 1
输出：true
```

示例 3：

```
输入：nums = [1,2,3,1,2,3], k = 2
输出：false
```

提示：

- 1 <= nums.length <= 10^5^
- -10^9^ <= nums[i] <= 10^9^
- 0 <= k <= 10^5^

### 代码

- 哈希表

```java
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < nums.length; i++) {
            if (map.containsKey(nums[i])) {
                if (Math.abs(i - map.get(nums[i])) <= k) {
                    return true;
                }
            }
            map.put(nums[i], i);
        }
        return false;
    }
}
```

- 滑动窗口+HashSet

```java
class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        HashSet<Integer> set = new HashSet<>();
        for(int i = 0; i < nums.length; i++) {
            if (i > k) {
                set.remove(nums[i-k-1]);
            }
            if (set.contains(nums[i])) {
                return true;
            }
            set.add(nums[i]);
        }
        return false;
    }
}
```

### 笔记

- Java计算绝对值：
  
  ```java
  Math.abs(a-b);
  ```

- 看到类似这种`abs(i - j) <= k`表示一个区间的，就可以考虑使用滑动窗口。

- 滑动窗口：维护一个长度为k的窗口，**每来一个元素，就看它是否在窗口中（窗口内的元素个数是<=k的）**，如果在，那么这两个相等元素一定满足`abs(i - j) <= k`，就可以返回true。同时，为了保持窗口的大小是k，当i>k的时候，就要移除窗口内的第一个元素。

- 三叶姐姐YYDS：
  整理题意：是否存在长度不超过的 k + 1窗口，窗口内有相同元素。
  
  我们可以从前往后遍历 nums，同时使用 Set 记录遍历当前滑窗内出现过的元素。
  
  假设当前遍历的元素为 nums[i]：
  
  - 下标小于等于 k（起始滑窗长度还不足 k + 1）：直接往滑窗加数，即将当前元素加入 Set 中；
  - 下标大于 k：将上一滑窗的左端点元素 nums[i - k - 1] 移除，判断当前滑窗的右端点元素 nums[i] 是否存在 Set 中，若存在，返回 True，否则将当前元素 nums[i] 加入 Set 中。
    重复上述过程，若整个 nums 处理完后仍未找到，返回 False。

## [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)

难度：简单:star::star::star:

### 题目

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。

实现 MyStack 类：

void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。

注意：

你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。

示例：

输入：

```
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]

解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False
```

提示：

- 1 <= x <= 9
- 最多调用100 次 push、pop、top 和 empty
- 每次调用 pop 和 top 都保证栈不为空

进阶：你能否仅用一个队列来实现栈。

### 代码

- 两个队列

```java
class MyStack {
    private Queue<Integer> queue1;
    private Queue<Integer> queue2;

    public MyStack() {
        queue1 = new LinkedList<>();
        queue2 = new LinkedList<>();
    }

    public void push(int x) {
        queue1.offer(x);
    }

    public int pop() {
        while(queue1.size()>1) {
            queue2.offer(queue1.poll());
        }
        while(!queue2.isEmpty()) {
            queue1.offer(queue2.poll());
        }
        return queue1.poll();
    }

    public int top() {
        while(queue1.size()>1) {
            queue2.offer(queue1.poll());
        }
        while(!queue2.isEmpty()) {
            queue1.offer(queue2.poll());
        }
        int result = queue1.peek();
        queue1.offer(queue1.poll());
        return result;
    }

    public boolean empty() {
        return queue1.isEmpty();
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */
```

- 一个队列

```java
class MyStack {
    private Queue<Integer> queue;

    public MyStack() {
        queue = new LinkedList<>();
    }

    public void push(int x) {
        queue.offer(x);
    }

    public int pop() {
        int num = queue.size();
        while(num > 1) {
            queue.offer(queue.poll());
            num--;
        }
        return queue.poll();
    }

    public int top() {
        int num = queue.size();
        while(num > 1) {
            queue.offer(queue.poll());
            num--;
        }
        int result = queue.peek();
        queue.offer(queue.poll());
        return result;
    }

    public boolean empty() {
        return queue.isEmpty();
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */
```

### 笔记

- 两个队列：一个队列存储所有元素，另一个队列作为中间队列，当需要pop时，即需要弹出队列的最后一个元素，则先把一个队列中的前n-1个元素，放到第二个队列中，再把第二个队列中的元素放到第一个队列中，也即放到最后一个元素的后面，然后将队首元素出队。需要top时，也是同样的操作，不过，最后一步是选择队首元素，选择完之后，要将队首元素重新放到最后面，这样就保证了top时，没有改变队列中元素的原本顺序，只是先把队尾元素调到队头，然后输出一下，然后重新把它调回队尾。
- 一个队列：原理同两个队列一样，只是出队前，先用一个num记录队列中原本有多少个元素，然后出队num-1个，出队后立刻将其添加到原队列的队尾。

## [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

难度：简单:star::star::star:

### 题目

给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。

示例 1：

![img](noteImage/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

示例 2：

![img](noteImage/invert2-tree.jpg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

示例 3：

```
输入：root = []
输出：[]
```

提示：

- 树中节点数目范围在 [0, 100] 内
- -100 <= Node.val <= 100

### 代码

- 递归

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root != null) {
            TreeNode tmp = invertTree(root.left);
            root.left = invertTree(root.right);
            root.right = tmp;
        }
        return root;
    }
}
```

- 层次遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root != null) {
            Queue<TreeNode> queue = new LinkedList<>();
            queue.offer(root);
            while(!queue.isEmpty()) {
                TreeNode p = queue.poll();
                if (p != null) {
                    TreeNode tmp = p.left;
                    p.left = p.right;
                    p.right = tmp;
                    queue.offer(p.left);
                    queue.offer(p.right);
                }
            }
        }
        return root;
    }
}
```

### 笔记

- 递归：交换左右子树，类似于交换两个变量的值，中间需要引入一个tmp

## [228. 汇总区间](https://leetcode-cn.com/problems/summary-ranges/)

难度：简单:star::star::star:

### 题目

给定一个  无重复元素 的 有序 整数数组 nums 。

返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。

列表中的每个区间范围 [a,b] 应该按如下格式输出：

"a->b" ，如果 a != b
"a" ，如果 a == b

示例 1：

```
输入：nums = [0,1,2,4,5,7]
输出：["0->2","4->5","7"]
解释：区间范围是：
[0,2] --> "0->2"
[4,5] --> "4->5"
[7,7] --> "7"
```

示例 2：

```
输入：nums = [0,2,3,4,6,8,9]
输出：["0","2->4","6","8->9"]
解释：区间范围是：
[0,0] --> "0"
[2,4] --> "2->4"
[6,6] --> "6"
[8,9] --> "8->9"
```

提示：

- 0 <= nums.length <= 20
- -2^31^ <= nums[i] <= 2^31^ - 1
- nums 中的所有值都 互不相同
- nums 按升序排列

### 代码

- 遍历

```java
class Solution {
    public List<String> summaryRanges(int[] nums) {
        List<String> result = new ArrayList<>();
        StringBuilder ranges = new StringBuilder();
        int start = 0;
        int n = nums.length;
        if (n == 1) {
            ranges.append(nums[start]);
            result.add(ranges.toString());
            return result;
        }
        for(int i = 0; i < n - 1; i++) {
            if (nums[i+1] > nums[i] + 1) {
                ranges.append(nums[start]);
                if (i > start) {
                    ranges.append("->");
                    ranges.append(nums[i]);
                }
                result.add(ranges.toString());
                ranges.delete(0, ranges.length());
                start = i+1;
            } 
            if (i + 1 == n - 1) {
                ranges.append(nums[start]);
                if (i >= start) {
                    ranges.append("->");
                    ranges.append(nums[i+1]);
                }
                result.add(ranges.toString());
            }
        }
        return result;
    }
}
```

- 遍历

```java
class Solution {
    public List<String> summaryRanges(int[] nums) {
        List<String> result = new ArrayList<>();
        StringBuilder ranges = new StringBuilder();
        int start = 0;
        int n = nums.length;
        for(int i = 0; i < n; i++) {
            while(i+1 < n && nums[i+1] == nums[i] + 1) {
                i++;
            }
            ranges.append(nums[start]);
            if (i > start) {
                ranges.append("->" + nums[i]);
            }
            result.add(ranges.toString());
            start = i+1;
            ranges.delete(0, ranges.length());
        }
        return result;
    }
}
```

### 笔记

- 判断int型的差值为1时，采用`if(a-b>1)`的方式不行，因为
  
  ```
  int a = 2147483647;
  int b = -2147483647;
  System.out.println(a-b); // -2
  ```
  
  可以用`if(a>b+1)`。

- StringBuilder清空数据：
  
  ```java
  StringBuilder sb = new StringBuilder(); // 1. 重新new一个
  sb.delete(0, sb.length()); // 2. 使用delete
  sb.setLength(0); // 3. 使用setLength
  ```

## [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)

难度：简单:star::star::star:

### 题目

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 MyQueue 类：

```
void push(int x) 将元素 x 推到队列的末尾
int pop() 从队列的开头移除并返回元素
int peek() 返回队列开头的元素
boolean empty() 如果队列为空，返回 true ；否则，返回 false
```

说明：

你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。
你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

示例 1：

```
输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```

提示：

- 1 <= x <= 9
- 最多调用 100 次 push、pop、peek 和 empty
- 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）

进阶：

- 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。

### 代码

- 两个栈

```java
class MyQueue {
    private Deque<Integer> stack1;
    private Deque<Integer> stack2;

    public MyQueue() {
        stack1 = new LinkedList<>();
        stack2 = new LinkedList<>();
    }

    public void push(int x) {
        stack1.push(x);
    }

    public int pop() {
        while(!stack1.isEmpty()) {
            stack2.push(stack1.pop());
        }
        int res = stack2.pop();
        while(!stack2.isEmpty()) {
            stack1.push(stack2.pop());
        }
        return res;
    }

    public int peek() {
        while(!stack1.isEmpty()) {
            stack2.push(stack1.pop());
        }
        int res = stack2.peek();
        while(!stack2.isEmpty()) {
            stack1.push(stack2.pop());
        }
        return res;
    }

    public boolean empty() {
        return stack1.isEmpty();
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```

- 优化两个栈

```java
class MyQueue {
    private Deque<Integer> stack1;
    private Deque<Integer> stack2;

    public MyQueue() {
        stack1 = new LinkedList<>();
        stack2 = new LinkedList<>();
    }

    public void push(int x) {
        stack1.push(x);
    }

    public int pop() {
        if (stack2.isEmpty()) {
            while(!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }

    public int peek() {
        if (stack2.isEmpty()) {
            while(!stack1.isEmpty()) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.peek();
    }

    public boolean empty() {
        return stack1.isEmpty() && stack2.isEmpty();
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```

### 笔记

- 栈1作为对外插入的栈，要出栈（pop）的时候，把栈1的元素都压入栈2，这时栈2内元素的顺序和队列中的顺序就是一致的了，满足先进先出。只不过要再入栈的话，还是插入栈1，等栈2为空，不能进行pop的时候，就把栈1的元素又都压入栈2，再执行pop操作即可

## [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

难度：简单:star::star::star:

### 题目

给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。如果是，返回 true ；否则，返回 false 。

示例 1：

![img](noteImage/pal1linked-list.jpg)

```
输入：head = [1,2,2,1]
输出：true
```

示例 2：

![img](noteImage/pal2linked-list.jpg)

```
输入：head = [1,2]
输出：false
```

提示：

- 链表中节点数目在范围[1, 10^5^] 内
- 0 <= Node.val <= 9

进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？

### 代码

- 暴力法

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        ArrayList<Integer> nums = new ArrayList<>();
        while(head != null) {
            nums.add(head.val);
            head = head.next;
        }
        int n = nums.size();
        int i, j;
        if (n % 2 == 0) {
            j = n / 2;
            i = j - 1;
        } else {
            j = n / 2 + 1;
            i = j - 2;
        }
        while(j < n) {
            if (nums.get(i) != nums.get(j)) {
                return false;
            }
            i--;
            j++;
        }
        return true;

    }
}
```

- 翻转后半部分链表

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while(fast != null && fast.next != null ) {
            fast = fast.next.next;
            slow = slow.next;
        }
        // 翻转后半部分链表
        ListNode pre = null;
        while(slow != null) {
            ListNode tmp = slow.next;
            slow.next = pre;
            pre = slow;
            slow = tmp;
        }
        while(pre != null) {
            if (head.val != pre.val) {
                return false;
            }
            head = head.next;
            pre = pre.next;
        }
        return true;

    }
}
```

- 翻转前半部分链表

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        ListNode pre = null;
        while(fast != null && fast.next != null ) {
            fast = fast.next.next;
            // 同时翻转前半部分链表
            ListNode tmp = slow.next;
            slow.next = pre;
            pre = slow;
            slow = tmp;
        }
        // 链表长为奇数
        if (fast != null) {
            slow = slow.next;
        }
        while(pre != null) {
            if (slow.val != pre.val) {
                return false;
            }
            slow = slow.next;
            pre = pre.next;
        }
        return true;

    }
}
```

- 递归

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    private ListNode pre;
    public boolean isPalindrome(ListNode head) {
        pre = head;
        return helper(head);
    }
    public boolean helper(ListNode head) {
        if (head != null) {
            if (!helper(head.next)) {
                return false;
            }
            if (pre.val != head.val) {
                return false;
            }
            pre = pre.next;
        }
        return true;
    }
}
```

### 笔记

- 暴力法：将链表的值存到数组中，再判断这个数组是否是回文数组
- 快慢指针：快指针走两步，慢指针走一步，快指针为空或到末尾时，慢指针在链表的中间。
- 递归：由于链表的递归特性，自带从后往前的操作，可以利用这个特性，增加一个递归函数外的全局指针，从前往后走，递归本身从后往前走，比较两个指针的值，如果不相等，就返回false。

## [235. 二叉搜索树的最近公共祖先 ](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

难度：简单:star::star::star:

### 题目

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]

![img](noteImage/binarysearchtree_improved.png)

示例 1:

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

示例 2:

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
输出: 2
解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
```

说明:

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉搜索树中。

### 代码

- 递归

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 一个在左子树，一个在右子树
        if (p.val <= root.val && q.val >= root.val) {
            return root;
        }
        if (p.val >= root.val && q.val <= root.val) {
            return root;
        }
        // 都在左子树
        if (p.val < root.val && q.val < root.val) {
            return lowestCommonAncestor(root.left, p, q);
        }
        // 都在右子树
        if (p.val > root.val && q.val > root.val) {
            return lowestCommonAncestor(root.right, p, q);
        }
        return null;
    }
}
```

- 递归

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 都在左子树
        if (p.val < root.val && q.val < root.val) {
            return lowestCommonAncestor(root.left, p, q);
        }
        // 都在右子树
        if (p.val > root.val && q.val > root.val) {
            return lowestCommonAncestor(root.right, p, q);
        }
        // 一个在左子树，一个在右子树
        return root;
    }
}
```

- 两次遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        ArrayList<TreeNode> path_p = getPath(root, p);
        ArrayList<TreeNode> path_q = getPath(root, q);
        TreeNode ancestor = null;
        for(int i = 0; i < path_p.size() && i < path_q.size(); i++) {
            if (path_p.get(i) == path_q.get(i)) {
                ancestor = path_p.get(i);
            }
            else {
                break;
            }
        }
        return ancestor;
    }

    public ArrayList<TreeNode> getPath(TreeNode root, TreeNode target) {
        ArrayList<TreeNode> path = new ArrayList<>();
        TreeNode node = root;
        while(node != target) {
            path.add(node);
            if (target.val < node.val) {
                node = node.left;
            }
            else if (target.val > node.val) {
                node = node.right;
            }
        }
        path.add(target);
        return path;
    }
}
```

- 一次遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        TreeNode node = root;
        while(true) {
            // 都在左子树，就往左找
            if (p.val < node.val && q.val < node.val) {
                node = node.left;
            }
            // 都在右子树，就往右找
            else if (p.val > node.val && q.val > node.val) {
                node = node.right;
            }
            // 出现分叉，要找的就是当前结点
            else {
                break;
            }
        }
        return node;
    }

}
```

### 笔记

- 二叉搜索树（BST）：（递归定义）
  - 空树是二叉搜索树
  - 若非空，则：其左子树的所有节点的值均小于它的根节点的值；其右子树的所有节点的值均大于它的根节点的值；它的左右子树也分别为二叉搜索树。
- 在二叉搜索树中可以快速找到某个结点以及从根结点到该节点的路径，例如我们需要找到节点 p：
  - 我们从根节点开始遍历；
  - 如果当前节点就是 p，那么成功地找到了节点；
  - 如果当前节点的值大于 p的值，说明 p应该在当前节点的左子树，因此将当前节点移动到它的左子节点；
  - 如果当前节点的值小于 p 的值，说明 p应该在当前节点的右子树，因此将当前节点移动到它的右子节点。
    在寻找节点的过程中，我们可以顺便记录经过的节点，这样就得到了从根节点到被寻找节点的路径。
- 两次遍历：当我们分别得到了从根节点到 p和 q的路径之后，我们就可以很方便地找到它们的最近公共祖先了。显然，p 和 q的最近公共祖先就是从根节点到它们路径上的「分岔点」，也就是最后一个相同的节点。
- 一次遍历：
  - 我们从根节点开始遍历；
  - 如果当前节点的值大于 p 和 q的值，说明 p 和 q应该在当前节点的左子树，因此将当前节点移动到它的左子节点；
  - 如果当前节点的值小于 p 和 q 的值，说明 p 和 q 应该在当前节点的右子树，因此将当前节点移动到它的右子节点；
  - 如果当前节点的值不满足上述两条要求，那么说明当前节点就是「分岔点」。此时，p和 q 要么在当前节点的不同的子树中，要么其中一个就是当前节点。

## [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

难度：简单:star::star::star:

### 题目

请编写一个函数，用于 删除单链表中某个特定节点 。在设计函数时需要注意，你无法访问链表的头节点 head ，只能直接访问 要被删除的节点 。

题目数据保证需要删除的节点 不是末尾节点 。

示例 1：

```
输入：head = [4,5,1,9], node = 5
输出：[4,1,9]
解释：指定链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9
```

示例 2：

```
输入：head = [4,5,1,9], node = 1
输出：[4,5,9]
解释：指定链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -> 5 -> 9
```

示例 3：

```
输入：head = [1,2,3,4], node = 3
输出：[1,2,4]
```

示例 4：

```
输入：head = [0,1], node = 0
输出：[1]
```

示例 5：

```
输入：head = [-3,5,-99], node = -3
输出：[5,-99]
```

提示：

- 链表中节点的数目范围是 [2, 1000]
- -1000 <= Node.val <= 1000
- 链表中每个节点的值都是唯一的
- 需要删除的节点 node 是 链表中的一个有效节点 ，且 不是末尾节点

### 代码

- 交换值

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        int tmp = node.val;
        node.val = node.next.val;
        node.next.val = tmp;
        node.next = node.next.next;
    }
}
```

- 不保存当前值

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
```

### 笔记

- 交换当前结点后后面结点的值，然后删除后面的结点

## [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)

难度：简单:star::star::star:

### 题目

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

注意：若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

示例 1:

```
输入: s = "anagram", t = "nagaram"
输出: true
```

示例 2:

```
输入: s = "rat", t = "car"
输出: false
```

提示:

- 1 <= s.length, t.length <= 5 * 10^4^
- s 和 t 仅包含小写字母

进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？

### 代码

- HashMap

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int sLen = s.length();
        int tLen = t.length();
        if (sLen != tLen) {
            return false;
        }
        HashMap<Character, Integer> map_s = new HashMap<>();
        HashMap<Character, Integer> map_t = new HashMap<>();
        for (int i = 0; i < sLen; i++) {
            map_s.put(s.charAt(i), map_s.getOrDefault(s.charAt(i), 0) + 1);
            map_t.put(t.charAt(i), map_t.getOrDefault(t.charAt(i), 0) + 1);
        }
        if (map_s.equals(map_t)) {
            return true;
        } else {
            return false;
        }
    }
}
```

- 排序

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int sLen = s.length();
        int tLen = t.length();
        if (sLen != tLen) {
            return false;
        }
        char[] sArray = s.toCharArray();
        char[] tArray = t.toCharArray();
        Arrays.sort(sArray);
        Arrays.sort(tArray);
        return Arrays.equals(sArray, tArray);
    }
}
```

- 哈希表

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int sLen = s.length();
        int tLen = t.length();
        if (sLen != tLen) {
            return false;
        }
        int[] count = new int[26];
        for(int i = 0; i < sLen; i++) {
            count[s.charAt(i) - 'a'] ++;
            count[t.charAt(i) - 'a'] --;
        }
        for(int i = 0; i < 26; i++) {
            if (count[i] != 0) {
                return false;
            }
        }
        return true;

    }
}
```

- HashMap-进阶

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int sLen = s.length();
        int tLen = t.length();
        if (sLen != tLen) {
            return false;
        }
        HashMap<Character, Integer> map = new HashMap<>();
        for (int i = 0; i < sLen; i++) {
            map.put(s.charAt(i), map.getOrDefault(s.charAt(i), 0) + 1);
            map.put(t.charAt(i), map.getOrDefault(t.charAt(i), 0) - 1);
        }
        for(int value : map.values()) {
            if (value != 0) {
                return false;
            }
        }
        return true;
    }
}
```

### 笔记

- String转char数组：
  
  ```java
  String s;
  char[] c = s.toCharArray();
  ```

- char数组排序：
  
  ```java
  char[] c;
  Arrays.sort(c); // 调用完之后数组c就会改变
  ```
  
  比较char数组是否相等：
  
  ```java
  Arrays.equals(sArray, tArray);
  ```

- 哈希表：由于字符串只包含 26个小写字母，因此我们可以维护一个长度为 26的频次数组 table，先遍历记录字符串 s中字符出现的频次，然后遍历字符串 t，减去 table 中对应的频次，如果出现 table[i]<0，则说明 t 包含一个不在 s中的额外字符，返回 false 即可。

## [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

难度：简单:star::star::star:

### 题目

给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。

叶子节点 是指没有子节点的节点。

示例 1：

![img](noteImage/paths-tree.jpg)

```
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

示例 2：

```
输入：root = [1]
输出：["1"]
```

提示：

- 树中节点的数目在范围 [1, 100] 内
- -100 <= Node.val <= 100

### 代码

- 深度优先搜索

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> result = new ArrayList<>();
        dfs(root, result, "");
        return result;
    }
    public void dfs(TreeNode root, List<String> result, String path) {
        if (root != null) {
            StringBuilder sb = new StringBuilder(path);
            sb.append(root.val);
            if (root.left == null && root.right == null) {
                result.add(sb.toString());
            }
            else {
                sb.append("->");
                dfs(root.left, result, sb.toString());
                dfs(root.right, result, sb.toString());
            } 
        }

    }
}
```

- 迭代

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> result = new ArrayList<>();
        Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        // 使用栈来存放路径，便于回溯
        Deque<String> path = new LinkedList<>();
        // 路径和结点同时入栈
        path.push(root.val + "");
        while (!stack.isEmpty()) {
            // 路径和结点同时出栈
            TreeNode p = stack.pop();
            String curPath = path.pop();
            if (p.left == null && p.right == null) {
                result.add(curPath);
            } else {
                if (p.right != null) {
                    stack.push(p.right);
                    path.push(curPath + "->" + p.right.val);
                }
                if (p.left != null) {
                    stack.push(p.left);
                    path.push(curPath + "->" + p.left.val);
                }
            }
        }
        return result;
    }
}
```

- 层次遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<String> binaryTreePaths(TreeNode root) {
        List<String> result = new ArrayList<>();
        Queue<TreeNode> node_queue = new LinkedList<>();
        Queue<String> path_queue = new LinkedList<>();
        node_queue.offer(root);
        path_queue.offer(root.val + "");
        while(!node_queue.isEmpty()) {
            TreeNode p = node_queue.poll();
            String path = path_queue.poll();
            if (p.left == null && p.right == null) {
                result.add(path);
            } else {
                if (p.left != null) {
                    node_queue.offer(p.left);
                    path_queue.offer(path + "->" + p.left.val);
                }
                if (p.right != null) {
                    node_queue.offer(p.right);
                    path_queue.offer(path + "->" + p.right.val);
                }
            }
        }
        return result;
    }
}
```

### 笔记

- 深度优先搜索：
  
  - 如果当前节点不是叶子节点，则在当前的路径末尾添加该节点，并继续递归遍历该节点的每一个孩子节点。
  - 如果当前节点是叶子节点，则在当前路径末尾添加该节点后我们就得到了一条从根节点到叶子节点的路径，将该路径加入到答案即可。
  
  注意：StringBuilder的定义要放到dfs函数里面，作为局部的变量，保存从根结点到当前结点的路径，这样递归的时候，会有隐藏的回溯。

- 迭代和层次遍历：结点和路径要一起操作，这样才能起到回溯的作用。

## [258. 各位相加](https://leetcode-cn.com/problems/add-digits/)

难度：简单:star::star::star:

### 题目

给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。

示例 1:

```
输入: num = 38
输出: 2 
解释: 各位相加的过程为：
38 --> 3 + 8 --> 11
11 --> 1 + 1 --> 2
由于 2 是一位数，所以返回 2。
```

示例 1:

```
输入: num = 0
输出: 0
```

提示：

- 0 <= num <= 2^31^ - 1

进阶：你可以不使用循环或者递归，在 O(1) 时间复杂度内解决这个问题吗？

### 代码

- 循环

```java
class Solution {
    public int addDigits(int num) {
        int s = sum(num);
        while(s >= 10) {
            s = sum(s);
        }
        return s;
    }
    public int sum(int num) {
        int res = 0;
        while(num > 0) {
            int a = num % 10;
            num = num /10;
            res += a;
        }
        return res;
    }
}
```

- 数学法

```java
class Solution {
    public int addDigits(int num) {
        return (num - 1) % 9 + 1;
    }
}
```

- 数学法

```java
class Solution {
    public int addDigits(int num) {
        if (num <= 9) {
            return num;
        }
        if (num % 9 == 0) {
            return 9;
        }
        return num % 9;
    }
}
```

### 笔记

- 数学法：
  abcde= a×(10^4^ - 1) + b×(10^3^ - 1) + c ×(10^2^ - 1) + d×(10 - 1) + e + a + b + c + d
  (10^i^ - 1) % 9 = 0
  abcde % 9 = (e + a + b + c + d) % 9
  特殊情况：abcde （>0）是9的倍数，则应当返回9，比如18,27,36等。abcde=0，则应该返回0。其它情况返回abcde % 9，也即等于各个位上的数字相加%9。
  避免情况的讨论，可以直接写成(num - 1 ) % 9 + 1；
- 在java、c、c++中，a%b的结果的正负和左操作数a相同，`-1%9=-1`
  在Python中，a%b的结果的正负和右操作数b相同，`-1%9=8`

## [263. 丑数](https://leetcode-cn.com/problems/ugly-number/)

难度：简单:star::star::star:

### 题目

给你一个整数 n ，请你判断 n 是否为 丑数 。如果是，返回 true ；否则，返回 false 。

丑数 就是只包含质因数 2、3 和/或 5 的正整数。

示例 1：

```
输入：n = 6
输出：true
解释：6 = 2 × 3
```

示例 2：

```
输入：n = 8
输出：true
解释：8 = 2 × 2 × 2
```

示例 3：

```
输入：n = 14
输出：false
解释：14 不是丑数，因为它包含了另外一个质因数 7 。
```

示例 4：

```
输入：n = 1
输出：true
解释：1 通常被视为丑数。
```

提示：

- -2^31^ <= n <= 2^31^ - 1

### 代码

- 循环

```java
class Solution {
    public boolean isUgly(int n) {
        if (n <= 0) {
            return false;
        }
        while(n > 0) {
            if (n == 1) {
                return true;
            }
            else if (n % 2 == 0) {
                n = n / 2;
            }
            else if (n % 3 == 0) {
                n = n / 3;
            } 
            else if (n % 5 == 0) {
                n = n / 5;
            }
            else {
                return false;
            }
        }
        return true;
    }
}
```

### 笔记

- 负数和0都是丑数

## [268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)

难度：简单:star::star::star:

### 题目

给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。

示例 1：

```
输入：nums = [3,0,1]
输出：2
解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```

示例 2：

```
输入：nums = [0,1]
输出：2
解释：n = 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。
```

示例 3：

```
输入：nums = [9,6,4,2,3,5,7,0,1]
输出：8
解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。
```

示例 4：

```
输入：nums = [0]
输出：1
解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。
```

提示：

- n == nums.length
- 1 <= n <= 10^4^
- 0 <= nums[i] <= n
- nums 中的所有数字都 独一无二

进阶：你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?

### 代码

- 排序

```java
class Solution {
    public int missingNumber(int[] nums) {
        Arrays.sort(nums);
        if (nums[0] != 0) {
            return 0;
        }
        for(int i = 0; i < nums.length - 1; i++) {
            if (nums[i + 1] - nums[i] > 1) {
                return i + 1;
            }
        }
        return nums.length;
    }
}
```

- 利用下标

```java
class Solution {
    public int missingNumber(int[] nums) {
        Arrays.sort(nums);
        for(int i = 0; i < nums.length; i++) {
            if (nums[i] != i) {
                return i;
            }
        }
        return nums.length;

    }
}
```

- HashSet

```java
class Solution {
    public int missingNumber(int[] nums) {
        HashSet<Integer> set = new HashSet<>();
        for(int i = 0; i < nums.length; i++) {
            set.add(nums[i]);
        }
        for(int i = 0; i < nums.length + 1; i++) {
            if (!set.contains(i)) {
                return i;
            }
        }
        return nums.length;
    }
}
```

- 求和作差

```java
class Solution {
    public int missingNumber(int[] nums) {
        int n = nums.length;
        int help = n * (n + 1) / 2;
        for (int num : nums) {
            help -= num;
        }
        return help;

    }
}
```

- 异或两次

```java
class Solution {
    public int missingNumber(int[] nums) {
        int res = 0;
        for (int num : nums) {
            res ^= num;
        }
        for (int i = 0; i < nums.length + 1; i++) {
            res ^= i;
        }
        return res;
    }
}
```

### 笔记

- 利用下标：排序后，当前元素和下标不一样，就返回下标。

- Java数组转HashSet:
  
  ```java
  Integer[] nums = new Integer[size];
  HashSet<Intger> set = new HashSet<>(Arrays.asList(nums));
  ```
  
  **注意：只有当nums是包装类型的数组时才可以使用`Arrays.asList()`进行转换，如果nums是原始类型（比如int[]）的数组，就不能使用`Arrays.asList()`进行转换。**

- 找缺失数、找出现一次数都是异或的经典应用。
  任何数异或0都是自己。

## [290. 单词规律](https://leetcode-cn.com/problems/word-pattern/)

难度：简单:star::star::star:

### 题目

给定一种规律 pattern 和一个字符串 s ，判断 s 是否遵循相同的规律。

这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。

示例1:

```
输入: pattern = "abba", str = "dog cat cat dog"
输出: true
```

示例 2:

```
输入:pattern = "abba", str = "dog cat cat fish"
输出: false
```

示例 3:

```
输入: pattern = "aaaa", str = "dog cat cat dog"
输出: false
```

提示:

- 1 <= pattern.length <= 300
- pattern 只包含小写英文字母
- 1 <= s.length <= 3000
- s 只包含小写英文字母和 ' '
- s 不包含 任何前导或尾随对空格
- s 中每个单词都被 单个空格 分隔

### 代码

- HashMap

```java
class Solution {
    public boolean wordPattern(String pattern, String s) {
        String[] split = s.split(" ");
        if (pattern.length() != split.length) {
            return false;
        }
        HashMap<Character, String> map = new HashMap<>();
        for(int i = 0; i < pattern.length(); i++) {
            if (map.containsKey(pattern.charAt(i))) {
                if (!map.get(pattern.charAt(i)).equals(split[i])) {
                    return false;
                }
            } else {
                if (map.containsValue(split[i])) {
                    return false;
                }
                map.put(pattern.charAt(i), split[i]);
            }
        }
        return true;
    }
}
```

- 比较下标

```java
class Solution {
    public boolean wordPattern(String pattern, String s) {
        String[] split = s.split(" ");
        if (pattern.length() != split.length) {
            return false;
        }
        for(int i = 0; i < pattern.length(); i++) {
            if(pattern.indexOf(pattern.substring(i, i+1)) != firstIndex(split, split[i])) {
                return false;
            }
        }
        return true;
    }
    public int firstIndex(String[] src, String target) {
        for(int i = 0; i < src.length; i++) {
            if (src[i].equals(target)) {
                return i;
            }
        }
        return -1;
    }
}
```

- 两个HashMap

```java
class Solution {
    public boolean wordPattern(String pattern, String s) {
        String[] split = s.split(" ");
        if (pattern.length() != split.length) {
            return false;
        }
        HashMap<Character, String> map1 = new HashMap<>();
        HashMap<String, Character> map2 = new HashMap<>();
        for(int i = 0; i < pattern.length(); i++) {
            char p = pattern.charAt(i);
            if (map1.containsKey(p) && !map1.get(p).equals(split[i])) {
                return false;
            }
            if (map2.containsKey(split[i]) && map2.get(split[i]) != p) {
                return false;
            }
            map1.put(p, split[i]);
            map2.put(split[i], p);
        }
        return true;
    }
}
```

### 笔记

- 比较下标是一个巧妙的方法，相当于把下标和元素作为映射，然后看相同元素的下标是否一样。
- 两个HashMap：map.containsValue()是比较耗时的，所以用两个HashMap

## [292. Nim 游戏](https://leetcode-cn.com/problems/nim-game/submissions/)

难度：简单:star::star::star:

### 题目

你和你的朋友，两个人一起玩 Nim 游戏：

桌子上有一堆石头。
你们轮流进行自己的回合， 你作为先手 。
每一回合，轮到的人拿掉 1 - 3 块石头。
拿掉最后一块石头的人就是获胜者。
假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。

示例 1：

```
输入：n = 4
输出：false 
解释：以下是可能的结果:

1. 移除1颗石头。你的朋友移走了3块石头，包括最后一块。你的朋友赢了。
2. 移除2个石子。你的朋友移走2块石头，包括最后一块。你的朋友赢了。
3. 你移走3颗石子。你的朋友移走了最后一块石头。你的朋友赢了。
   在所有结果中，你的朋友是赢家。
```

示例 2：

```
输入：n = 1
输出：true
```

示例 3：

```
输入：n = 2
输出：true
```

提示：

- 1 <= n <= 2^31^ - 1

### 代码

- 技巧

```java
class Solution {
    public boolean canWinNim(int n) {
        return n % 4 != 0;
    }
}
```

### 笔记

- 技巧
  
  | 总数  | 先拿  | 结果  |
  | --- | --- | --- |
  | 1   | 1   | 先胜  |
  | 2   | 2   | 先胜  |
  | 3   | 3   | 先胜  |
  | 4   | -   | 后胜  |
  | 5   | 1   | 先胜  |
  | 6   | 2   | 先胜  |
  | 7   | 3   | 先胜  |
  | 8   | -   | 后胜  |
  | 9   | 1   | 先胜  |

- 巴什博弈： 只有一堆n个物品，两个人轮流从这堆物品中取物， 规定每次至少取一个，最多取m个。最后取光者得胜。 只要 n 不能整除 m+1 ,那么必然是先手取胜，否则后手取胜 

## [303. 区域和检索](https://leetcode-cn.com/problems/range-sum-query-immutable/)

难度：简单:star::star::star:

### 题目

给定一个整数数组  nums，处理以下类型的多个查询:

计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的 和 ，其中 left <= right
实现 NumArray 类：

NumArray(int[] nums) 使用数组 nums 初始化对象
int sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的 总和 ，包含 left 和 right 两点（也就是 nums[left] + nums[left + 1] + ... + nums[right] )

示例 1：

```
输入：
["NumArray", "sumRange", "sumRange", "sumRange"]
[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
输出：
[null, 1, -1, -3]

解释：
NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);
numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)
numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) 
numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))
```

提示：

- 1 <= nums.length <= 10^4^
- -10^5^ <= nums[i] <= 10^5^
- 0 <= i <= j < nums.length
- 最多调用 10^4^ 次 sumRange 方法

### 代码

- 暴力法-this

```java
class NumArray {
    private int[] nums;
    public NumArray(int[] nums) {
        this.nums = nums;
    }

    public int sumRange(int left, int right) {
        int sum = 0;
        for(int i = left; i <= right; i++) {
            sum += this.nums[i];
        }
        return sum;
    }
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * int param_1 = obj.sumRange(left,right);
 */
```

- 暴力法-private

```java
class NumArray {
    private int[] numArray;
    public NumArray(int[] nums) {
        numArray = nums;
    }

    public int sumRange(int left, int right) {
        int sum = 0;
        for(int i = left; i <= right; i++) {
            sum += numArray[i];
        }
        return sum;
    }
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * int param_1 = obj.sumRange(left,right);
 */
```

- 空间换时间

```java
class NumArray {
    private int[] numArray;
    private int[] sumArray;
    public NumArray(int[] nums) {
        numArray = nums;
        sumArray = new int[nums.length];
        sumArray[0] = nums[0];
        for(int i = 1; i < nums.length; i++) {
            sumArray[i] = sumArray[i-1] + nums[i];
        }
    }

    public int sumRange(int left, int right) {
        return left == 0 ? sumArray[right] : sumArray[right] - sumArray[left-1];
    }
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * int param_1 = obj.sumRange(left,right);
 */
```

- 一个数组就够

```java
class NumArray {
    private int[] numArray;
    public NumArray(int[] nums) {
        numArray = nums;
        for(int i = 1; i < nums.length; i++) {
            numArray[i] = numArray[i-1] + nums[i];
        }
    }

    public int sumRange(int left, int right) {
        return left == 0 ? numArray[right] : numArray[right] - numArray[left-1];
    }
}

/**
 * Your NumArray object will be instantiated and called as such:
 * NumArray obj = new NumArray(nums);
 * int param_1 = obj.sumRange(left,right);
 */
```

### 笔记

- 空间换时间：由于初始化只执行一次，所以可以再初始化的时候就把从0到当前位置的和都求出来，这样在执行sumRange的时候可以直接查询。

## [326. 3 的幂](https://leetcode-cn.com/problems/power-of-three/)

难度：简单:star::star::star:

### 题目

给定一个整数，写一个函数来判断它是否是 3 的幂次方。如果是，返回 true ；否则，返回 false 。

整数 n 是 3 的幂次方需满足：存在整数 x 使得 n == 3^x^

示例 1：

```
输入：n = 27
输出：true
```

示例 2：

```
输入：n = 0
输出：false
```

示例 3：

```
输入：n = 9
输出：true
```

示例 4：

```
输入：n = 45
输出：false
```

提示：

- -2^31^ <= n <= 2^31^ - 1

进阶：你能不使用循环或者递归来完成本题吗？

### 代码

- 使用Math库（换底公式）

```java
class Solution {
    public boolean isPowerOfThree(int n) {
        if (n <= 0) {
            return false;
        }
        long x = Math.round(Math.log(n) / Math.log(3));
        return n == (int)Math.round(Math.pow(3, x));
    }
}
```

- 循环

```java
class Solution {
    public boolean isPowerOfThree(int n) {
        if (n <= 0) {
            return false;
        }
        while(n % 3 == 0) {
            n = n / 3;
        }
        return n == 1;
    }
}
```

- 取巧

```java
class Solution {
    public boolean isPowerOfThree(int n) {
        if (n <= 0) {
            return false;
        }
        return 1162261467 % n == 0;
    }
}
```

### 笔记

- 取巧：在题目给定的 32位有符号整数的范围内，最大的 3的幂为 $3^{19}$ = 1162261467。我们只需要判断 n是否是 $3^{19}$的约数即可。

## [338. 比特位计数](https://leetcode-cn.com/problems/counting-bits/)

难度：简单:star::star::star:

### 题目

给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。

示例 1：

```
输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10
```

示例 2：

```
输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```

提示：

- 0 <= n <= 105

进阶：

- 很容易就能实现时间复杂度为 O(n log n) 的解决方案，你可以在线性时间复杂度 O(n) 内用一趟扫描解决此问题吗？
- 你能不使用任何内置函数解决此问题吗？（如，C++ 中的 __builtin_popcount ）

### 代码

- 位运算

```java
class Solution {
    public int[] countBits(int n) {
        int[] ans = new int[n + 1];
        for(int i = 0; i <= n; i++) {
            ans[i] = countOne(i);
        }
        return ans;
    }
    public int countOne(int num) {
        int count = 0;
        while (num > 0) {
            num = num & (num - 1);
            count++;
        }
        return count;
    }
}
```

- bitCount

```java
class Solution {
    public int[] countBits(int n) {
        int[] ans = new int[n + 1];
        for(int i = 0; i <= n; i++) {
            ans[i] = Integer.bitCount(i);
        }
        return ans;
    }
}
```

- 判断奇偶

```java
class Solution {
    public int[] countBits(int n) {
        int[] ans = new int[n + 1];
        ans[0] = 0;
        for(int i = 0; i <= n; i++) {
            if (i % 2 == 0) {
                ans[i] = ans[i/2];
            } else {
                ans[i] = ans[i-1] + 1;
            }
        }
        return ans;
    }
}
```

- 最低有效位

```java
class Solution {
    public int[] countBits(int n) {
        int[] ans = new int[n + 1];
        ans[0] = 0;
        for(int i = 1; i <= n; i++) {
            ans[i] = ans[i >> 1] + (i & 1);
        }
        return ans;
    }
}
```

- 最低设置位

```java
class Solution {
    public int[] countBits(int n) {
        int[] ans = new int[n + 1];
        ans[0] = 0;
        for(int i = 1; i <= n; i++) {
            ans[i] = ans[i & (i - 1)] + 1;
        }
        return ans;
    }
}
```

### 笔记

- 位运算：`n & (n - 1)`这个位运算的特点，每运算一次，会将n（二进制表示）中的最低位的1变为0。运算几次变为0，n的二进制表示就有几个1。
- 判断奇偶：
  https://leetcode-cn.com/problems/counting-bits/solution/hen-qing-xi-de-si-lu-by-duadua/
- Java的库函数`Integer.bitCount(i)`可以统计一个int型数字的二进制表示的1的个数。
- x/2 = x >> 1
  x%2 = x & 1

## [342. 4的幂](https://leetcode-cn.com/problems/power-of-four/)

难度：简单:star::star::star

### 题目

给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。

整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4^x^

示例 1：

```
输入：n = 16
输出：true
```

示例 2：

```
输入：n = 5
输出：false
```

示例 3：

```
输入：n = 1
输出：true
```

提示：

- -2^31^ <= n <= 2^31^ - 1

进阶：你能不使用循环或者递归来完成本题吗？

### 代码

- 循环

```java
class Solution {
    public boolean isPowerOfFour(int n) {
        if (n <= 0) {
            return false;
        }
        while(n % 4 == 0) {
            n = n / 4;
        }
        return n == 1;
    }
}
```

- Math库

```java
class Solution {
    public boolean isPowerOfFour(int n) {
        if (n <= 0) {
            return false;
        }
        long x = Math.round(Math.log(n) / Math.log(4));
        return n == (int)Math.round(Math.pow(4, x));
    }
}
```

- 位运算

```java
class Solution {
    public boolean isPowerOfFour(int n) {
        return n > 0 && (n & (n - 1)) == 0 && (n & 0x2aaaaaaa) == 0; 
    }
}
```

- 模3余1

```java
class Solution {
    public boolean isPowerOfFour(int n) {
        return n > 0 && (n & (n - 1)) == 0 && (n % 3) == 1; 
    }
}
```

### 笔记

- 位运算：`n & (n - 1) == 0`则n为2的幂， 首先**判断是2的幂**，然后判断其只有偶数位上是1，如果有奇数为上是1，那就不是4的幂。
  0x2aaaaaaa= 0010 1010 1010 1010 1010 1010 1010 1010
  
                        31 30 29 ...                                        ...3 2 1 0
  
  由于n<=2^31 - 1，x<=31, 则若n = 4^x, 则x<=29, n < 2^29 - 1。
  若n = 29,则x=29/2 = 14.5 把不是整数，所以，n <= 2^28。
  如果n是4的幂次方，则只有n的第28,或26或,24..或.2位上为1，其余都为0时，才是4的幂次方，也即与0x2aaaaaaa相与的结果为0时，才是4的幂次方。
- & 与运算符的优先级 比 == 等等于号的优先级要低
- 如果 n 是 4的幂，那么它可以表示成 4^x的形式，我们可以发现它除以 3的余数一定为 1

## [345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)

难度：简单:star::star::star:

### 题目

给你一个字符串 s ，仅反转字符串中的所有元音字母，并返回结果字符串。

元音字母包括 'a'、'e'、'i'、'o'、'u'，且可能以大小写两种形式出现。

示例 1：

```
输入：s = "hello"
输出："holle"
```

示例 2：

```
输入：s = "leetcode"
输出："leotcede"
```

提示：

- 1 <= s.length <= 3 * 10^5^
- s 由 可打印的 ASCII 字符组成

### 代码

- 双指针

```java
class Solution {
    public String reverseVowels(String s) {
        HashSet<Character> set = new HashSet<>(){{
            add('a');
            add('e');
            add('i');
            add('o');
            add('u');
            add('A');
            add('E');
            add('I');
            add('O');
            add('U');
        }};
        char[] res = s.toCharArray();
        for(int i = 0, j = s.length() - 1; i < j;) {
            char left = s.charAt(i);
            char right = s.charAt(j);
            if (set.contains(left) && set.contains(right)) {
                char tmp = left;
                res[i] = right;
                res[j] = tmp;
                i++;
                j--;
            }
            else if(!set.contains(left)) {
                i++;
            }
            else if(!set.contains(right)) {
                j--;
            }
        }
        return String.valueOf(res);
    }
}
```

### 笔记

- String转char数组：
  
  ```java
  String s = "abcd";
  char[] c = s.toCharArray();
  ```
  
  char数组转String：
  
  ```java
  char[] c = {'a', 'b', 'c', 'd'};
  String s = String.valueOf(c);
  ```

## [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

难度：简单:star::star::star:

### 题目

给定两个数组 nums1 和 nums2 ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 不考虑输出结果的顺序 。

示例 1：

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
```

示例 2：

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的
```

提示：

- 1 <= nums1.length, nums2.length <= 1000
- 0 <= nums1[i], nums2[i] <= 1000

### 代码

- 转集合求交集

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        HashSet<Integer> set1 = new HashSet<>();
        HashSet<Integer> set2 = new HashSet<>();
        for(int num : nums1) {
            set1.add(num);
        }
        for(int num : nums2) {
            set2.add(num);
        }
        set1.retainAll(set2);
        int[] res = new int[set1.size()];
        Integer[] tmp = set1.toArray(Integer[]::new);
        for(int i = 0; i < set1.size(); i++) {
            res[i] = tmp[i].intValue();
        }
        return res;
    }
}
```

- 排序

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        if (nums1.length > nums2.length) {
            return intersection(nums2, nums1);
        }
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        ArrayList<Integer> res = new ArrayList<>();
        for(int i = 0; i < nums1.length; ) {
            int tmp = nums1[i];
            if (Arrays.binarySearch(nums2, tmp) >= 0) {
                res.add(nums1[i]);
            }
            while(i < nums1.length && tmp == nums1[i]) {
                i++;
            }
        }
        return res.stream().mapToInt(k->k).toArray();
    }
}
```

- 排序+双指针

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int n1 = nums1.length;
        int n2 = nums2.length;
        int[] res = new int[n1 + n2];
        int i = 0;
        int j = 0;
        int last = 0;
        while(i < n1 && j < n2) {
            if (nums1[i] == nums2[j]) {
                if(last == 0 || nums1[i] != res[last-1]) {
                    res[last] = nums1[i];
                    last++;
                }
                i++;
                j++;
            }
            else if (nums1[i] < nums2[j]) {
                i++;
            }
            else {
                j++;
            }
        }
        return Arrays.copyOfRange(res, 0, last);
    }
}
```

### 笔记

- Java求集合的交集：
  
  ```java
  HashSet<Integer> set1 = new HashSet<>();
  HashSet<Integer> set2 = new HashSet<>();
  set1.retainAll(set2);
  ```
  
  Java求集合的并集：
  
  ```java
  HashSet<Integer> set1 = new HashSet<>();
  HashSet<Integer> set2 = new HashSet<>();
  set1.addAll(set2);
  ```

- Java中HashSet转数组：
  
  ```java
  HashSet<Integer> set1 = new HashSet<>();
  Integer[] tmp = set1.toArray(Integer[]::new);
  ```
  
  Java中Integer转int:
  
  ```java
  Integer a = new Integer();
  int b = a.intValue();
  ```
  
  Java中int转Integer：
  
  ```java
  int b = 1;
  Integer a = new Integer(b);
  Integer c = Integer.valueOf(b);
  ```

- Java中ArrayList<Integer>转int[] ：
  
  ```java
      ArrayList<Integer> res = new ArrayList<>();
      int ans = res.stream().mapToInt(k->k).toArray();
  ```

- Arrays的方法：
  
  ```java
  int[] res = new int[n];
  int[] resCopy = Arrays.copyOfRange(res, 0, n-2); //将指定数组的指定范围复制到新数组中。不包括n-2
  ```

## [350. 两个数组的交集 II](https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/)

难度：简单:star::star::star:

### 题目

给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。

示例 1：

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2,2]
```

示例 2:

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[4,9]
```

提示：

- 1 <= nums1.length, nums2.length <= 1000
- 0 <= nums1[i], nums2[i] <= 1000

进阶：

- 如果给定的数组已经排好序呢？你将如何优化你的算法？
- 如果 nums1 的大小比 nums2 小，哪种方法更优？
- 如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

### 代码

- 两个HashMap

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        HashMap<Integer, Integer> map1 = new HashMap<>();
        HashMap<Integer, Integer> map2 = new HashMap<>();
        for(int num: nums1) {
            map1.put(num, map1.getOrDefault(num, 0) + 1);
        }
        for(int num: nums2) {
            map2.put(num, map2.getOrDefault(num, 0) + 1);
        }
        int[] res = new int[nums1.length + nums2.length];
        int i = 0;
        for(int num : map1.keySet()) {
            if(map2.containsKey(num)) {
                int tmp = Math.min(map1.get(num), map2.get(num));
                while(tmp > 0) {
                    res[i] = num;
                    i++;
                    tmp--;
                }
            }
        }
        return Arrays.copyOfRange(res, 0, i);
    }
}
```

- 排序+双指针

```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        if (nums1.length > nums2.length) {
            return intersect(nums2, nums1);
        } 
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int[] res = new int[nums1.length];
        int k = 0;
        for(int i = 0, j = 0; i < nums1.length && j < nums2.length; ) {
            if(nums1[i] < nums2[j]) {
                i++;
            } 
            else if (nums1[i] == nums2[j]) {
                res[k] = nums1[i];
                k++;
                i++;
                j++;
            }
            else {
                j++;
            }
        }
        return Arrays.copyOfRange(res, 0, k);
    }
}
```

### 笔记

## [374. 猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)

难度：简单:star::star::star:

### 题目

猜数字游戏的规则如下：

- 每轮游戏，我都会从 1 到 n 随机选择一个数字。 请你猜选出的是哪个数字。
- 如果你猜错了，我会告诉你，你猜测的数字比我选出的数字是大了还是小了。

你可以通过调用一个预先定义好的接口 int guess(int num) 来获取猜测结果，返回值一共有 3 种可能的情况（-1，1 或 0）：

- -1：我选出的数字比你猜的数字小 pick < num
- 1：我选出的数字比你猜的数字大 pick > num
- 0：我选出的数字和你猜的数字一样。恭喜！你猜对了！pick == num

返回我选出的数字。

示例 1：

```
输入：n = 10, pick = 6
输出：6
```

示例 2：

```
输入：n = 1, pick = 1
输出：1
```

示例 3：

```
输入：n = 2, pick = 1
输出：1
```

示例 4：

```
输入：n = 2, pick = 2
输出：2
```

提示：

- 1 <= n <= 2^31^ - 1
- 1 <= pick <= n

### 代码

- 折半查找

```java
/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return          -1 if num is lower than the guess number
 *                  1 if num is higher than the guess number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int left = 1;
        int right = n;
        int pick = left + (right - left) / 2;
        int res = guess(pick);
        // System.out.println(pick + ", " + res);
        while(res != 0) {
            switch(res) {
                case 1:
                    left = pick + 1;
                    break;
                case -1:
                    right = pick - 1;
                    break;
                case 0:
                    return pick;
            }
            pick = left + (right - left) / 2;
            res = guess(pick);
            // System.out.println(pick + ", " + res);
        }
        return pick;
    }
}
```

- 二分查找

```java
/** 
 * Forward declaration of guess API.
 * @param  num   your guess
 * @return          -1 if num is lower than the guess number
 *                  1 if num is higher than the guess number
 *               otherwise return 0
 * int guess(int num);
 */

public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int left = 1;
        int right = n;
        while(left < right) {
            int pick = left + (right - left) / 2;
            if (guess(pick) > 0) {
                left = pick + 1;
            } else {
                right = pick;
            }
        }
        return left;
    }
}
```

### 笔记

- 1表示我猜小了，-1表示我猜大了，0表示猜中了

## [383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)

难度：简单:star::star::star:

### 题目

给你两个字符串：ransomNote 和 magazine ，判断 ransomNote 能不能由 magazine 里面的字符构成。

如果可以，返回 true ；否则返回 false 。

magazine 中的每个字符只能在 ransomNote 中使用一次。

示例 1：

```
输入：ransomNote = "a", magazine = "b"
输出：false
```

示例 2：

```
输入：ransomNote = "aa", magazine = "ab"
输出：false
```

示例 3：

```
输入：ransomNote = "aa", magazine = "aab"
输出：true
```

提示：

- 1 <= ransomNote.length, magazine.length <= 10^5^
- ransomNote 和 magazine 由小写英文字母组成

### 代码

- 两个HashMap

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        if (ransomNote.length() > magazine.length()) {
            return false;
        }
        HashMap<Character, Integer> map1 = new HashMap<>();
        HashMap<Character, Integer> map2 = new HashMap<>();
        for (int i = 0; i < ransomNote.length(); i++) {
            map1.put(ransomNote.charAt(i), map1.getOrDefault(ransomNote.charAt(i), 0) + 1);
        }
        for (int i = 0; i < magazine.length(); i++) {
            map2.put(magazine.charAt(i), map2.getOrDefault(magazine.charAt(i), 0) +1);
        }
        for (char key : map1.keySet()) {
            if (!map2.containsKey(key)) {
                return false;
            }
            else if (map1.get(key) > map2.get(key)) {
                return false;
            }
        }
        return true;
    }
}
```

- 数组-加减

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        if (ransomNote.length() > magazine.length()) {
            return false;
        }
        int[] num = new int[26];
        int i = 0;
        int j = 0;
        while(i < ransomNote.length() || j < magazine.length()) {
            if (i < ransomNote.length()) {
                num[ransomNote.charAt(i) - 'a']++;
                i++;
            }
            if ( j < magazine.length()) {
                num[magazine.charAt(j) - 'a']--;
                j++;
            }
        }
        for(i = 0; i < 26; i++) {
            if (num[i] > 0) {
                return false;
            }
        }
        return true;
    }
}
```

### 笔记

- 遇到只有小写字母组成，就可以考虑使用一个int[26]的数组来代替HashMap计数，下标表示字符与小写字母a的ASCII码相减，值表示该字符出现的次数。

## [387. 字符串中的第一个唯一字符](https://leetcode-cn.com/problems/first-unique-character-in-a-string/)

难度：简单:star::star::star:

### 题目

给定一个字符串 s ，找到 它的第一个不重复的字符，并返回它的索引 。如果不存在，则返回 -1 。

示例 1：

```
输入: s = "leetcode"
输出: 0
```

示例 2:

```
输入: s = "loveleetcode"
输出: 2
```

示例 3:

```
输入: s = "aabb"
输出: -1
```

提示:

- 1 <= s.length <= 10^5^
- s 只包含小写字母

### 代码

- 数组计数

```java
class Solution {
    public int firstUniqChar(String s) {
        int[] num = new int[26];
        for (int i = 0; i < s.length(); i++) {
            num[s.charAt(i) - 'a']++;
        }
        for (int i = 0; i < s.length(); i++) {
            if (num[s.charAt(i) - 'a'] == 1) {
                return i;
            }
        }
        return -1;
    }
}
```

### 笔记

## [389. 找不同](https://leetcode-cn.com/problems/find-the-difference/)

难度：简单:star::star::star:

### 题目

给定两个字符串 s 和 t ，它们只包含小写字母。

字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。

请找出在 t 中被添加的字母。

示例 1：

```
输入：s = "abcd", t = "abcde"
输出："e"
解释：'e' 是那个被添加的字母。
```

示例 2：

```
输入：s = "", t = "y"
输出："y"
```

提示：

- 0 <= s.length <= 1000
- t.length == s.length + 1
- s 和 t 只包含小写字母

### 代码

- 数组计数

```java
class Solution {
    public char findTheDifference(String s, String t) {
        int[] count = new int[26];
        for (int i = 0; i < s.length(); i++) {
            count[s.charAt(i) - 'a']++;
            count[t.charAt(i) - 'a']--;
        }
        count[t.charAt(s.length()) - 'a']--;
        for (int i = 0; i < 26; i++) {
            if (count[i] == -1) {
                return (char)(i + 97);
            }
        }
        return 'a';
    }
}
```

- 求和作差

```java
class Solution {
    public char findTheDifference(String s, String t) {
        int sum = 0;
        for (int i = 0; i < t.length(); i++) {
            sum += (t.charAt(i) - 'a');
        }
        for (int i = 0; i < s.length(); i++) {
            sum -= (s.charAt(i) - 'a');
        }
        return (char)(sum + (int)'a');
    }
}
```

- 异或

```java
class Solution {
    public char findTheDifference(String s, String t) {
        char xor = '\u0000';
        for (int i = 0; i < s.length(); i++) {
            xor ^= s.charAt(i);
        }
        for (int i = 0; i < t.length(); i++) {
            xor ^= t.charAt(i);
        }
        return xor;
    }
}
```

- 异或

```java
class Solution {
    public char findTheDifference(String s, String t) {
        int xor = 0;
        for (int i = 0; i < s.length(); i++) {
            xor ^= s.charAt(i);
        }
        for (int i = 0; i < t.length(); i++) {
            xor ^= t.charAt(i);
        }
        return (char)xor;
    }
}
```

### 笔记

- Java中的空字符：`char c = '\u0000';`

## [392. 判断子序列](https://leetcode-cn.com/problems/is-subsequence/)

难度：简单:star::star::star:

### 题目

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

进阶：

如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

致谢：

特别感谢 @pbrother 添加此问题并且创建所有测试用例。

示例 1：

```
输入：s = "abc", t = "ahbgdc"
输出：true
```

示例 2：

```
输入：s = "axc", t = "ahbgdc"
输出：false
```

提示：

- 0 <= s.length <= 100
- 0 <= t.length <= 10^4
- 两个字符串都只由小写字符组成。

### 代码

- 双指针

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        if(s.length() > t.length()) {
            return false;
        }
        int i = 0;
        int j = 0;
        while(j < t.length() && i < s.length()) {
            if (s.charAt(i) == t.charAt(j)) {
                i++;
            }
            j++;
        }
        return i == s.length();
    }
}
```

- 动态规划

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int m = s.length();
        int n = t.length();
        int[][] dp = new int[m + 1][n + 1];
        dp[0][0] = 0;
        for (int i = 1; i <= m; i++) {
            dp[i][0] = 0;
            for (int j = 1; j <= n; j++) {
                if (s.charAt(i-1) == t.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1] + 1;
                } else {
                    dp[i][j] = dp[i][j-1];
                }
            }
        }
        return dp[m][n] == m;
    }
}
```

- 官解动规

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int m = s.length();
        int n = t.length();
        // dp数组：dp[i][j]表示在字符串t中，从第i个位置开始（也即在t的子字符串t[i:]中），第一次出现字符j（这里的字符j我们用0到25的索引表示，0表示字符a,...,25表示字符z）的位置
        int[][] dp = new int[n + 1][26];
        // 初始化条件，dp[n][j] = n 表示在字符串t中，从第n（=t.length()）个位置开始，也即从t.charAt(n)（实际上对字符串t来说，取不到下标为n的字符）开始不存在任何字符
        for(int j = 0; j < 26; j++) {
            dp[n][j] = n;
        }
        // 从后往前递推，计算dp数组
        for(int i = n - 1; i >= 0; i--) {
            for (int j = 0; j < 26; j++) {
                // 从后往前看，记录字符串t中每个字符第一次出现的下标
                if (t.charAt(i) - 'a' == j) {
                    dp[i][j] = i;
                } else {
                    dp[i][j] = dp[i+1][j];
                }
            }
        }
        // 看字符串s中每一个字符在字符串t中第一次出现的位置
        int row = 0;
        for(int k = 0; k < m; k++) {
            // 如果字符串s中某个字符在字符串t中第一次出现的位置是n，就表示在字符串t中没有该字符
            if (dp[row][s.charAt(k) - 'a'] == n) {
                return false;
            }
            // 如果字符串s中某个字符在字符串t中第一次出现的位置是某个位置，那么该字符的下一个字符就可以直接从该字符在字符串t中第一次出现的位置的下一个位置开始找
            row = dp[row][s.charAt(k) - 'a'] + 1;
        }
        return true;
    }
}
```

### 笔记

- 在子序列中的相关问题，使用动态规划时，关于dp数组的定义，数组的下标通常是字符串中字符的下标，`dp[i]`通常表示一个长度。
  在本题中，是两个字符串，那一般会使用二维的dp数组，第一维的下标是一个字符串中字符的下标，第二维的下标也是一个字符串中字符的下标。`dp[i][j]`是表示一个长度。
- 动态规划：
  0. 首先想到要使用一个二维的dp数组，数组中的每个值表示的是一个长度。
  1. 然后确定状态：
     - 最后一步（ab是ahbgd的子序列，那么abc一定是ahbgdc的子序列）
     - 化成子问题（a是ah的子序列，那么ab一定是ahb的子序列，也一定是ahbgd的子序列
  2. 转移方程：
     - `s[i-1]==t[j-1], dp[i][j] = dp[i-1][j-1] + 1`。`dp[i][j]`表示一个表示一个长度为i的字符串s和一个长度为j的字符串t的公共子序列的长度。如果这两个字符串的最后一个字符相同，那么`dp[i][j] = dp[i-1][j-1] + 1`，也即长度为i和j的两个字符串的公共子序列的长度就等于长度为i-1和j-1（都去掉最后一个字符）的两个字符串的公共子序列的长度加1（加上最后一个字符，长度是1）。
     - `s[i-1] != t[j-1], dp[i][j] = dp[i][j-1]`。如果这两个字符串的最后一个字符不相同，那么长度为i和j的两个字符串的公共子序列的长度就等于长度为i和j-1（字符串t去掉最后一个字符）的两个字符串的公共子序列的长度
  3. 初始条件
      （初始条件的确定，主要是看`dp[i][j]`依赖哪些值，要确保在计算`dp[i][j]`之前，那些依赖的值都已经计算出来了）
     - `dp[0][0] `= 0；即两个长度为0的字符串的公共子序列长度是0；
     - `dp[i][0] `= 0; 即一个长度为i的字符串和一个长度为0的字符串的公共子序列长度是0。
  4. 计算顺序
     
      - 要先算`dp[i-1][j-1]`再算`dp[i][j]`，或者先算`dp[i][j-1]`再算`dp[i][j]`，也即从上往下，从左往右计算。
- 官方题解的动态规划:
  - dp数组：`dp[i][j]`表示在字符串t中，从第i个位置开始（也即在t的子字符串t[i:]中），第一次出现字符j（这里的字符j我们用0到25的索引表示，0表示字符a,...,25表示字符z）的位置
  - 初始化条件，`dp[n][j] = n `表示在字符串t中，从第n（=t.length()）个位置开始，也即从t.charAt(n)（实际上对字符串t来说，取不到下标为n的字符）开始不存在任何字符
  - 状态转移方程：
    - 如果t中的位置i的字符就是j,那么`dp[i][j] = i`
    - 否则，字符j就出现在t中的位置i+1开始往后，即`dp[i][j] = dp[i+1][j]`。
  - 要算`dp[i][[j]`我们得先算`dp[i+1][j]`，所以，我们要对字符串t倒着遍历。

## [401. 二进制手表](https://leetcode-cn.com/problems/binary-watch/)

难度：简单:star::star::star:

### 题目

二进制手表顶部有 4 个 LED 代表 小时（0-11），底部的 6 个 LED 代表 分钟（0-59）。每个 LED 代表一个 0 或 1，最低位在右侧。

例如，下面的二进制手表读取 "3:25" 。

![img](noteImage/binary_clock_samui_moon.jpg)

（图源：WikiMedia - Binary clock samui moon.jpg ，许可协议：Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0) ）

给你一个整数 turnedOn ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 按任意顺序 返回答案。

小时不会以零开头：

- 例如，"01:00" 是无效的时间，正确的写法应该是 "1:00" 。

分钟必须由两位数组成，可能会以零开头：

- 例如，"10:2" 是无效的时间，正确的写法应该是 "10:02" 。

示例 1：

```
输入：turnedOn = 1
输出：["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"]
```

示例 2：

```
输入：turnedOn = 9
输出：[]
```

提示：

- 0 <= turnedOn <= 10

### 代码

- 枚举+bitCount

```java
class Solution {
    public List<String> readBinaryWatch(int turnedOn) {
        ArrayList<String> res = new ArrayList<>();
        StringBuilder time = new StringBuilder();
        for (int h = 0; h < 12; h++) {
            for (int m = 0; m < 60; m++) {
                if(Integer.bitCount(h) + Integer.bitCount(m) == turnedOn) {
                    time.append(h + ":");
                    time.append(m < 10 ? "0" + m: m);
                    res.add(time.toString());
                    time.setLength(0);
                }
            }
        }
        return res;
    }
}
```

### 笔记

- 枚举+bitCount：由题意可知，小时由 4个比特表示，分钟由 6个比特表示，比特位值为 0表示灯灭，为 1 表示灯亮。
  
  我们可以枚举小时的所有可能值 `[0,11]`，以及分钟的所有可能值 `[0,59]`，并计算二者的二进制中 1的个数之和，若为turnedOn，则将其加入到答案中。

## [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

难度：简单:star::star::star:

### 题目

给定二叉树的根节点 root ，返回所有左叶子之和。

示例 1：

![img](noteImage/leftsum-tree.jpg)

```
输入: root = [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

示例 2:

```
输入: root = [1]
输出: 0
```

提示:

- 节点数在 [1, 1000] 范围内
- -1000 <= Node.val <= 1000

### 代码

- 前序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int sum = 0;
    public int sumOfLeftLeaves(TreeNode root) {
       if (root != null) {
            if (root.left != null && root.left.left == null && root.left.right == null) {
                sum += root.left.val;
            }
            sumOfLeftLeaves(root.left);
            sumOfLeftLeaves(root.right);
        }
        return sum;
    }
}
```

- 中序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int sum = 0;
    public int sumOfLeftLeaves(TreeNode root) {
       if (root != null) {
           sumOfLeftLeaves(root.left);
            if (root.left != null && root.left.left == null && root.left.right == null) {
                sum += root.left.val;
            }
            sumOfLeftLeaves(root.right);
        }
        return sum;
    }
}
```

- 后序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int sum = 0;
    public int sumOfLeftLeaves(TreeNode root) {
       if (root != null) {
           sumOfLeftLeaves(root.left);
           sumOfLeftLeaves(root.right);
            if (root.left != null && root.left.left == null && root.left.right == null) {
                sum += root.left.val;
            }
        }
        return sum;
    }
}
```

- 层次遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
       Queue<TreeNode> queue = new LinkedList<>();
       queue.offer(root);
       int sum = 0;
       while(!queue.isEmpty()) {
           TreeNode p = queue.poll();
           if (p.left != null && p.left.left == null && p.left.right == null) {
               sum += p.left.val;
           }
           if (p.left != null) {
               queue.offer(p.left);
           }
           if (p.right != null) {
               queue.offer(p.right);
           }
       }
       return sum;
    }
}
```

### 笔记

- 判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。
  判断是否是左叶子结点：
  
  ```java
  if (root.left != null && root.left.left == null && root.left.right == null) {
          System.out.println(root.left.val);
  }
  ```

## [405. 数字转换为十六进制数](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/)

难度：简单:star::star::star:

### 题目

给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。

注意:

十六进制中所有字母(a-f)都必须是小写。
十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 
给定的数确保在32位有符号整数范围内。
不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。
示例 1：

```
输入:
26

输出:
"1a"
```

示例 2：

```
输入:
-1

输出:
"ffffffff"
```

### 代码

- 循环模拟

```java
class Solution {
    public String toHex(int num) {
        if (num == 0) {
            return "0";
        }
        StringBuilder res = new StringBuilder();
        // 处理负数的补码
        long _num = num;
        if (_num < 0) {
            _num += Math.pow(2, 32);
        }
        while(_num > 0) {
            long m = _num % 16;
            if (m < 10) {
                res.append((char)(m + '0'));
            } else {
                res.append((char)(m - 10 + 'a'));
            }
            _num /= 16;
        } 
        res.reverse();
        return res.toString();
    }
}
```

- 位运算+分组

```java
class Solution {
    public String toHex(int num) {
        if (num == 0) {
            return "0";
        }
        StringBuilder res = new StringBuilder();
        while (num != 0) {
            int m = num & 0xf;
            if (m < 10) {
                res.append((char)(m + '0'));
            } else {
                res.append((char)(m - 10 + 'a'));
            }
            num >>>= 4; // 无符号右移四位
        }
        res.reverse();
        return res.toString();
    }
}
```

### 笔记

- 循环模拟：首先，我们可以利用通用的进制转换思路来做，不断循环 num % k 和 num / k 的操作来构造出 k进制每一位。
  但需要处理「补码」问题：对于负数的 num，我们需要先在 num基础上加上 2^32的偏移量，再进行进制转换。

- 一个十六进制数可以用4位二进制数表示，所以可以将 num 的二进制数按照四位一组分成 8 组，依次将每一组转换为对应的十六进制数，即可得到num 的十六进制数。

- Java中`>>`和`>>>`的区别：
  
  - `>>`：带符号右移。正数右移高位补0，负数右移高位补1。比如：
    `4 >> 1`，结果是2；`-4 >> 1`，结果是-2。`-2 >> 1`，结果是-1。
  
  - `>>>`：无符号右移。无论是正数还是负数，高位通通补0。
  
  对于正数而言，`>>`和`>>>`没区别。
  对于负数而言，`-2 >>> 1`，结果是2147483647（Integer.MAX_VALUE），`-1 >>> 1`，结果是2147483647（Integer.MAX_VALUE）。

## [409. 最长回文串](https://leetcode-cn.com/problems/longest-palindrome/)

难度：简单:star::star::star:

### 题目

给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。

在构造过程中，请注意 区分大小写 。比如 "Aa" 不能当做一个回文字符串。

示例 1:

```
输入:s = "abccccdd"
输出:7
解释:
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。
```

示例 2:

```
输入:s = "a"
输入:1
```

示例 3:

```
输入:s = "bb"
输入: 2
```

提示:

- 1 <= s.length <= 2000
- s 只能由小写和/或大写英文字母组成

### 代码

- 计数

```java
class Solution {
    public int longestPalindrome(String s) {
        int[] count = new int[58];
        for (int i = 0; i < s.length(); i++) {
            count[s.charAt(i) - 'A']++;
        }
        int res = 0;
        for(int num : count) {
            res += (num / 2) * 2;
            // 最多只需要一个奇数字符，如果已经是奇数了，就不用再加1了。如果res是偶数，刚好有一个字符是奇数个，那么res就可以加1
            if (res % 2 == 0 && num % 2 == 1) {
                res++;
            }
        }
        return res;
    }
}
```

### 笔记

- 常用ASCII码的范围：
  0-9的十进制ASCII码是：48-57
  A-Z的十进制ASCII码是：65-90
  a-z的十进制ASCII码是：97-122
- 回文字符串的长度：偶数对 字符的个数 * 2 + 1（如果至少有一个字符的个数为奇数）

## [412. Fizz Buzz](https://leetcode-cn.com/problems/fizz-buzz/)

难度：简单:star::star::star:

### 题目

给你一个整数 n ，找出从 1 到 n 各个整数的 Fizz Buzz 表示，并用字符串数组 answer（下标从 1 开始）返回结果，其中：

- answer[i] == "FizzBuzz" 如果 i 同时是 3 和 5 的倍数。
- answer[i] == "Fizz" 如果 i 是 3 的倍数。
- answer[i] == "Buzz" 如果 i 是 5 的倍数。
- answer[i] == i （以字符串形式）如果上述条件全不满足。

示例 1：

```
输入：n = 3
输出：["1","2","Fizz"]
```

示例 2：

```
输入：n = 5
输出：["1","2","Fizz","4","Buzz"]
```

示例 3：

```
输入：n = 15
输出：["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14","FizzBuzz"]
```

提示：

- 1 <= n <= 10^4^

### 代码

- 循环

```java
class Solution {
    public List<String> fizzBuzz(int n) {
        ArrayList<String> res = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            if (i % 3 == 0 && i % 5 == 0) {
                res.add("FizzBuzz");
            } 
            else if (i % 3 == 0) {
                res.add("Fizz");
            }
            else if (i % 5 == 0) {
                res.add("Buzz");
            }
            else {
                res.add(i+"");
            }
        }
        return res;
    }
}
```

### 笔记

## [415. 字符串相加](https://leetcode-cn.com/problems/add-strings/)

难度：简单:star::star::star:

### 题目

给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。

你不能使用任何內建的用于处理大整数的库（比如 BigInteger）， 也不能直接将输入的字符串转换为整数形式。

示例 1：

```
输入：num1 = "11", num2 = "123"
输出："134"
```

示例 2：

```
输入：num1 = "456", num2 = "77"
输出："533"
```

示例 3：

```
输入：num1 = "0", num2 = "0"
输出："0"
```

提示：

- 1 <= num1.length, num2.length <= 10^4^
- num1 和num2 都只包含数字 0-9
- num1 和num2 都不包含任何前导零

### 代码

- 模拟加法

```java
class Solution {
    public String addStrings(String num1, String num2) {
        StringBuilder res = new StringBuilder();
        int carry = 0;
        int sum = 0;
        int i = num1.length() - 1;
        int j = num2.length() - 1;
        while (i >= 0 || j >= 0) {
            if (i < 0) {
                sum = num2.charAt(j) - '0';
                j--;
            }
            else if (j < 0) {
                sum = num1.charAt(i) - '0';
                i--;
            }
            else {
                sum = (num1.charAt(i) - '0') + (num2.charAt(j) - '0');
                i--;
                j--;
            }
            sum += carry;
            carry = sum / 10;
            res.append(sum % 10);
        }
        if (carry > 0) {
            res.append(carry);
        }
        return res.reverse().toString();
    }
}
```

### 笔记

- Java中char转int：
  
  ```java
  int num = Character.getNumericValue(ch);
  ```
  
  ```java
  int num = ch - '0'; // ch是数字字符
  ```
  
  ```java
  int num = Integer.parseInt(String.valueOf(ch))
  ```
  
  Java中int转char:
  
  ```java
  char ch = Character.forDigit(num,10); // num是数字
  ```
  
  ```java
  char ch = String.valueOf(num).charAt(0);
  ```
  
  ```java
  char ch = (char)('0' + num); // num是数字
  ```

## [434. 字符串中的单词数](https://leetcode-cn.com/problems/number-of-segments-in-a-string/)

难度：简单:star::star::star:

### 题目

统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。

请注意，你可以假定字符串里不包括任何不可打印的字符。

示例:

```
输入: "Hello, my name is John"
输出: 5
解释: 这里的单词是指连续的不是空格的字符，所以 "Hello," 算作 1 个单词。
```

### 代码

- 快慢指针

```java
class Solution {
    public int countSegments(String s) {
        int res = 0;
        int fast = 0;
        int slow = 0;
        while(slow < s.length()) {
            while(fast < s.length() && s.charAt(fast) != ' ') {
                fast++;
            }
            fast++;
            if (slow < fast && s.charAt(slow) != ' ') {
                res++;
            }
            slow = fast;
        }
        return res;
    }
}
```

- 统计单词首字母的个数

```java
class Solution {
    public int countSegments(String s) {
        if (s.length() == 0) {
            return 0;
        }
        int res = 0;
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) != ' ' && s.charAt(i - 1) == ' ') {
                res++;
            }
        }
        return s.charAt(0) == ' ' ? res : res + 1;
    }
}
```

- 统计单词首字母的个数

```java
class Solution {
    public int countSegments(String s) {
        int res = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) != ' ' && (i == 0 || s.charAt(i - 1) == ' ')) {
                res++;
            }
        }
        return res;
    }
}
```

### 笔记

- 计算字符串中单词的数量，就等同于计数单词的第一个下标的个数。因此，我们只需要遍历整个字符串，统计每个单词的第一个下标的数目即可。
  满足单词的第一个下标有以下两个条件：
  - 该下标对应的字符不为空格；
  - 该下标为初始下标或者该下标的前下标对应的字符为空格；
- 快慢指针：快指针找单词尾的空格，慢指针找单词头的非空格

## [441. 排列硬币](https://leetcode-cn.com/problems/arranging-coins/)

难度：简单:star::star::star:

### 题目

你总共有 n 枚硬币，并计划将它们按阶梯状排列。对于一个由 k 行组成的阶梯，其第 i 行必须正好有 i 枚硬币。阶梯的最后一行 可能 是不完整的。

给你一个数字 n ，计算并返回可形成 完整阶梯行 的总行数。

示例 1：

![img](noteImage/arrangecoins1-grid.jpg)

```
输入：n = 5
输出：2
解释：因为第三行不完整，所以返回 2 。
```

示例 2：

![img](noteImage/arrangecoins2-grid.jpg)

```
输入：n = 8
输出：3
解释：因为第四行不完整，所以返回 3 。
```

提示：

- 1 <= n <= 2^31^ - 1

### 代码

- 数学法

```java
class Solution {
    public int arrangeCoins(int n) {
        double x = Math.sqrt(2.0d * n + 0.25) - 0.5;
        return (int)Math.floor(x);
    }
}
```

- 循环

```java
class Solution {
    public int arrangeCoins(int n) {
        int row = 1;
        while(row <= n) {
            n -= row;
            row++;
        }
        return row - 1;
    }
}
```

- 二分法

```java
class Solution {
    public int arrangeCoins(int n) {
        long l = 1;
        long r = n;
        while(l < r) {
            long mid = l + (r - l) / 2;
            if (mid * (mid + 1) / 2 <= n) {
                l = mid + 1;
            } else {
                r = mid;
            }
        }
        return l > 1 ? (int)l - 1 : 1;
    }
}
```

### 笔记

- Java中Math类的常用方法：
  
  ```java
  double num;
  double res = Math.sqrt(num); // 计算num的算术平方根
  double res = Math.floor(num); // 返回给定参数最大的整数，该整数小于或等给定的参数。
  ```

- 数学法：设总行数为x，则有$\frac{x*(x+1)}{2} \geq n$，解得
  $x \geq \sqrt{2n+\frac{1}{4}} - \frac{1}{2}$，算出x后，取小于等于x的最大整数即可

- 二分法：到第 k 行时的总硬币数等于 k(k+1)/2，只要找到最接近 n 的那个 k 就可以了。

## [455. 分发饼干](https://leetcode-cn.com/problems/assign-cookies/)

难度：简单:star::star::star

### 题目

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

示例 1:

```
输入: g = [1,2,3], s = [1,1]
输出: 1
解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。
```

示例 2:

```
输入: g = [1,2], s = [1,2,3]
输出: 2
解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.
```

提示：

- 1 <= g.length <= 3 * 10^4^
- 0 <= s.length <= 3 * 10^4^
- 1 <= g[i], s[j] <= 2^31^ - 1

### 代码

- 大胃口给大饼干

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int res = 0;
        // 最大的胃口需要给最大的饼干
        int j = s.length - 1;
        for(int i = g.length - 1; i >= 0 && j >= 0; i--) {
            if (s[j] >= g[i]) {
                j--;
                res++;
            }
        }
        return res;
    }
}
```

- 小饼干给小胃口

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        Arrays.sort(g);
        Arrays.sort(s);
        int res = 0;
        // 最小的饼干给最小的胃口
        for (int j = 0, i = 0; j < s.length && i < g.length; j++) {
            if (s[j] >= g[i]) {
                i++;
                res++;
            }
        }
        return res;

    }
}
```

### 笔记

- 想清楚局部最优，想清楚全局最优，感觉局部最优是可以推出全局最优，**并想不出反例**，那么就试一试贪心。

## [459. 重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)

难度：简单:star::star::star:

### 题目

给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。

示例 1:

```
输入: s = "abab"
输出: true
解释: 可由子串 "ab" 重复两次构成。
```

示例 2:

```
输入: s = "aba"
输出: false
```

示例 3:

```
输入: s = "abcabcabcabc"
输出: true
解释: 可由子串 "abc" 重复四次构成。 (或子串 "abcabc" 重复两次构成。)
```

提示：

- 1 <= s.length <= 10^4^
- s 由小写英文字母组成

### 代码

- 双倍字符串匹配

```java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        return (s + s).indexOf(s, 1) != s.length();
    }
}
```

- 枚举子串

```java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        int n = s.length();
        // 枚举子串的长度，1,2,3...，子串的长度最大为n/2
        for(int i = 1; 2 * i <= n; i++) {
            // 能构成，则n是子串长度的倍数
            if (n % i == 0) {
                boolean match = true;
                for(int j = i; j < n; j++) {
                    if (s.charAt(j) != s.charAt(j - i)) {
                        match = false;
                        break;
                    }
                }
                if (match) {
                    return true;
                }
            }
        }
        return false;
    }
}
```

### 笔记

- 双倍字符串匹配：我们将两个 s连在一起，并移除第一个和最后一个字符。如果 s 是该字符串的子串，那么 s就满足题目要求。可以证明，我们可以从位置 1开始查询，并希望查询结果**不为位置 n**，这与移除字符串的第一个和最后一个字符**是等价的**。

- 枚举子串：链接：https://leetcode-cn.com/problems/repeated-substring-pattern/solution/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/

- Java中String的indexOf():
  
  ```java
  int indexOf(String str, int fromIndex);
  // 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。
  ```

## [461. 汉明距离](https://leetcode-cn.com/problems/hamming-distance/)

难度：简单:star::star::star:

### 题目

两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。

给你两个整数 x 和 y，计算并返回它们之间的汉明距离。

示例 1：

```
输入：x = 1, y = 4
输出：2
解释：
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。
```

示例 2：

```
输入：x = 3, y = 1
输出：1
```

提示：

- 0 <= x, y <= 2^31^ - 1

### 代码

- Integer.bitCount

```java
class Solution {
    public int hammingDistance(int x, int y) {
        return Integer.bitCount(x ^ y);
    }
}
```

- 右移

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int res = 0;
        for (int i = 0; i < 32; i++) {
            int a = (x >> i) & 1;
            int b = (y >> i) & 1;
            res += a ^ b;
        }
        return res;
    }
}
```

- 右移

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int res = 0;
        for (int i = 0; i < 32; i++) {
            int a = x & 1;
            int b = y & 1;
            res += a ^ b;
            x >>= 1;
            y >>= 1;
        }
        return res;
    }
}
```

- 异或

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int res = 0;
        int s = x ^ y;
        while (s != 0) {
            s = s & (s - 1);
            res++;
        }
        return res;
    }
}
```

- 异或

```java
class Solution {
    public int hammingDistance(int x, int y) {
        int res = 0;
        int s = x ^ y;
        while (s != 0) {
            res += (s & 1);
            s >>= 1;
        }
        return res;
    }
}
```

### 笔记

- 一个数`a&1`可以取出a的最后一位
- 每次执行`s = s & (s - 1);`都会移除s中最低位的一个1。

## [463. 岛屿的周长](https://leetcode-cn.com/problems/island-perimeter/)

难度：简单:star::star::star:

### 题目

给定一个 row x col 的二维网格地图 grid ，其中：`grid[i][j]` = 1 表示陆地， `grid[i][j]` = 0 表示水域。

网格中的格子 水平和垂直 方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。

示例 1：

![img](noteImage/island.png)

```
输入：grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]
输出：16
解释：它的周长是上面图片中的 16 个黄色的边
```

示例 2：

```
输入：grid = [[1]]
输出：4
```

示例 3：

```
输入：grid = [[1,0]]
输出：4
```

提示：

- row == grid.length
- col == grid[i].length
- 1 <= row, col <= 100
- `grid[i][j]` 为 0 或 1

### 代码

- 深度优先搜索

```java
class Solution {
    static int[][] direction = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    public int islandPerimeter(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int perimeter = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    perimeter += dfs(i, j, grid, m, n);
                }
            }
        }
        return perimeter;
    }
    public int dfs(int x, int y, int[][] grid, int m, int n) {
        // 遇到边界或水域，边+1
        if (x < 0 || y < 0 || x >=m || y >= n || grid[x][y] == 0) {
            return 1;
        }
        // 已经访问过
        if (grid[x][y] == 2) {
            return 0;
        }
        grid[x][y] = 2;
        int count = 0;
        // 往上下左右四个方向走
        for (int i = 0; i < 4; i++) {
            count += dfs(x + direction[i][0], y + direction[i][1], grid, m, n);
        }
        return count;
    }
}
```

- 遍历

```java
class Solution {

    public int islandPerimeter(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int perimeter = 0;
        int[][] direction = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    for(int d = 0; d < 4; d++) {
                        int x = i + direction[d][0];
                        int y = j + direction[d][1];
                        if (x < 0 || y < 0 || x >= m || y >= n || grid[x][y]==0) {
                            perimeter++;
                        }
                    }
                }
            }
        }
        return perimeter;
    }
}
```

- 遍历

```java
class Solution {

    public int islandPerimeter(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int land = 0; //岛屿个数
        int join = 0; // 上边和左边有岛屿的个数
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    land++;
                    // 上边是岛屿
                    if (i - 1 >= 0 && grid[i-1][j] == 1) {
                        join++;
                    }
                    // 左边是岛屿
                    if (j - 1 >= 0 && grid[i][j-1] == 1) {
                        join++;
                    }
                    // 不用计算下边和右边，避免重复
                }

            }
        }
        return land * 4 - join * 2;
    }
}
```

### 笔记

- 遍历：遍历每个陆地格子，**看其四个方向是否为边界或者水域**，如果是，将这条边的贡献（即 1）加入答案 ans 中即可。

- 深度优先搜索：深度优先搜索可以扩展到统计多个岛屿各自的周长。需要注意的是为了防止陆地格子在深度优先搜索中被重复遍历导致死循环，我们需要将遍历过的陆地格子标记为已经遍历过，下面的代码中我们设定值为 2的格子为已经遍历过的陆地格子。

- Java二维网格中定义上下左右四个方向：
  
  ```java
  int[][] direction = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
  ```

- 遍历：有两个陆地相连，就会减去两条边，可以发现，总边数=总陆地数 * 4 - 相邻的边数 * 2。
  计算相邻的边数时，看一个陆地的上边和左边是否有陆地，有就加1，注意，不用计算下边和右边，避免重复计算相邻的边。

## [476. 数字的补数](https://leetcode-cn.com/problems/number-complement/)

难度：简单:star::star::star:

### 题目

对整数的二进制表示取反（0 变 1 ，1 变 0）后，再转换为十进制表示，可以得到这个整数的补数。

例如，整数 5 的二进制表示是 "101" ，取反后得到 "010" ，再转回十进制表示得到补数 2 。
给你一个整数 num ，输出它的补数。

示例 1：

```
输入：num = 5
输出：2
解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。
```

示例 2：

```
输入：num = 1
输出：0
解释：1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。
```

提示：

- 1 <= num < 2^31^

### 代码

- 模拟

```java
class Solution {
    public int findComplement(int num) {
        int s = -1;
        // 找到最高位的1
        for (int i = 31; i >= 0; i--) {
            if ((num >> i) != 0) {
                s = i;
                break;
            }
        }
        int res = 0;
        // 从最低位到最高位的1
        for(int i = 0; i < s; i++) {
            // num右移i位和1相与等于0就说明num的第i位是0，把第i位的0变成1就是把1左移i位
            if (((num >> i) & 1) == 0) {
                res |= (1 << i);
            }
        }
        return res;
    }
}
```

- 取反

```java
class Solution {
    public int findComplement(int num) {
        return ~num & ((Integer.highestOneBit(num) << 1) - 1);
    }
}
```

- 异或

```java
class Solution {
    public int findComplement(int num) {
        return num ^ ((Integer.highestOneBit(num) << 1) - 1);
    }
}
```

### 笔记

- 模拟：首先找到最高位的1，然后从最低位遍历到最高位的1，进行逐位取反，取反操作：num右移i位和1相与等于0就说明num的第i位是0，把第i位的0变成1就是把1左移i位。

- 取反：
  位运算中有一个运算符` ~ `表示取反，可不可以用它呢？我们实验一下：
  
  ```
  >>> Integer.toBinaryString(5)
  101
  >>> Integer.toBinaryString(~5)
  11111111111111111111111111111010
  ```
  
  我们看到，虽然 5 的二进制 101 被取反了，但是其前导 0 也被取反。
  对于 Java 而言，有库函数可以使用 `Integer.highestOneBit(num) `，它的作用是只保留 num 二进制的最高位的 1 的情况下的数字。
  
  ```
  >>> Integer.highestOneBit(5)
  4
  ```
  
  我们想得到和 num 的二进制位置相等的全 1 的数字，可以用 `((Integer.highestOneBit(num)) << 1) - 1`。

- 异或：把原本的数字的每一位都和 1 进行异或计算。
  我们需要构建和源数字的二进制位数相等的全 1 数字。可以用 `((Integer.highestOneBit(num)) << 1) - 1`。

## [482. 密钥格式化](https://leetcode-cn.com/problems/license-key-formatting/)

难度：简单:star::star::star:

### 题目

给定一个许可密钥字符串 s，仅由字母、数字字符和破折号组成。字符串由 n 个破折号分成 n + 1 组。你也会得到一个整数 k 。

我们想要重新格式化字符串 s，使每一组包含 k 个字符，除了第一组，它可以比 k 短，但仍然必须包含至少一个字符。此外，两组之间必须插入破折号，并且应该将所有小写字母转换为大写字母。

返回 重新格式化的许可密钥 。

示例 1：

```
输入：S = "5F3Z-2e-9-w", k = 4
输出："5F3Z-2E9W"
解释：字符串 S 被分成了两个部分，每部分 4 个字符；
     注意，两个额外的破折号需要删掉。
```

示例 2：

```
输入：S = "2-5g-3-J", k = 2
输出："2-5G-3J"
解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。
```

提示:

- 1 <= s.length <= 10^5^
- s 只包含字母、数字和破折号 '-'.
- 1 <= k <= 10^4^

### 代码

- 暴力法

```java
class Solution {
    public String licenseKeyFormatting(String s, int k) {
        StringBuilder res = new StringBuilder();
        for(int i = s.length()-1; i >= 0;) {
            int count = 0;
            while(count < k) {
                if (i < 0) {
                    break;
                }
                if (s.charAt(i) != '-') {
                    res.append(Character.toUpperCase(s.charAt(i)));
                    count++;
                }
                i--;
            }
            if (count == k) {
                res.append("-");
            }
        }
        res.reverse();
        if (res.length() == 0) {
            return "";
        }
        if (res.charAt(0) == '-') {
            res.deleteCharAt(0);
        }
        return res.toString();
    }
}
```

### 笔记

- Java中字母转大写字母：
  
  ```java
  Character.toUpperCase(); // 方法用于将小写字符转换为大写。返回转换后字符的大写形式，如果有的话；否则返回字符本身。
  ```
  
  StringBuilder的常用方法：
  
  ```java
  StringBuilder sb = new StringBuilder();
  char ch = sb.charAt(int index); //返回指定索引处的此序列中的 char值。
  sb.deleteCharAt(int index); //按此顺序删除指定位置的 char 。
  ```

## [492. 构造矩形](https://leetcode-cn.com/problems/construct-the-rectangle/)

难度：简单:star::star::star:

### 题目

作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 所以，现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：

1. 你设计的矩形页面必须等于给定的目标面积。
2. 宽度 W 不应大于长度 L ，换言之，要求 L >= W 。
3. 长度 L 和宽度 W 之间的差距应当尽可能小。

返回一个 数组 [L, W]，其中 L 和 W 是你按照顺序设计的网页的长度和宽度。

示例1：

```
输入: 4
输出: [2, 2]
解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。
但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。
```

示例 2:

```
输入: area = 37
输出: [37,1]
```

示例 3:

```
输入: area = 122122
输出: [427,286]
```

提示:

- 1 <= area <= 10^7^

### 代码

- 开方，遍历

```java
class Solution {
    public int[] constructRectangle(int area) {
        int high = (int)Math.floor(Math.sqrt(area));
        int L = 0;
        int W = 0;
        for(int i = high; i > 0; i--) {
            if (area % i ==0) {
                W = i;
                L = area / i;
                break;
            }
        }
        return new int[]{L, W};

    }
}
```

- 数学

```java
class Solution {
    public int[] constructRectangle(int area) {
        int W = (int)Math.sqrt(area);
        while(area % W != 0) {
            W--;
        }
        return new int[]{area / W, W};
    }
}
```

### 笔记

- 使用开方，缩减范围，然后遍历

## [500. 键盘行](https://leetcode-cn.com/problems/keyboard-row/)

难度：简单:star::star::star:

### 题目

给你一个字符串数组 words ，只返回可以使用在 美式键盘 同一行的字母打印出来的单词。键盘如下图所示。

美式键盘 中：

第一行由字符 "qwertyuiop" 组成。
第二行由字符 "asdfghjkl" 组成。
第三行由字符 "zxcvbnm" 组成。

![American keyboard](noteImage/keyboard.png)

示例 1：

```
输入：words = ["Hello","Alaska","Dad","Peace"]
输出：["Alaska","Dad"]
```

示例 2：

```
输入：words = ["omk"]
输出：[]
```

示例 3：

```
输入：words = ["adsdf","sfd"]
输出：["adsdf","sfd"]
```

提示：

- 1 <= words.length <= 20
- 1 <= words[i].length <= 100
- words[i] 由英文字母（小写和大写字母）组成

### 代码

- 暴力法

```java
class Solution {
    public String[] findWords(String[] words) {
        String row1 = "qwertyuiop";
        String row2 = "asdfghjkl";
        String row3 = "zxcvbnm";
        HashSet<Character> set1 = new HashSet<>();
        HashSet<Character> set2 = new HashSet<>();
        HashSet<Character> set3 = new HashSet<>();
        for(int i = 0; i < row1.length(); i++) {
            set1.add(row1.charAt(i));
        }
        for(int i = 0; i < row2.length(); i++) {
            set2.add(row2.charAt(i));
        }
        for(int i = 0; i < row3.length(); i++) {
            set3.add(row3.charAt(i));
        }
        String[] res = new String[words.length];
        int count = 0;
        for(String word : words) {
            boolean flag = true;
            for (int i = 0; i < word.length(); i++) {
                if (!set1.contains(Character.toLowerCase(word.charAt(i)))) {
                    flag = false;
                }
            }
            if (flag) {
                res[count] = word;
                count++;
                continue;
            }
            flag = true;
            for (int i = 0; i < word.length(); i++) {
                if (!set2.contains(Character.toLowerCase(word.charAt(i)))) {
                    flag = false;
                }
            }
            if (flag) {
                res[count] = word;
                count++;
                continue;
            }
            flag = true;
            for (int i = 0; i < word.length(); i++) {
                if (!set3.contains(Character.toLowerCase(word.charAt(i)))) {
                    flag = false;
                }
            }
            if (flag) {
                res[count] = word;
                count++;
                continue;
            }
        }
        // System.out.println(count);
        return Arrays.copyOfRange(res, 0, count);
    }
}
```

- Hash数组

```java
class Solution {
    public String[] findWords(String[] words) {
        String[] keyboard = new String[]{"qwertyuiop", "asdfghjkl", "zxcvbnm"};
        int[] hash = new int[26];
        // 记录每个字符的行号
        for(int row = 0; row < 3; row++) {
            for(int i = 0; i < keyboard[row].length(); i++) {
                hash[Character.toLowerCase(keyboard[row].charAt(i)) - 'a'] = row + 1;
            }
        }
        String[] res = new String[words.length];
        int count = 0;
        for(String word : words) {
            boolean flag = true;
            // 看这个单词的每个字母是否个第一个字母的行数一样
            int row = hash[Character.toLowerCase(word.charAt(0)) - 'a'];
            for(int i = 1; i < word.length(); i++) {
                if (hash[Character.toLowerCase(word.charAt(i)) - 'a'] != row) {
                    flag = false;
                    break;
                }
            }
            if (flag) {
                res[count] = word;
                count++;
            }
        }
        return Arrays.copyOfRange(res, 0, count);
    }
}
```

### 笔记

- Hash数组：首先记录每个字符的行号，然后**看这个单词的每个字母是否和第一个字母的行数一样**

## [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

难度：简单:star::star::star:

### 题目

给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。

如果树中有不止一个众数，可以按 任意顺序 返回。

假定 BST 满足如下定义：

结点左子树中所含节点的值 小于等于 当前节点的值
结点右子树中所含节点的值 大于等于 当前节点的值
左子树和右子树都是二叉搜索树

示例 1：

![img](noteImage/mode-tree.jpg)

```
输入：root = [1,null,2,2]
输出：[2]
```

示例 2：

```
输入：root = [0]
输出：[0]
```

提示：

- 树中节点的数目在范围 [1, 10^4^] 内
- -10^5^ <= Node.val <= 10^5^

进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）

### 代码

- 暴力法

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int[] findMode(TreeNode root) {
        ArrayList<Integer> value = new ArrayList<>();
        inOrder(root, value);
        HashMap<Integer, Integer> map = new HashMap<>();
        for(Integer v : value) {
            map.put(v, map.getOrDefault(v, 0) + 1);
        }
        int max = Integer.MIN_VALUE;
        for(Integer v : map.values()) {
            max = v > max ? v : max;
        }
        int[] res = new int[value.size()];
        int count = 0;
        for(Integer v : map.keySet()) {
            if (max == map.get(v)) {
                res[count] = v.intValue();
                count++;
            }
        }
        return Arrays.copyOfRange(res, 0, count);
    }
    public void inOrder(TreeNode root, ArrayList<Integer> value) {
        if (root != null) {
            inOrder(root.left, value);
            value.add(root.val);
            inOrder(root.right, value);
        }
    }
}
```

- 中序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private int cur = 0;
    private int count = 0;
    private int max = Integer.MIN_VALUE;
    private ArrayList<Integer> value = new ArrayList<>();
    public int[] findMode(TreeNode root) {
        inOrder(root);
        int[] res = new int[value.size()];
        int i = 0;
        for(Integer v : value) {
            res[i] = v;
            i++;
        }
        return res;

    }
    public void update(int x) {
        if (x == cur) {
            count++;
        } else {
            // 这里count要从1开始，不能从0开始
            count = 1;
            cur = x;
        }
        // 遇到更大的，就清空之前的，重新添加进去
        if (count > max) {
            max = count;
            value.clear();
            value.add(x);
        } else if (count == max) {
            value.add(x);
        }
    }
    public void inOrder(TreeNode root) {
        if (root != null) {
            inOrder(root.left);
            update(root.val);
            inOrder(root.right);
        }
    }
}
```

### 笔记

- 中序遍历：由于二叉搜索树的中序遍历是个非递减的有序序列，利用这个性质，在遍历时，就统计结点的值的个数，并且把它“当作众数”加到结果集中，当出现比这个个数要大的值的时候，就把之前的结果集清空，重新加入当前这个更大的值对应的结点的值到结果集中。这样就不用完整的存储整个树的结点。

## [504. 七进制数](https://leetcode-cn.com/problems/base-7/)

难度：简单:star::star::star:

### 题目

给定一个整数 num，将其转化为 7 进制，并以字符串形式输出。

示例 1:

```
输入: num = 100
输出: "202"
```

示例 2:

```
输入: num = -7
输出: "-10"
```

提示：

- -10^7^ <= num <= 10^7^

### 代码

- 模拟

```java
class Solution {
    public String convertToBase7(int num) {
        if (num == 0) {
            return "0";
        }
        StringBuilder res = new StringBuilder();
        boolean flag = false;
        if (num < 0) {
            flag = true;
            num = num * (-1);
        }
        while(num > 0) {
            res.append(num % 7);
            num = num / 7;
        }
        if (flag) {
            res.append("-");
        }
        return res.reverse().toString();
    }
}
```

### 笔记

## [506. 相对名次](https://leetcode-cn.com/problems/relative-ranks/)

难度：简单:star::star::star:

### 题目

给你一个长度为 n 的整数数组 score ，其中 score[i] 是第 i 位运动员在比赛中的得分。所有得分都 互不相同 。

运动员将根据得分 决定名次 ，其中名次第 1 的运动员得分最高，名次第 2 的运动员得分第 2 高，依此类推。运动员的名次决定了他们的获奖情况：

名次第 1 的运动员获金牌 "Gold Medal" 。
名次第 2 的运动员获银牌 "Silver Medal" 。
名次第 3 的运动员获铜牌 "Bronze Medal" 。
从名次第 4 到第 n 的运动员，只能获得他们的名次编号（即，名次第 x 的运动员获得编号 "x"）。
使用长度为 n 的数组 answer 返回获奖，其中 answer[i] 是第 i 位运动员的获奖情况。

示例 1：

```
输入：score = [5,4,3,2,1]
输出：["Gold Medal","Silver Medal","Bronze Medal","4","5"]
解释：名次为 [1st, 2nd, 3rd, 4th, 5th] 。
```

示例 2：

```
输入：score = [10,3,8,9,4]
输出：["Gold Medal","5","Bronze Medal","Silver Medal","4"]
解释：名次为 [1st, 5th, 3rd, 2nd, 4th] 。
```

提示：

- n == score.length
- 1 <= n <= 10^4^
- 0 <= score[i] <= 10^6^
- score 中的所有值 互不相同

### 代码

- HashMap+排序

```java
class Solution {
    public String[] findRelativeRanks(int[] score) {
        String[] rank = {"Gold Medal", "Silver Medal", "Bronze Medal"};
        int n = score.length;
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < n; i++) {
            map.put(score[i], i);
        }
        Arrays.sort(score);
        String[] res = new String[n];
        for(int i = n-1; i >= 0; i--) {
            if (i >= n-3) {
                res[map.get(score[i])] = rank[n-1-i];
            } else {
                res[map.get(score[i])] = n-1-i + 1 + "";
            }
        }
        return res;
    }
}
```

- 二维数组

```java
class Solution {
    public String[] findRelativeRanks(int[] score) {
        String[] rank = {"Gold Medal", "Silver Medal", "Bronze Medal"};
        int n = score.length;
        int[][] map = new int[n][2];
        for(int i = 0; i < n; i++) {
            map[i][0] = score[i];
            map[i][1] = i;
        }
        Arrays.sort(map, (a, b) -> b[0] - a[0]);
        String[] res = new String[n];
        for(int i = 0; i < n; i++) {
            if (i < 3) {
                res[map[i][1]] = rank[i];
            } else {
                res[map[i][1]] = i + 1 + "";
            }
        }
        return res;
    }
}
```

### 笔记

- 由于score 中的所有值 互不相同，所以可以使用HashMap记录原score数组中的值和对应的索引，然后对其进行排序，再遍历排序后的数组，可以利用HashMap快速找到每个值在原数组中的索引，然后对原数组中的相应的索引赋对应的值即可。
  Java对int类型的数组降序排列比较麻烦，这里就升序排列，然后倒着遍历。

- 用二维数组当HashMap，记录值和其索引。
  用二维数组，可以直接使用Arrays.sort()对二维数组进行降序排列
  
  ```java
  int[][] map = new int[n][2];
  Arrays.sort(map, (a, b) -> b[0] - a[0]); // 按第一维降序排列
  ```

## [507. 完美数](https://leetcode-cn.com/problems/perfect-number/)

难度：简单:star::star::star:

### 题目

对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。

给定一个 整数 n， 如果是完美数，返回 true；否则返回 false。

 

示例 1：

```
输入：num = 28
输出：true
解释：28 = 1 + 2 + 4 + 7 + 14
1, 2, 4, 7, 和 14 是 28 的所有正因子。
```

示例 2：

```
输入：num = 7
输出：false
```

提示：

- 1 <= num <= 10^8^

### 代码

- 模拟

```java
class Solution {
    public boolean checkPerfectNumber(int num) {
        int sum = 0;
        int i = 1;
        while(i < num) {
            if (num % i == 0) {
                sum += i;
            }
            i++;
        }
        return sum == num;

    }
}
```

- 模拟

```java
class Solution {
    public boolean checkPerfectNumber(int num) {
        int sum = 0;
        int i = 1;
        while(i <= num / i) {
            if (num % i == 0) {
                sum += i;
                // 因数是成对出现的，找到了小的，就可以把大的也加上
                // 要是i*i==num,i会被重复计算，所以要判断一下
                if (i * i != num) {
                    sum += (num / i);
                }
            }
            i++;
        }
        sum -= num;
        return sum == num;
    }
}
```

- 数学

```java
class Solution {
    public boolean checkPerfectNumber(int num) {
        return num == 6 || num == 28 || num == 496 || num == 8128 || num == 33550336;
    }
}
```

### 笔记

- 模拟：在枚举时，我们只需要枚举不超过$\sqrt{num}$的数。这是因为如果num 有一个大于 $\sqrt{num}$的因数 d，那么它一定有一个小于 $\sqrt{num}$的因数 $\frac{num}{d}$

  因数是成对出现的，找到了小的，就可以把大的也加上。要是i * i==num,i会被重复计算，所以要判断一下。

- 数学：据欧几里得-欧拉定理，每个偶完全数都可以写成
  $2^{p-1}\times \left( 2^{p}-1\right)$
  的形式，其中 p 为素数且 $2^{p}-1$为素数。

  由于目前奇完全数还未被发现，因此题目范围` [1,10^8]`内的完全数都可以写成上述形式。

  这一共有如下 5 个：
  6, 28, 496, 8128, 33550336

