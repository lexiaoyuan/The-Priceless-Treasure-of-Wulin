# 力扣刷题笔记（二）

[TOC]

## [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)

难度：简单:star::star::star:

### 题目

给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

说明:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

示例 1：

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

示例 2：

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```

提示：

- 0 <= nums.length <= 100
- 0 <= nums[i] <= 50
- 0 <= val <= 100

### 代码

- nums.remove(val)

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        while val in nums:
            nums.remove(val)
        return len(nums)
```

- 倒着遍历

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        n = len(nums)
        j = n - 1
        for i in range(n-1, -1, -1):
            if val == nums[i]:
                nums[i], nums[j] = nums[j], nums[i]
                j -= 1
        return j + 1
```

- 双指针

```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        left, right = 0, len(nums)
        while left < right:
            if nums[left] == val:
                nums[left] = nums[right-1]
                right -= 1
            else:
                left += 1
        return left
```

### 笔记

- 双指针：一个从左，一个从右，从左找到等于val的时候，左边的不动，等着，把右边的给它，然后右边的往左走。左边的那个个val不相等的时候，左边就往右走，找等于val的。
  左指针找等于val的，右指针盲目的把当前的值给左指针等于val的那个位置，每次都是判断左指针。

## [26. 删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/)

难度：简单:star::star::star:

### 题目

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

说明:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

示例 1：

```
输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

示例 2：

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

提示：

- 0 <= nums.length <= 3 * 10^4^
- -10^4^ <= nums[i] <= 10^4^
- nums 已按升序排列

### 代码

- 快慢指针

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        n = len(nums)
        left, right = 0, 1
        while right < n:
            if nums[left] == nums[right]:
                right += 1
            else:
                left += 1
                nums[left] = nums[right]
        return left + 1
```

- 快慢指针+二分

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        n = len(nums)
        left, right = 0, 0
        while right < n:
            if nums[left] == nums[right]:
                right = self.bisect_right(nums, left, nums[right])
            else:
                left += 1
                nums[left] = nums[right]
        return left if n==0 else left + 1

    def bisect_right(self, nums, start, k):
        lo, hi = start, len(nums)
        while lo < hi:
            mid = lo + (hi - lo) // 2
            if nums[mid] > k:
                hi = mid
            else:
                lo = mid + 1
        return lo
```

- 好的快慢指针

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        j = 1
        for i in range(1, len(nums)):
            if nums[i] != nums[j - 1]:
                nums[j] = nums[i]
                j += 1
        return j
```

### 笔记

- 好的快慢指针：i 去找和j不同的，找到和j不同的就把j替换掉。j指向最后被替换位置的下一个。

## [80. 删除有序数组中的重复项 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/)

难度：中等:star::star::star::star:

### 题目

给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。

说明：

为什么返回数值是整数，但输出的答案是数组呢？

请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

示例 1：

```
输入：nums = [1,1,1,2,2,3]
输出：5, nums = [1,1,2,2,3]
解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。
```

示例 2：

```
输入：nums = [0,0,1,1,1,1,2,3,3]
输出：7, nums = [0,0,1,1,2,3,3]
解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。
```

提示：

- 1 <= nums.length <= 3 * 10^4^
- -10^4^ <= nums[i] <= 10^4^
- nums 已按升序排列

### 代码

- 快慢指针

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        n = len(nums)
        if n <= 2:
            return n
        slow, fast = 2, 2
        while fast < n:
            if nums[fast] != nums[slow - 2]:
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        return slow
```

- 快慢指针

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        n = len(nums)
        slow = 2
        for fast in range(2, n):
            if nums[fast] != nums[slow - 2]:
                nums[slow] = nums[fast]
                slow += 1
        return n if n <= 2 else slow
```

### 笔记

- 关键的思路在于找不同，找到不同的时候，进行替换。

## [844. 比较含退格的字符串](https://leetcode-cn.com/problems/backspace-string-compare/)

难度：简单:star::star::star:

### 题目

 给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。

注意：如果对空文本输入退格字符，文本继续为空。

示例 1：

```
输入：S = "ab#c", T = "ad#c"
输出：true
解释：S 和 T 都会变成 “ac”。
```

示例 2：

```
输入：S = "ab##", T = "c#d#"
输出：true
解释：S 和 T 都会变成 “”。
```

示例 3：

```
输入：S = "a##c", T = "#a#c"
输出：true
解释：S 和 T 都会变成 “c”。
```

示例 4：

```
输入：S = "a#c", T = "b"
输出：false
解释：S 会变成 “c”，但 T 仍然是 “b”。
```

提示：

- 1 <= S.length <= 200
- 1 <= T.length <= 200
- S 和 T 只含有小写字母以及字符 '#'。

进阶：

- 你可以用 O(N) 的时间复杂度和 O(1) 的空间复杂度解决该问题吗？

### 代码

- 暴力解法

```python
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        return True if self.back(s) ==self.back(t) else False

    def back(self, x):
        m = len(x)
        x2 = [1] * m
        for i in range(m):
            if x[i] == '#':
                x2[i] = 0
                j = i - 1
                while j > -1:
                    if x2[j] == 1:
                        x2[j] = 0
                        break
                    j -= 1
        xx = ''
        for i in range(m):
            if x2[i] == 1:
                xx += x[i]
        return xx
```

- 用栈

```python
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        return self.back(s) == self.back(t)

    def back(self, x):
        stack = []
        for i in x:
            if i != '#':
                stack.append(i)
            else:
                if stack:
                    stack.pop()
        return stack
```

- 两个指针

```python
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        i = len(s) - 1
        j = len(t) - 1
        skipS, skipT = 0, 0
        while i >= 0 or j >= 0 :
            while i >= 0 :
                if s[i] == '#':
                    skipS += 1
                    i -= 1
                elif skipS > 0 :
                    skipS -= 1
                    i -= 1
                else:
                    break
            while j >= 0 :
                if t[j] == '#' :
                    skipT += 1
                    j -= 1
                elif skipT > 0 :
                    skipT -= 1
                    j -= 1
                else:
                    break
            if i < 0 and j < 0:
                return True
            if i < 0 and j >= 0:
                return False
            if j < 0 and i >= 0:
                return False
            if s[i] != t[j]:
                return False
            i -= 1
            j -= 1
        return True
```

- 简化判断

```python
class Solution:
    def backspaceCompare(self, s: str, t: str) -> bool:
        i = len(s) - 1
        j = len(t) - 1
        skipS, skipT = 0, 0
        while i >= 0 or j >= 0 :
            while i >= 0 :
                if s[i] == '#':
                    skipS += 1
                    i -= 1
                elif skipS > 0 :
                    skipS -= 1
                    i -= 1
                else:
                    break
            while j >= 0 :
                if t[j] == '#' :
                    skipT += 1
                    j -= 1
                elif skipT > 0 :
                    skipT -= 1
                    j -= 1
                else:
                    break
            if i >= 0 and j >= 0:
                if s[i] != t[j]:
                    return False
            elif i >= 0 or j >= 0:
                return False
            i -= 1
            j -= 1
        return True
```

### 笔记

- 用栈：要学会利用栈这种数据结构，对一些删除、修改、撤销等操作，可以考虑使用栈来解决。
- 两个指针：关键点就是反向遍历和使用skipS、skipT这个变量，是#就加一，不是#就减一。i和j分别指向从后往前依次未被删除的值，比较这两个保留下来的值，不一样就返回False，一样就继续往前找下一个倒数被保留下来的值。

## [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)

难度：中等:star::star::star::star:

### 题目

给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

示例 1：

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

示例 2：

```
输入：target = 4, nums = [1,4,4]
输出：1
```

示例 3：

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

提示：

- 1 <= target <= 10^9^
- 1 <= nums.length <= 10^5^
- 1 <= nums[i] <= 10^5^

进阶：

- 如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。

### 代码

- 滑动窗口

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        n = len(nums)
        left = 0
        count = float('inf')
        s = 0
        for right in range(n):
            s += nums[right]
            while s >= target :
                count = min(count, right - left + 1)
                s -= nums[left]
                left += 1

        return count if count != float('inf') else 0 
```

- 前缀和加二分

```python
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        import bisect
        n = len(nums)
        sums = [0]
        for i in nums:
            sums.append(sums[-1] + i)
        count = n + 1
        for i in range(1, n + 1):
            s = sums[i-1] + target
            bound = bisect.bisect_left(sums, s)
            if bound != (n + 1):
                count = min(count, bound - (i - 1))
        return count if count != (n + 1) else 0
```

### 笔记

- 滑动窗口：右边的一直走，左边的满足条件时进入while开始缩小。

## [907. 子数组的最小值之和](https://leetcode-cn.com/problems/sum-of-subarray-minimums/)

难度：中等:star::star::star::star:

### 题目

给定一个整数数组 arr，找到 min(b) 的总和，其中 b 的范围为 arr 的每个（连续）子数组。

由于答案可能很大，因此 返回答案模 10^9 + 7 。

示例 1：

```
输入：arr = [3,1,2,4]
输出：17
解释：
子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。 
最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。
```

示例 2：

```
输入：arr = [11,81,94,43,3]
输出：444
```

提示：

- 1 <= arr.length <= 3 * 10^4^
- 1 <= arr[i] <= 3 * 10^4^

### 代码

- 暴力法（超时）

```python
class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        n = len(arr)
        count = sum(arr)
        for i in range(0, n-1):
            minimum = arr[i]
            for j in range(i+1, n):
                if arr[j] < minimum:
                    minimum = arr[j]
                count += minimum        
        return count % (10**9 + 7)
```

- 单调栈

```python
class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        stack = []
        ans = dot = 0
        for y in arr:
            # 子数组中元素的个数
            count = 1
            while stack and stack[-1][0] >= y:
                x, c = stack.pop()
                count += c
                dot -= x*c
            stack.append((y, count))
            # print(stack)
            dot += y * count
            ans += dot
        return ans % (10**9 + 7)
```

- 双指针

```python
class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        l = len(arr)
        count = 0
        for i in range(l):
            j = i - 1
            m = n = 0
            while j >= 0 and arr[j] >= arr[i]:
                m += 1
                j -= 1
            k = i + 1
            while k < l and arr[k] > arr[i]:
                n += 1
                k += 1
            count += arr[i] * (m + 1) * (n + 1)
        return count % (10**9 + 7)
```

- 单调栈（二）

```python
class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        arr.append(0)
        stack = [-1]
        res = 0
        for i in range(len(arr)):
            while arr[i] < arr[stack[-1]]:
                # 进来的i是小于目前遍历到的最大的值的索引
                index = stack.pop()
                # index是目前遍历到的最大的值的索引（位于栈顶），pop之后，
                # stack[-1]是目前遍历到的位于arr[stack[-1]]的值的索引（位于栈顶）
                # 进来一个小于目前最大值的值的时候，说明以当前最大值作为最小值的子数组不能包含
                # 后面的元素了，因为后面的元素已经有一个比它小了。这个时候就可以开始计算以这个
                # 最大值作为最小值的子数组的个数了。个数=(该最大值的索引 - 在它前面比它小的那
                # 个值的索引) * (在它后面比它小的那个值的索引 - 该最大值的索引)。
                res += arr[index] * (index - stack[-1]) * (i - index)
            stack.append(i)
        return res % (10**9 + 7)
```

### 笔记

- 题目本质理解：这道题的本质在于找到数组中的每一个数作为最小值的范围，比如对于某个数nums[i]能够最小值以这种形式表示：左边连续m个数比nums[i]大，右边连续n个数比nums[i]大。
  
  作者：drinkwater999
  链接：https://leetcode-cn.com/problems/sum-of-subarray-minimums/solution/dan-diao-zhan-zuo-you-liang-bian-di-yi-g-ww3n/

- 暴力法（超时）：计算每个长度为1的子数组的最小值的和，再计算每个长度为2的子树组的最小值的和，...，再计算每个长度为n的子树组的最小值的和。最后把这些和加起来。

- 双指针（超时）：根据公式，对于每个元素a[i]，以该元素作为最小值的子数组的最小值之和=a[i] * 该元素作为最小值的子数组的个数=a[i] * (m + 1) * (n + 1)。其中，m是a[i]左边大于等于a[i]的个数，n是a[i]右边大于a[i]的个数。

- 单调栈法：对于每一个元素，如果该元素大于等于前一个元素，则将该元素入栈，维护一个从栈顶到栈底是递减的栈。因为我们要找每一个元素作为最小值的子数组个数，如果下一个元素比当前一个元素要小，那么下一个元素就不能是当前元素作为最小值的子数组中的元素。首先在数组末尾添加一个最小值（比如-1,0都可以，因为数组中的元素都是大于0的），在栈底添加一个-1，这样一开始可以取到数组末尾的最小值，第一个元素肯定大于最小值，那么可以将第一个元素添加到栈顶。然后遍历第二个元素，如果该元素大于等于栈顶的元素，则将该元素入栈，如果该元素小于栈顶元素，则计算以栈顶元素为最小值的子数组的个数，个数=(该最大值的索引 - 在它前面比它小的那个值的索引) * (在它后面比它小的那个值的索引 - 该最大值的索引)。
  **关键点**：**在栈底添加一个为-1的索引**，**在数组中也添加一个值为-1**。

## [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/)

难度：中等:star::star::star::star:

### 题目

请根据每日 气温 列表 temperatures ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。

示例 1:

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

示例 2:

```
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```

示例 3:

```
输入: temperatures = [30,60,90]
输出: [1,1,0]
```

提示：

- 1 <= temperatures.length <= 10^5^
- 30 <= temperatures[i] <= 100

### 代码

- 单调栈

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        n = len(temperatures)
        stack = []
        result = [0]*n
        for i in range(n):
            while stack and temperatures[i] > temperatures[stack[-1]]:
                index = stack.pop()
                result[index] = i - index
            stack.append(i)
        return result
```

### 笔记

- 单调栈：由于单调栈满足从栈底到栈顶元素对应的温度递减，因此每次有元素进栈时，会将温度更低的元素全部移除，并更新出栈元素对应的等待天数，这样可以确保等待天数一定是最小的。
  
  作者：LeetCode-Solution
  链接：https://leetcode-cn.com/problems/daily-temperatures/solution/mei-ri-wen-du-by-leetcode-solution/

- 单调栈：由于我们需要知道天数，天数其实就是两个温度对应的索引的差，所以我们在栈中存储温度对应的索引。首先将第一天的温度入栈（这里的入栈均是指将索引入栈，后面同），再看第二天的温度比第一天的温度高还是低，如果低的话，就可以将第二天的温度直接入栈（因为我们要找比第一天温度高的那一天，所以，温度比第一天低就可以直接入栈）；如果高的话，那就说明第一天再过一天就有一天温度比它高，所以，这时就可以将第一天出栈，并且计算第一天还有几天遇到比它温度高的，也即第二天的索引-第一天的索引=1。第一天处理完了之后，将第二天的温度入栈，再看第三天，如果第三天的温度比第二天低，则直接将第三天温度入栈，如果第三天温度更高，那么和上面的计算一样，第二天还有1天遇到更高的温度。第二天处理完了，再将第三天温度入栈。
  由于每次是遇到比前一天温度低的时候，才将这一天的温度直接入栈，所以我们维护的是一个从栈顶到栈底递增的栈。

## [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/)

难度：简单:star::star::star:

### 题目

给你两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。

请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。

nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。

示例 1:

```
输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
输出: [-1,3,-1]
解释:
    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。
    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。
    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。
```

示例 2:

```
输入: nums1 = [2,4], nums2 = [1,2,3,4].
输出: [3,-1]
解释:
    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。
    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。
```

提示：

- 1 <= nums1.length <= nums2.length <= 1000
- 0 <= nums1[i], nums2[i] <= 10^4^
- nums1和nums2中所有整数 互不相同
- nums1 中的所有整数同样出现在 nums2 中

**进阶：你可以设计一个时间复杂度为 O(nums1.length + nums2.length) 的解决方案吗？**

### 代码

- 单调栈+哈希表

```python
class Solution:
    def nextGreaterElement(self, nums1: List[int], nums2: List[int]) -> List[int]:
        stack = []
        res = {}
        for i in nums2:
            while stack and i > stack[-1]:
                t = stack.pop()
                res[t] =i
            stack.append(i)
            res[i] = -1
        ans = []
        for i in nums1:
            ans.append(res[i])
        return ans
```

### 笔记

- 看到没有重复元素就要想到用哈希表。
- 寻找下一个更大元素就是单调栈的典型应用场景。

## [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)

难度：中等:star::star::star::star:

### 题目

给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。

示例 1:

```
输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```

注意: 输入数组的长度不会超过 10000。

### 代码

- 单调栈+重复数组

```python
class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        n = len(nums)
        nums2 = nums + nums
        stack = []
        result = [-1] * 2 * n
        for i in range(2*n):
            while stack and nums2[i] > nums2[stack[-1]]:
                j = stack.pop()
                result[j] = nums2[i]
            stack.append(i)
        return result[:n]
```

- 单调栈+循环数组

```python
class Solution:
    def nextGreaterElements(self, nums: List[int]) -> List[int]:
        n = len(nums)
        stack = []
        result = [-1] * n
        for i in range(2*n):
            i = i % n
            while stack and nums[i] > nums[stack[-1]]:
                j = stack.pop()
                result[j] = nums[i]
            stack.append(i)
        return result
```

### 笔记

- 寻找下一个更大的元素就是单调栈的典型应用场景
- 对于循环数组，一个常用的思路就是将数组复制一份，再将两个数组拼到一起。
- 这个题可以不用重复数组，就按照循环数组的做法，对下标取余即可。

## [9. 回文数](https://leetcode-cn.com/problems/palindrome-number/)

难度：简单:star::star::star:

### 题目

给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

示例 1：

```
输入：x = 121
输出：true
```

示例 2：

```
输入：x = -121
输出：false

解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

示例 3：

```
输入：x = 10
输出：false
解释：从右向左读, 为 01 。因此它不是一个回文数。
```

示例 4：

```
输入：x = -101
输出：false
```

提示：

- -2^31^ <= x <= 2^31^ - 1

**进阶：你能不将整数转为字符串来解决这个问题吗？**

### 代码

- 转字符串

```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0:
            return False
        number = list(str(x))
        # while x > 0:
        #     low = x % 10
        #     number.append(low)
        #     x = x // 10
        n = len(number)
        for i in range(n):
            if number[i] != number[n-i-1]:
                return False
        return True
```

- 直接翻转字符串

```python
class Solution:
    def isPalindrome(self, x: int) -> bool:
        return True if str(x) == str(x)[::-1]  else False
```

- 直接翻转字符串

```java
class Solution {
    public boolean isPalindrome(int x) {
        if (x < 0) {
            return false;
        }
        StringBuilder y = new StringBuilder(String.valueOf(x));
        if (String.valueOf(x).equals(y.reverse().toString()))
            return true;
        else
            return false;
    }
}
```

- 直接翻转字符串（简写）

```java
class Solution {
    public boolean isPalindrome(int x) {
        StringBuilder y = new StringBuilder(x + "");
        if ((x + "").equals(y.reverse().toString()))
            return true;
        else
            return false;
    }
}
```

- 数学方法

```java
class Solution {
    public boolean isPalindrome(int x) {
        if (x < 0)
            return false;
        int div = 1;
        int y = x;
        while (y >= 10) {
            y = y / 10;
            div *= 10;
        }
        while (x > 0) {
            int low = x % 10;
            int high = x / div;
            // System.out.println(x);
            if (low != high) 
                return false;
            x = (x % div) / 10;
            div /= 100;
        }
        return true;
    }
}
```

- 进阶（翻转后一半的数字）

```java
class Solution {
    public boolean isPalindrome(int x) {
        if (x < 0 || (x % 10==0 && x != 0))
            return false;
        int y = 0;
        while (x > y) {
            y = y * 10 + (x % 10);
            x /= 10;
        }
        if (x == y || x == y / 10)
            return true;
        else
            return false;
    }
}
```

### 笔记

- 去除一个数的最高位和最低位的方法：`x = (x % div) / 10;`。其中div是最高位的位数。比如，x=1221,则div=1000。

## [13. 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)

难度：简单:star::star::star:

### 题目

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

```
字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
```

例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

- I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
- X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
- C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。

示例 1:

```
输入: s = "III"
输出: 3
```

示例 2:

```
输入: s = "IV"
输出: 4
```

示例 3:

```
输入: s = "IX"
输出: 9
```

示例 4:

```
输入: s = "LVIII"
输出: 58
解释: L = 50, V= 5, III = 3.
```

示例 5:

```
输入: s = "MCMXCIV"
输出: 1994
解释: M = 1000, CM = 900, XC = 90, IV = 4.
```

提示：

- 1 <= s.length <= 15
- s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M')
- 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内
- 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。
- IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。
- 关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。

### 代码

- 暴力判断

```java
class Solution {
    public int romanToInt(String s) {
        HashMap<Character, Integer> dict = new HashMap<>();
        dict.put('I', 1);
        dict.put('V', 5);
        dict.put('X', 10);
        dict.put('L', 50);
        dict.put('C', 100);
        dict.put('D', 500);
        dict.put('M', 1000);
        int result = 0;
        for (int i = 0; i < s.length(); i++) {
            int roman = dict.get(s.charAt(i));
            int next_roman = 0;
            if (i+1 < s.length())
                next_roman = dict.get(s.charAt(i+1));
            if ((roman == 1 && (next_roman == 5 || next_roman == 10)) || (roman == 10 && (next_roman == 50 || next_roman == 100) || (roman == 100 && (next_roman == 500 || next_roman == 1000)))) {
                result += (next_roman - roman);
                i++;
            } else {
                result += roman;
            }
        }
        return result;

    }
}
```

- 直接判断

```java
class Solution {
    public int romanToInt(String s) {
        HashMap<Character, Integer> dict = new HashMap<>();
        dict.put('I', 1);
        dict.put('V', 5);
        dict.put('X', 10);
        dict.put('L', 50);
        dict.put('C', 100);
        dict.put('D', 500);
        dict.put('M', 1000);
        int result = 0;
        for (int i = 0; i < s.length(); i++) {
            int roman = dict.get(s.charAt(i));
            int next_roman = 0;
            if (i+1 < s.length())
                next_roman = dict.get(s.charAt(i+1));
            if (roman < next_roman) {
                result += (next_roman - roman);
                i++;
            } else {
                result += roman;
            }
        }
        return result;

    }
}
```

### 笔记

## [14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)

难度：简单:star::star::star:

### 题目

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

示例 1：

```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

示例 2：

```
输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
```

提示：

- 1 <= strs.length <= 200
- 0 <= strs[i].length <= 200
- strs[i] 仅由小写英文字母组成

### 代码

- 暴力解法

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        int shortest = 201;
        int j = 0;
        for (int i = 0; i < strs.length; i++) {
            if (strs[i].length() < shortest) {
                shortest = strs[i].length();
                j = i;
            }
        }
        for (int i = 0; i < shortest; i++) {
            char prefix = 'A';
            for (String s : strs) {
                if (prefix == 'A') {
                    prefix = s.charAt(i);
                }
                else if (prefix != s.charAt(i)){
                    return s.substring(0, i);
                }
            }
        }
        return strs[j];
    }
}
```

- 横向比较

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        String prefix = strs[0];
        for (int i=1; i < strs.length; i++) {
            prefix = lcp(prefix, strs[i]);
        }
        return prefix;
    }
    public String lcp(String str1, String str2) {
        int shortest = Math.min(str1.length(), str2.length());
        for (int i = 0; i < shortest; i++) {
            if (str1.charAt(i) != str2.charAt(i)) {
                return str1.substring(0, i);
            }
        }
        return str1.substring(0, shortest);
    }
}
```

- 纵向比较

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        String prefix = strs[0];
        for (int i=0; i < prefix.length(); i++) {
            char c = prefix.charAt(i);
            for (int j=1; j < strs.length; j++) {
                if (i >= strs[j].length() || c != strs[j].charAt(i)) {
                    return prefix.substring(0, i);
                }
            }
        }
        return prefix;
    }

}
```

### 笔记

- 暴力解法：找到长度最短的元素，按该长度来循环，比较每一个字符串的每一个元素
- 横向比较：得到第一个和第二个的前缀，和第三个比较得到新的前缀，再用新的前缀和第四个比较。。。最终得到的就是所有字符串的公共前缀。
- 纵向比较：以第一个字符串为基准，比较第一个字符串的第一个字符和其它所有字符串的第一个字符，再比较第一个字符串的第二个字符和其它所有字符串的第二个字符，再比较第一个字符串的第三个字符和其它所有字符串的第三个字符。。。。

## [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

难度：简单:star::star::star:

### 题目

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

示例 1：

```
输入：s = "()"
输出：true
```

示例 2：

```
输入：s = "()[]{}"
输出：true
```

示例 3：

```
输入：s = "(]"
输出：false
```

示例 4：

```
输入：s = "([)]"
输出：false
```

示例 5：

```
输入：s = "{[]}"
输出：true
```

提示：

- 1 <= s.length <= 10^4^
- s 仅由括号 '()[]{}' 组成

### 代码

- 栈的应用

```java
class Solution {
    public boolean isValid(String s) {
        if (s.length()%2==1)
            return false;
        HashMap<Character, Character> pairs = new HashMap<>() {{
            put('(', ')');
            put('[', ']');
            put('{', '}');
        }};
        Deque<Character> stack = new LinkedList<>();
        for (int i=0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (pairs.containsKey(c)) {
                stack.push(c);
            }
            if (pairs.containsValue(c)) {
                if (stack.isEmpty() || pairs.get(stack.peek())!=c) {
                    return false;
                } else {
                    stack.pop();
                }
            }
        }
        return stack.isEmpty();
    }
}
```

### 笔记

- 这是一个利用栈的典型应用

## [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

难度：简单:star::star::star:

### 题目

实现 [strStr()]([strstr（PHP语言函数）_百度百科 (baidu.com)](https://baike.baidu.com/item/strstr/811469)) 函数。

给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。

说明：

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 [strstr()](https://baike.baidu.com/item/strstr/811469) 以及 Java 的 [indexOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)) 定义相符。

示例 1：

```
输入：haystack = "hello", needle = "ll"
输出：2
```

示例 2：

```
输入：haystack = "aaaaa", needle = "bba"
输出：-1
```

示例 3：

```
输入：haystack = "", needle = ""
输出：0
```

提示：

- 0 <= haystack.length, needle.length <= 5 * 10^4^
- haystack 和 needle 仅由小写英文字符组成

### 代码

- 暴力法

```java
class Solution {
    public int strStr(String haystack, String needle) {
        int m = haystack.length();
        int n = needle.length();
        if (n > m || (m==n && !haystack.equals(needle))) {
            return -1;
        }
        if (n==0) {
            return 0;
        }
        int start = -1;
        for (int i=0; i < m; i++)  {
            if (haystack.charAt(i) == needle.charAt(0)) {
                start = i;
                break;
            }
        }
        if (start >= 0) {
            for (int j=start; j < m && j-start < n; j++) {
                if (haystack.charAt(j) != needle.charAt(j-start)) {
                    for (int i=start+1; i < m; i++)  {
                        if (haystack.charAt(i) == needle.charAt(0)) {
                            start = i;
                            j=i;
                            break;
                        }
                    }
                }
                if (m-start < n || (m-start==n && !haystack.substring(start, m).equals(needle))) {
                    return -1;
                }
            }
            return start;
        }
        return -1;
    }
}
```

- indexOf源码

```java
class Solution {
    public int strStr(String haystack, String needle) {
        int m = haystack.length();
        int n = needle.length();
        if (m == 0) {
            return n == 0 ? n : -1;
        }
        if (n == 0) {
            return 0;
        }

        char first = needle.charAt(0);
        int max = m - n;

        for (int i = 0; i <= max; i++) {
            // 找第一个相等的字符
            if(haystack.charAt(i) != first) {
                while (++i <= max && haystack.charAt(i) != first);
            }
            // 匹配后面的字符
            if (i <= max) {
                int j = i + 1;
                int end = j + n - 1;
                for (int k = 1; j < end && haystack.charAt(j) == needle.charAt(k); j++, k++);
                if (j == end) {
                    return i;
                }
            }
        }
        return -1;
    }
}
```

- KMP算法

- [ ] TODO

### 笔记

- indexOf()源码的一个小技巧：for循环的时候，尝试计算一个固定的最小范围，在这个最小的范围内循环。

## [53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)

难度：简单:star::star::star:

### 题目

给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

子数组 是数组中的一个连续部分。

示例 1：

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

示例 2：

```
输入：nums = [1]
输出：1
```

示例 3：

```
输入：nums = [5,4,-1,7,8]
输出：23
```

提示：

- 1 <= nums.length <= 10^5^
- -10^4^ <= nums[i] <= 10^4^

进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 **分治法** 求解。

### 代码

- ~~暴力法~~（超时）

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int max = (int) Collections.max(Arrays.asList(Arrays.stream(nums).boxed().toArray(Integer[]::new)));
        int n = nums.length;
        for (int i = 0; i < n-1; i++) {
            int count = nums[i];
            for (int j = i+1; j < n; j++) {
                count += nums[j];
                max = Math.max(max, count);
            }
            if (nums[i] > 0) {
                i++;
            }
        }
        return max;
    }
}
```

- 动态规划

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0;
        int maxValue = nums[0];
        for(int x : nums) {
            pre = Math.max(pre + x, x);
            maxValue = Math.max(maxValue, pre);
        }
        return maxValue;
    }
}
```

### 笔记

- 求最值、最优解的问题，可以尝试动态规划
- 动态规划：设f(i)表示数组nums从0到i的最大子数组和，则有$f(i) = max(f(i-1), f(i-1)+nums[i], nums[i])$

## [58. 最后一个单词的长度](https://leetcode-cn.com/problems/length-of-last-word/)

难度：简单:star::star::star:

### 题目

给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。

单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。

示例 1：

```
输入：s = "Hello World"
输出：5
```

示例 2：

```
输入：s = "   fly me   to   the moon  "
输出：4
```

示例 3：

```
输入：s = "luffy is still joyboy"
输出：6
```

提示：

- 1 <= s.length <= 10^4^
- s 仅有英文字母和空格 ' ' 组成
- s 中至少存在一个单词

### 代码

- split

```java
class Solution {
    public int lengthOfLastWord(String s) {
        String [] wordList = s.split(" ");
        for (int i = wordList.length - 1; i >= 0; i--) {
            if (wordList[i].length()>=1) {
                return wordList[i].length();
            }
        }
        return s.length();
    }
}
```

- 反向遍历

```java
class Solution {
    public int lengthOfLastWord(String s) {
        int count = 0;
        for (int i = s.length()-1; i >= 0; i--) {
            int pre=count;
            if (s.charAt(i) != ' ') {
                count++;
            }
            if (count > 0 && count == pre) {
                return count;
            }
        }
        return count;
    }
}
```

### 笔记

## [66. 加一](https://leetcode-cn.com/problems/plus-one/submissions/)

难度：简单:star::star::star:

### 题目

给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

示例 1：

```
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。
```

示例 2：

```
输入：digits = [4,3,2,1]
输出：[4,3,2,2]
解释：输入数组表示数字 4321。
```

示例 3：

```
输入：digits = [0]
输出：[1]
```

提示：

- 1 <= digits.length <= 100
- 0 <= digits[i] <= 9

### 代码

- 按进位加

```java
class Solution {
    public int[] plusOne(int[] digits) {
        int last = digits.length - 1;
        if (digits[last] < 9) {
            digits[last] += 1;
            return digits;
        }
        int carry = 1;
        int compute = 0;
        for (int i = last; i >= 0; i--) {
            compute = digits[i] + carry;
            carry = 0;
            if (compute > 9) {
                digits[i] = compute % 10;
                carry = 1;
            } else {
                digits[i] = compute;
            }
        }
        if (carry == 1) {
            int[] dst = new int[digits.length + 1];
            dst[0] = 1;
            return dst;
        }
        return digits;
    }
}
```

- 找第一个小于9的

```java
class Solution {
    public int[] plusOne(int[] digits) {
        for (int i = digits.length - 1; i >= 0; i--) {
            if (digits[i] < 9) {
                digits[i] += 1;
                return digits;
            } else {
                digits[i] = 0;
            }
        }
        if (digits[0] == 0) {
            int[] dst = new int[digits.length + 1];
            dst[0] = 1;
            return dst;
        }
        return digits;
    }
}
```

### 笔记

- 找第一个小于9的：从后往前找，如果找到第一个小于9的，把它加1，然后把这个数后面所有是9的变成0。如果全是9，那么第一个数也会变成0，那就new一个比原数组长度大1的数组，将第一个数定为1，后面的全是0.

## [67. 二进制求和](https://leetcode-cn.com/problems/add-binary/)

难度：简单:star::star::star:

### 题目

给你两个二进制字符串，返回它们的和（用二进制表示）。

输入为 非空 字符串且只包含数字 1 和 0。

示例 1:

```
输入: a = "11", b = "1"
输出: "100"
```

示例 2:

```
输入: a = "1010", b = "1011"
输出: "10101"
```

提示：

- 每个字符串仅由字符 '0' 或 '1' 组成。
- 1 <= a.length, b.length <= 10^4^
- 字符串如果不是 "0" ，就都不含前导零。

### 代码

- 竖式加法

```java
class Solution {
    public String addBinary(String a, String b) {
        StringBuilder res = new StringBuilder();
        int i = a.length() - 1;
        int j = b.length() - 1;
        int carry = 0;
        while (i >= 0 || j >= 0) {
            int m = i >= 0 ? a.charAt(i) - '0' : 0;
            int n = j >= 0 ? b.charAt(j) - '0' : 0;
            int s = m + n + carry;
            res.append(s % 2);
            carry = s / 2;
            i--;
            j--; 
        }
        if (carry > 0) {
            res.append(carry);
        }
        return res.reverse().toString();
    }
}
```

### 笔记

- 竖式加法：模拟加法运算，逢2进1。
- java中char类型的字符相减是字符对应的ASCII码相减。'1'的ASCII码是49， '0'的ASCII码是48，'1' - '0' = 49-48=1。
- java中的StringBuilder可以直接append int、char、String等类型。

## [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

难度：简单:star::star::star:

### 题目

给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。

示例 1：

![img1](noteImage/list1.jpg)

```
输入：head = [1,1,2]
输出：[1,2]
```

示例 2：

![img2](noteImage/list2.jpg)

```
输入：head = [1,1,2,3,3]
输出：[1,2,3]
```

提示：

- 链表中节点数目在范围 [0, 300] 内
- -100 <= Node.val <= 100
- 题目数据保证链表已经按升序 排列

### 代码

- 快慢指针

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) {
            return head;
        }
        ListNode fast = head.next;
        ListNode slow = head;
        while (fast != null) {
            if (fast.val != slow.val) {
                slow.next = fast;
                slow = fast;
            }
            fast = fast.next;
        }
        slow.next = fast;
        return head;
    }
}
```

- 一次遍历

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) {
            return head;
        }
        ListNode cur = head;
        while (cur.next != null) {
            if (cur.val == cur.next.val) {
                cur.next = cur.next.next;
            } else {
                cur = cur.next;
            }
        }
        return head;

    }
}
```

### 笔记

## [88. 合并两个有序数组](https://leetcode-cn.com/problems/merge-sorted-array/)

难度：简单:star::star::star:

### 题目

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

示例 1：

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

示例 2：

```
输入：nums1 = [1], m = 1, nums2 = [], n = 0
输出：[1]
解释：需要合并 [1] 和 [] 。
合并结果是 [1] 。
```

示例 3：

```
输入：nums1 = [0], m = 0, nums2 = [1], n = 1
输出：[1]
解释：需要合并的数组是 [] 和 [1] 。
合并结果是 [1] 。
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。
```

提示：

- nums1.length == m + n
- nums2.length == n
- 0 <= m, n <= 200
- 1 <= m + n <= 200
- -10^9^ <= nums1[i], nums2[j] <= 10^9^

进阶：你可以设计实现一个时间复杂度为 O(m + n) 的算法解决此问题吗？

### 代码

- 合并后排序

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        for (int i = 0; i < n; i++) {
            nums1[m+i] = nums2[i];
        }
        Arrays.sort(nums1);
    }
}
```

- 正向双指针

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int[] sorted = new int[m+n];
        int i = 0;
        int j = 0;
        int k = 0;
        while (k < m+n) {
            if (i < m && j < n) {
                if (nums1[i] <= nums2[j]) {
                    sorted[k] = nums1[i];
                    i++;
                } else {
                    sorted[k] = nums2[j];
                    j++;
                }
            }
            else if (i < m) {
                sorted[k] = nums1[i];
                i++;
            } else if (j < n) {
                sorted[k] = nums2[j];
                j++;
            }
            k++;
        }
        for (i = 0; i < m+n; i++) {
            nums1[i] = sorted[i];
        }
    }
}
```

- 逆向双指针

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int k = m + n -1;
        int i = k - n;
        int j = k - m;
        while (k >= 0) {
            if (i >= 0 && j >= 0) {
                if (nums1[i] > nums2[j]) {
                    nums1[k] = nums1[i];
                    i--;
                } else {
                    nums1[k] = nums2[j];
                    j--;
                }
            }
            else if (i >= 0) {
                nums1[k] = nums1[i];
                i--;
            } else if (j >= 0) {
                nums1[k] = nums2[j];
                j--;
            }
            k--;
        }
    }
}
```

### 笔记

- 看见两个序列，就要想到使用双指针。
- 逆向双指针：从后面开始确定，谁大谁去后面。

## [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

难度：简单:star::star::star:

### 题目

给定一个二叉树的根节点 root ，返回它的 中序 遍历。

示例 1：

![img](noteImage/inorder_1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

示例 2：

```
输入：root = []
输出：[]
```

示例 3：

```
输入：root = [1]
输出：[1]
```

示例 4：

![img](noteImage/inorder_5.jpg)

```
输入：root = [1,2]
输出：[2,1]
```

示例 5：

![img](noteImage/inorder_4.jpg)

```
输入：root = [1,null,2]
输出：[1,2]
```

提示：

- 树中节点数目在范围 [0, 100] 内
- -100 <= Node.val <= 100

进阶: 递归算法很简单，你可以通过迭代算法完成吗？

### 代码

- 递归算法

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<Integer> result = new LinkedList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        if (root != null) {
            inorderTraversal(root.left);
            result.add(root.val);
            inorderTraversal(root.right);
        }
        return result;
    }
}
```

- 递归算法

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        inorder(root, result);
        return result;
    }
    public void inorder(TreeNode root, List<Integer> result) {
        if (root != null) {
            inorder(root.left, result);
            result.add(root.val);
            inorder(root.right, result);
        }
    }
}
```

- 非递归算法

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new LinkedList<>();
        if (root != null) {
            Deque<TreeNode> stack = new LinkedList<>();
            TreeNode p = new TreeNode();
            p = root;
            while ( p != null || !stack.isEmpty()) {
                while (p != null) {
                    stack.push(p);
                    p = p.left;
                }
                if (!stack.isEmpty()) {
                    p = stack.pop();
                    result.add(p.val);
                    p = p.right;
                }
            }
        }
        return result;
    } 
}
```

### 笔记

- Java定义栈及常用操作：
  
  ```java
  Deque<E> stack = new LinkedList<>();
  // stack.empty(); // 为空返回true，不为空返回false。
  // stack.isEmpty(); // 为空返回true，不为空返回false(与stack.empty()无结果上的区别)。
  // stack.peek(); // 为空返回null，不为空返回栈顶元素。
  // stack.size(); // 为空返回0，不为空返回一个大于1的整数。
  // stack.push(E); // 在栈的顶部添加元素
  // stack.pop(); 返回栈的顶部元素，并将其从栈顶删除
  ```

- 二叉树的中序遍历递归算法：（在当前节点不为空的情况下进行）
  
  1. 中序遍历左子树
  2. 访问（当前）根节点
  3. 中序遍历右子树

- 二叉树的中序遍历非递归算法：**借助栈来实现**。（在当前节点不为空的情况下进行）
  算法思想：
  
  1. 先将根入栈，再到左孩子。
  2. 把左孩子当作当前的根入栈，再到当前根的左孩子（有的话）。
  3. 一直到没有左孩子，然后将栈顶出栈，并访问。
  4. 再访问其右孩子，当作当前根，回到1，重复。

## [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

难度：简单:star::star::star:

### 题目

给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1：

![img](noteImage/ex1.jpg)

```
输入：p = [1,2,3], q = [1,2,3]
输出：true
```

示例 2：

![img](noteImage/ex2.jpg)

```
输入：p = [1,2], q = [1,null,2]
输出：false
```

示例 3：

![img](noteImage/ex3.jpg)

```
输入：p = [1,2,1], q = [1,1,2]
输出：false
```

提示：

- 两棵树上的节点数目都在范围 [0, 100] 内
- -10^4^ <= Node.val <= 10^4^

### 代码

- 递归-深度优先搜索

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        } 
        else if (p == null || q == null) {
            return false;
        }
        else if (p.val != q.val) {
            return false;
        }
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
```

- 栈-深度优先搜索

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    public boolean isSameTree(TreeNode p, TreeNode q) {
        TreeNode node_p = new TreeNode();
        TreeNode node_q = new TreeNode();
        Deque<TreeNode> stack_p = new LinkedList<>();
        Deque<TreeNode> stack_q = new LinkedList<>();
        stack_p.push(p);
        stack_q.push(q);
        while (!stack_p.isEmpty() && !stack_q.isEmpty()) {
            node_p = stack_p.pop();
            node_q = stack_q.pop();
            if (node_p == null && node_q == null) {
                continue;
            }
            else if ((node_p == null || node_q == null) || node_p.val != node_q.val) {
                return false;
            }
            stack_p.push(node_p.right);
            stack_q.push(node_q.right);
            stack_p.push(node_p.left);
            stack_q.push(node_q.left);
        }
        return stack_p.isEmpty() && stack_q.isEmpty();
    }
}
```

- 队列-广度优先搜索

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {

    public boolean isSameTree(TreeNode p, TreeNode q) {
        TreeNode node_p = new TreeNode();
        TreeNode node_q = new TreeNode();
        Queue<TreeNode> queue_p = new LinkedList<>();
        Queue<TreeNode> queue_q = new LinkedList<>();
        queue_p.offer(p);
        queue_q.offer(q);
        while (!queue_p.isEmpty() && !queue_q.isEmpty()) {
            node_p = queue_p.poll();
            node_q = queue_q.poll();
            if (node_p == null && node_q == null) {
                continue;
            }
            else if ((node_p == null || node_q == null) || node_p.val != node_q.val) {
                return false;
            }
            queue_p.offer(node_p.left);
            queue_p.offer(node_p.right);
            queue_q.offer(node_q.left);
            queue_q.offer(node_q.right);
        }
        return queue_p.isEmpty() && queue_q.isEmpty();
    }
}
```

### 笔记

- java定义队列及常用操作：
  
  ```java
  Queue<E> queue = new LinkedList<>();
  // queue.offer(E); // 在队列尾部插入元素
  // queue.poll(); // 返回队列首部元素，并在队列中删除
  // queue.peek(); // 返回队列首部元素
  // queue.isEmpty(); // 判断队列是否为空
  ```

## [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

难度：简单:star::star::star:

### 题目

给你一个二叉树的根节点 root ， 检查它是否轴对称。

示例 1：

![img](noteImage/symtree1.jpg)

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

示例 2：

![img](noteImage/symtree2.jpg)

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

提示：

- 树中节点数目在范围 [1, 1000] 内
- -100 <= Node.val <= 100

**进阶：**你可以运用递归和迭代两种方法解决这个问题吗？

### 代码

- 双指针递归

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return preOrder(root, root) > 0 ? false : true;
    }
    int res = 0;
    public int preOrder(TreeNode root1, TreeNode root2) {
        if (res > 0 || (root1 == null && root2 == null)) {
            return res;
        } 
        else if (root1 == null || root2 == null) {
            res++;
            return res;
        } else {
            if (root1.val != root2.val) {
                res++;
            }
            res += preOrder(root1.left, root2.right);
            res += preOrder(root1.right, root2.left);
        }
        //System.out.println(res);
        return res;
    }
}
```

- 优雅的递归

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root, root);
    }
    public boolean check(TreeNode root1, TreeNode root2) {
        if (root1 == null && root2 == null) {
            return true;
        } 
        if (root1 == null || root2 == null) {
            return false;
        }
        return root1.val == root2.val && check(root1.left, root2.right) && check(root1.right, root2.left);
    }
}
```

- 队列，迭代

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root, root);
    }
    public boolean check(TreeNode root1, TreeNode root2) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root1);
        queue.offer(root2);
        while (!queue.isEmpty()) {
            TreeNode p = queue.poll();
            TreeNode q = queue.poll();
            if (p == null && q == null) {
                continue;
            }
            if (p == null || q == null) {
                return false;
            }
            if (p.val != q.val) {
                return false;
            }
            queue.offer(p.left);
            queue.offer(q.right);
            queue.offer(p.right);
            queue.offer(q.left);
        }
        return true;
    }
}
```

### 笔记

- 迭代法：用一个队列就可以了，每次从队列中取出两个元素，来判断两个节点是否相同。

## [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

难度：简单:star::star::star:

### 题目

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例：
给定二叉树 [3,9,20,null,null,15,7]，

        3
       / \
      9  20
        /  \
       15   7

返回它的最大深度 3 。

### 代码

- 递归-深度优先搜索

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if (root != null) {
            int leftHeight = maxDepth(root.left);
            int rightHeight = maxDepth(root.right);
            return Math.max(leftHeight, rightHeight) + 1;
        }
        return 0;

    }
}
```

- 迭代-广度优先遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        TreeNode p = new TreeNode();
        int depth = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            while (size > 0) {
                p = queue.poll();
                size--;
                if (p.left != null) {
                    queue.offer(p.left);
                }
                if (p.right != null) {
                    queue.offer(p.right);
                }
            }
            depth++;
        }
        return depth;
    }
}
```

### 笔记

- 深度优先搜索：最大深度=max(左子树最大深度,右子树最大深度)+1
- 广度优先搜索：利用队列。入队时，要把每一层的元素全部入队，出队时，要把每一层的元素全部出队。在把当前层全部出队前，可以通过`int size = queue.size()`获取到当前层的元素个数。然后每出队一个元素，就把size减一，size减到了0就表示当前层都出队了（这时队列里是下一层的全部元素）。一层都出队完了，深度就加一。

## [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

难度：简单:star::star::star:

### 题目

给你一个整数数组 nums ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

示例 1：

![img](noteImage/btree1.jpg)

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
```

![img](noteImage/btree2.jpg)

示例 2：

![img](noteImage/btree.jpg)

```
输入：nums = [1,3]
输出：[3,1]
解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。
```

提示：

- 1 <= nums.length <= 10^4^
- -10^4^ <= nums[i] <= 10^4^
- nums 按 **严格递增** 顺序排列

### 代码

- 递归-选择中点靠左的点

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return helper(nums, 0, nums.length-1);
    }
    public TreeNode helper(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }
        // 选择中间靠左边的值作为根节点
        int m = left + (right - left) / 2;
        TreeNode root = new TreeNode(nums[m]);
        root.left = helper(nums, left, m-1);
        root.right = helper(nums, m+1, right);
        return root;
    }
}
```

- 递归-选择中点靠右的点

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return helper(nums, 0, nums.length-1);
    }
    public TreeNode helper(int[] nums, int left, int right) {
        if (left > right) {
            return null;
        }
        // 选择中间靠右边的值作为根节点
        int m = left + (right - left + 1) / 2;
        TreeNode root = new TreeNode(nums[m]);
        root.left = helper(nums, left, m-1);
        root.right = helper(nums, m+1, right);
        return root;
    }
}
```

### 笔记

- 计算中点的写法：`int m = left +  (right - left)/2;`等价于`int m = (left + right)/2`。为了避免后后者中的left+right的结果可能出现超出int范围导致的越界，通常采用前者。这种写法是取中点靠左的点。
  `int m = left + (right - left + 1)/2`等价于`int m = (left + right + 1)/2`取中点靠右的点。

- 直观地看，我们可以选择中间数字作为二叉搜索树的根节点，这样分给左右子树的数字个数相同或只相差 11，可以使得树保持平衡。**如果数组长度是奇数，则根节点的选择是唯一的，如果数组长度是偶数，则可以选择中间位置左边的数字作为根节点或者选择中间位置右边的数字作为根节点，选择不同的数字作为根节点则创建的平衡二叉搜索树也是不同的。**
  确定平衡二叉搜索树的根节点之后，其余的数字分别位于平衡二叉搜索树的左子树和右子树中，左子树和右子树分别也是平衡二叉搜索树，因此可以通过递归的方式创建平衡二叉搜索树。
  
  当然，这只是我们直观的想法，为什么这么建树一定能保证是「平衡」的呢？这里可以参考[「1382. 将二叉搜索树变平衡」](https://leetcode-cn.com/problems/balance-a-binary-search-tree/)，这两道题的构造方法完全相同，这种方法是正确的，1382题解中给出了这个方法的正确性证明：[1382 官方题解]((https://leetcode-cn.com/problems/balance-a-binary-search-tree/solution/jiang-er-cha-sou-suo-shu-bian-ping-heng-by-leetcod/) )

- 要构建一个二叉搜索树的话，就需要满足二叉搜索树的性质（简单来说是“左小右大”）。由于数组是严格递增（升序）的，那么从中间选择分割点，分割点作为根节点，左区间构造左子树，右区间构造右子树，刚好可以满足二叉搜索树的性质。

- 从数组构建二叉树，一个常用的思路就是从数组中间开始构建，然后分两个区间，对两个区间作为子数组来构建，是一个递归构建的过程。

- 二叉搜索树中一般认为没有相等的值，对BST中序遍历可得到一个递增的序列。

- 题目要求是高度平衡的二叉搜索树，即：既是平衡二叉树（AVL树）又是二叉搜索树（BST）。
  
  1. 二叉平衡树（AVL树）：（递归定义）
     
     - 空树是二叉平衡树
     
     - 若非空，则：它的左右子树均是AVL树；左右子树的高（深）度差的绝对值不超过1。（只能为-1,0,1）。
  
  2. 二叉搜索树（BST）：（递归定义）
     
     - 空树是二叉搜索树
     
     - 若非空，则：其左子树的所有节点的值均小于它的根节点的值；其右子树的所有节点的值均大于它的根节点的值；它的左右子树也分别为二叉搜索树。

## [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

难度：简单:star::star::star:

### 题目

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

**一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。**

示例 1：

![img](noteImage/balance_1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：true
```

示例 2：

![img](noteImage/balance_2.jpg)

```
输入：root = [1,2,2,3,3,null,null,4,4]
输出：false
```

示例 3：

```
输入：root = []
输出：true
```

提示：

- 树中的节点数在范围 [0, 5000] 内
- -10^4^ <= Node.val <= 10^4^

### 代码

- 自顶向下递归

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root == null) {
            return true;
        }
        return Math.abs(height(root.left) - height(root.right)) <= 1 && isBalanced(root.left) && isBalanced(root.right);
    }
    public int height(TreeNode root) {
        if (root != null) {
            int leftHeight = height(root.left);
            int rightHeight = height(root.right);
            return Math.max(leftHeight, rightHeight) + 1;
        }
        return 0;
    }
}
```

- 自底向上递归

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        return height(root) >= 0;
    }
    public int height(TreeNode root) {
        if (root == null) {
            return 0;
        }
        int leftHeight = height(root.left);
        if (leftHeight == -1) {
            return -1;
        }
        int rightHeight = height(root.right);
        if (rightHeight == -1) {
            return -1;
        }
        if (Math.abs(leftHeight - rightHeight) > 1) {
            return -1;
        }
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
```

### 笔记

- 自顶向下的递归采用了两个递归，一个递归计算一个节点的高度，另一个递归来调用这个递归来判断是否为高度平衡的二叉树

- 节点的深度：从根节点开始自顶向下逐层累加，根的深度为1。
  节点的高度：从叶子节点开始自底向上逐层累加，叶子节点高度为1。

- 自底向上递归：如果当前传入节点为根节点的二叉树已经不是二叉平衡树了，还返回高度的话就没有意义了。所以如果已经不是二叉平衡树了，可以返回-1 来标记已经不符合平衡树的规则了。
  如何判断当前传入节点为根节点的二叉树是否是平衡二叉树呢，当然是左子树高度和右子树高度相差。
  
  分别求出左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则则返回-1，表示已经不是平衡二叉树了。

## [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

难度：简单:star::star::star:

### 题目

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明：叶子节点是指没有子节点的节点。

示例 1：

![img](noteImage/ex_depth.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：2
```

示例 2：

```
输入：root = [2,null,3,null,4,null,5,null,6]
输出：5
```

提示：

- 树中节点数的范围在 [0, 10^5^] 内
- -1000 <= Node.val <= 1000

### 代码

- 递归-深度优先遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        if (root.left == null && root.right == null) {
            return 1;
        }
        int leftDepth = minDepth(root.left);
        int rightDepth = minDepth(root.right);
        if (leftDepth == 0) {
            return rightDepth + 1;
        }
        if (rightDepth == 0) {
            return leftDepth + 1;
        }
        return Math.min(leftDepth, rightDepth) + 1;
    }

}
```

- 递归-深度优先遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        if (root.left == null && root.right == null) {
            return 1;
        }
        int min_depth = Integer.MAX_VALUE;
        if (root.left != null) {
            min_depth = Math.min(minDepth(root.left), min_depth);
        }
        if (root.right != null) {
            min_depth = Math.min(minDepth(root.right), min_depth);
        }
        return min_depth + 1;
    }

}
```

- 递归-深度优先遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        if (root.left == null && root.right == null) {
            return 1;
        }
        int leftDepth = minDepth(root.left);
        int rightDepth = minDepth(root.right);
        if (root.left == null) {
            return rightDepth + 1;
        }
        if (root.right == null) {
            return leftDepth + 1;
        }
        return Math.min(leftDepth, rightDepth) + 1;
    }

}
```

- 迭代-层次遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int minDepth(TreeNode root) {
        if (root == null) {
            return 0;
        }
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int depth = 0;
        while(!queue.isEmpty()) {
            depth++;
            int size = queue.size();
            while (size > 0) {
                TreeNode p = queue.poll();
                if (p.left == null && p.right == null) {
                    return depth;
                }
                if (p.left != null) {
                    queue.offer(p.left);
                }
                if (p.right != null) {
                    queue.offer(p.right);
                }
                size--;
            }
        }
        return depth;
    }

}
```

### 笔记

- 层次遍历：每次入队一层的元素，出队一层的元素，第一个出队的叶子节点所在的层数就是最小的深度。

## [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)

难度：简单:star::star::star:

### 题目

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

叶子节点 是指没有子节点的节点。

示例 1：

![img](noteImage/pathsum1.jpg)

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

示例 2：

![img](noteImage/pathsum2.jpg)

```
输入：root = [1,2,3], targetSum = 5
输出：false
解释：树中存在两条根节点到叶子节点的路径：
(1 --> 2): 和为 3
(1 --> 3): 和为 4
不存在 sum = 5 的根节点到叶子节点的路径。
```

示例 3：

```
输入：root = [], targetSum = 0
输出：false
解释：由于树是空的，所以不存在根节点到叶子节点的路径。
```

提示：

- 树中节点的数目在范围 [0, 5000] 内
- -1000 <= Node.val <= 1000
- -1000 <= targetSum <= 1000

### 代码

- 两次先序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        preOrder(root);
        Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode p = stack.pop();
            if (p.left == null && p.right == null && p.val == targetSum) {
                return true;
            }
            if (p.right != null) {
                stack.push(p.right);
            }
            if (p.left != null) {
                stack.push(p.left);
            }
        }
        return false;
    }
    public void preOrder(TreeNode root) {
        if (root != null) {
            if (root.left != null) {
                root.left.val = root.val + root.left.val;
            }
            if (root.right != null) {
                root.right.val = root.val + root.right.val;
            }
            preOrder(root.left);
            preOrder(root.right);
        }
    }
}
```

- 迭代-先序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode p = stack.pop();
            if (p.left != null) {
                p.left.val += p.val;
            }
            if (p.right != null) {
                p.right.val += p.val;
            }
            if (p.left == null && p.right == null && p.val == targetSum) {
                return true;
            }
            if (p.right != null) {
                stack.push(p.right);
            }
            if (p.left != null) {
                stack.push(p.left);
            }
        }
        return false;
    }
}
```

- 迭代-先序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode p = stack.pop();
            if (p.left == null && p.right == null && p.val == targetSum) {
                return true;
            }
            if (p.right != null) {
                p.right.val += p.val;
                stack.push(p.right);
            }
            if (p.left != null) {
                p.left.val += p.val;
                stack.push(p.left);
            }
        }
        return false;
    }
}
```

- 递归-找和改找差

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return root.val == targetSum;
        }
        return hasPathSum(root.left, targetSum - root.val) || hasPathSum(root.right, targetSum - root.val);
    }
}
```

- 两个队列

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean hasPathSum(TreeNode root, int targetSum) {
        if (root == null) {
            return false;
        }
        Queue<TreeNode> queue1 = new LinkedList<>();
        Queue<Integer> queue2 = new LinkedList<>();
        queue1.offer(root);
        queue2.offer(root.val);
        while(!queue1.isEmpty()) {
            TreeNode p = queue1.poll();
            int value = queue2.poll();
            if (p.left == null && p.right == null && value == targetSum) {
                return true;
            }
            if (p.left != null) {
                queue1.offer(p.left);
                queue2.offer(p.left.val + value);
            }
            if (p.right != null) {
                queue1.offer(p.right);
                queue2.offer(p.right.val + value);
            }
        }
        return false;
    }
}
```

### 笔记

- 递归：找根结点到叶子节点的路径和等于targetSum，也即，找根结点的子节点到叶子节点的路径和等于targetSum - root.val。

## [118. 杨辉三角](https://leetcode-cn.com/problems/pascals-triangle/)

难度：简单:star::star::star:

### 题目

给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](noteImage/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

示例 1:

```
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

示例 2:

```
输入: numRows = 1
输出: [[1]]
```

提示:

- 1 <= numRows <= 30

### 代码

- 利用杨辉三角的性质

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> yangHui = new ArrayList<List<Integer>>();

        for(int i=0; i < numRows; i++) {
            ArrayList<Integer> row = new ArrayList<>(); 
            for(int j = 0; j <= i; j++) {
                if (j == 0 || j == i) {
                    row.add(1);
                } else {
                    int val = yangHui.get(i-1).get(j-1) + yangHui.get(i-1).get(j);
                    row.add(val);
                }
            }
            yangHui.add(row);
        }
        return yangHui;
    }
}
```

- 二维数组的定义

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> yangHui = new ArrayList<List<Integer>>();

        for(int i=0; i < numRows; i++) {
            ArrayList<Integer> row = new ArrayList<>(); 
            for(int j = 0; j <= i; j++) {
                if (j == 0 || j == i) {
                    row.add(1);
                } else {
                    row.add(yangHui.get(i-1).get(j-1) + yangHui.get(i-1).get(j));
                }
            }
            yangHui.add(row);
        }
        return yangHui;
    }
}
```

### 笔记

- 杨辉三角形的性质：
  f(i, j) = f(i-1, j-1) + f(i-1, j），0<=i<rows; 0<= j <= i;

- Java中定义一个二维的动态数组：
  
  ```java
  List<List<Integer>> yangHui = new ArrayList<List<Integer>>();
  List<List<Integer>> yangHui = new ArrayList<>();
  ```
  
  java中ArrayList的常用方法：
  
  ```java
  yangHui.add(E); // 添加元素到 ArrayList
  yangHui.get(i); // 访问第i+1个元素。索引从0开始
  yanghui.set(2, E); // 第一个参数为索引位置，第二个为要修改的值
  yanghui.remove(3); // 删除第四个元素
  yanghui.size(); // 计算 ArrayList 中的元素数量可以使用 size() 方法
  ```

## [119. 杨辉三角 II](https://leetcode-cn.com/problems/pascals-triangle-ii/)

难度：简单:star::star::star:

### 题目

给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](noteImage/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

示例 1:

```
输入: rowIndex = 3
输出: [1,3,3,1]
```

示例 2:

```
输入: rowIndex = 0
输出: [1]
```

示例 3:

```
输入: rowIndex = 1
输出: [1,1]
```

提示:

- 0 <= rowIndex <= 33

进阶：

- 你可以优化你的算法到 O(rowIndex) 空间复杂度吗？

### 代码

- 暴力法

```java
class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<List<Integer>> yangHui = new ArrayList<>();
        for (int i = 0; i <= rowIndex; i++) {
            ArrayList<Integer> row = new ArrayList<>();
            for (int j = 0; j <= i; j++) {
                if (j == 0 || j == i) {
                    row.add(1);
                }
                else {
                    row.add(yangHui.get(i-1).get(j-1) + yangHui.get(i-1).get(j));
                }
            }
            yangHui.add(row);
        }
        return yangHui.get(rowIndex);
    }
}
```

- 只记录两行

```java
class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> preRow = new ArrayList<>();
        for (int i = 0; i <= rowIndex; i++) {
            List<Integer> curRow = new ArrayList<>();
            for (int j = 0; j <= i; j++) {
                if (j == 0 || j == i) {
                    curRow.add(1);
                }
                else {
                    curRow.add(preRow.get(j-1) + preRow.get(j));
                }
            }
            preRow = curRow;
        }
        return preRow;
    }
}
```

- 一个数组

```java
class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> row = new ArrayList<>();
        row.add(1);
        for (int i = 1; i <= rowIndex; i++) {
            row.add(0);
            for (int j = i; j > 0; j--) {
                row.set(j, row.get(j) + row.get(j-1));
            }
        }
        return row;
    }
}
```

### 笔记

- 暴力法：先构建杨辉三角的前rowIndex行，然后返回最后一行

- 只记录两行：前一行和当前行

- 一个数组：末尾添加一个0，然后从后往前算。
  
  ```
  1-->
  1, 0 -->
  1, 1 -->
  1, 1, 0 -->
  1, 1, 1 -->
  1, 2, 1 -->
  1, 2, 1, 0 -->
  1, 2, 1, 1 -->
  1, 2, 3, 1 -->
  1, 3, 3, 1
  ```

## [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

难度：简单:star::star::star:

### 题目

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

示例 1：

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

示例 2：

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

提示：

- 1 <= prices.length <= 10^5^
- 0 <= prices[i] <= 10^4^

### 代码

- 暴力法（超时）

```java
class Solution {
    public int maxProfit(int[] prices) {
        int profit = Integer.MIN_VALUE;
        for (int i = 0; i < prices.length; i++) {
            for (int j = i+1; j < prices.length; j++) {
                if (prices[j] > prices[i]) {
                    profit = Math.max(profit, prices[j] - prices[i]);
                }
            }
        }
        return Math.max(profit, 0);
    }
}
```

- 一次遍历

```java
class Solution {
    public int maxProfit(int[] prices) {
       int minPrice = Integer.MAX_VALUE;
       int profit = 0;
       for(int price : prices) {
           if (price < minPrice) {
               minPrice = price;
           }
           else if (price - minPrice > profit) {
               profit = price - minPrice;
           }
       }
       return profit;
    }
}
```

- 动态规划

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        int[] dp = new int[n];
        dp[0] = 0;
        int minPrice = prices[0];
        for (int i = 1; i < n; i++) {
            minPrice = Math.min(minPrice, prices[i]);
            dp[i] = Math.max(dp[i-1], prices[i] - minPrice);
        }
        return dp[n-1];
    }
}
```

### 笔记

- 一次遍历：记录一个历史最低价，如果当天的价格低于历史最低价，那么当天的价格就作为历史最低价，如果当天的价格大于等于历史最低价，那就看当天的价格和历史最低价的差是不是当天的最大利润，如果是，就更新这个利润。

- 动态规划：
  
  1. 从最优策略的最后一步来划分子问题：
     到第i天的最大利润=max(到第i-1天的最大利润， 第i天的价格-前i-1天的最低价格）
       这里的i>=1
  
  2. 改写成状态转移方程：
     
          f(i) = max(f(i-1), prices[i] - min(prices[0:i]))
          这里的i>=1
          f(i)就是截止到第i天的最大利润（是当天卖出或者不卖出这两种情况下的最大利润）
  
  3. 确定初始条件
     
              f(0) = 0, 表示第0天的利润为0，也即因为第0天买入了就不能卖出。就算当前买入又卖出，那当天的利润还是0。
              还需要一个变量来记录前i-1天的最小值，比如i取1,（实际上是第二天），前0天的最小值也即第0天的最小值，所以这个变量的初始值就位prices[0]
  
  4. 计算顺序
     
          我们就依次计算，到第i天的最大利润。最后就返回截止到最后一天的最大利润。

- 动态规划：
  对于[7,1,5,3,6,4]，结合状态转移方程有：
  f(0) = 0 
  f(1) = max(0, 1-7) = 0
  f(2) = max(0, 5-1) = 4
  f(3) = max(4, 3-1) = 4
  f(4) = max(4, 6-1) = 5
  f(5) = max(5, 4-1) = 5

## [540. 有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)

难度：中等:star::star::star::star:

### 题目

给你一个仅由整数组成的有序数组，其中每个元素都会出现两次，唯有一个数只会出现一次。

请你找出并返回只出现一次的那个数。

你设计的解决方案必须满足 O(log n) 时间复杂度和 O(1) 空间复杂度。

示例 1:

```
输入: nums = [1,1,2,3,3,4,4,8,8]
输出: 2
```

示例 2:

```
输入: nums =  [3,3,7,7,10,11,11]
输出: 10
```

提示:

- 1 <= nums.length <= 10^5^
- 0 <= nums[i] <= 10^5^

### 代码

- 递归使用二分法

```java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        return helper(nums, 0, nums.length - 1);
    }
    public int helper(int[] nums, int left, int right) {
        if (left == right) {
            return nums[left];
        }
        if (right - left == 1) {
            return -1;
        }
        int mid = left + (right - left) / 2;
        int res = -1;
        if (nums[mid] != nums[mid - 1] && nums[mid] != nums[mid + 1]) {
            return nums[mid];
        }
        else if (nums[mid] == nums[mid - 1]) {
            res = helper(nums, left, mid);
            if (res >= 0) {
                return res;
            } else {
                res = helper(nums, mid + 1, right);
                if (res >= 0) {
                    return res;
                }
            }
        }
        else if (nums[mid] == nums[mid + 1]) {
            res = helper(nums, left, mid - 1);
            if (res >= 0) {
                return res;
            } else {
                res = helper(nums, mid, right);
                if (res >= 0) {
                    return res;
                }
            }
        }
        return res;
    }
}
```

- 步长为2

```java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int n = nums.length;
        for(int i = 0; i < n - 1; i += 2) {
            if (nums[i] != nums[i+1]) {
                return nums[i];
            }
        }
        return nums[n - 1];
    }

}
```

- 使用异或

```java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int n = nums.length;
        int res = nums[0];
        for(int i = 1; i < n; i++) {
            res ^= nums[i];
        }
        return res;
    }

}
```

- 二分查找

```java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int lo = 0;
        int hi = nums.length - 1;
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            if (mid % 2 == 0) {
                if (nums[mid] == nums[mid+1]) {
                    lo = mid + 1;
                } else {
                    hi = mid;
                }
            } else {
                if (nums[mid] == nums[mid-1]) {
                    lo = mid + 1;
                } else {
                    hi = mid;
                }
            }
        }
        return nums[lo];
    }

}
```

- 二分+异或技巧

```java
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int lo = 0;
        int hi = nums.length - 1;
        while (lo < hi) {
            int mid = lo + (hi - lo) / 2;
            if (nums[mid] == nums[mid^1]) {
                lo = mid + 1;
            } else {
                hi = mid;
            }
        }
        return nums[lo];
    }

}
```

### 笔记

- 递归使用二分：通过二分来划分区间，如果中间的数和左边的数相等，就把这个数划分到左边的区间，这样就分为左右两个区间；如果中间的数和右边的数相等，就把这个数划分到右边的区间，也是这样就分为了左右两个区间。递归处理左右区间，就把一对一对的都划分到一起去了，不能划分成一对的那一个就是要返回的那一个了

- 找不同可以使用异或。
  异或：相同为0，不同为1
  二进制下用1表示真，0表示假，则异或的运算法则为：0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1）
  异或的性质
  
  1. 归零律：a ^ a = 0
  2. 恒等律：a ^ 0 = a
  3. 交换律： a ^ b = b ^ a
  4. 结合律： a ^ b ^ c = a ^ ( b ^ c)  = (a ^ b ) ^ c
  5. 自反：a ^ b ^ a = b

- 二分查找：由于给定数组有序 且 常规元素总是两两出现，因此如果**不考虑“特殊”的单一元素**的话，我们有结论：成对元素中的第一个所对应的下标必然是偶数，成对元素中的第二个所对应的下标必然是奇数。
  
  然后再**考虑存在单一元素**的情况，假如单一元素所在的下标为 x，那么**下标 x之前（左边）的位置仍满足上述结论**，而**下标 x之后（右边）的位置由于 x的插入，导致结论翻转，**，也即在下标x的右边是：成对元素中的第一个所对应的下表必然是奇数，第二个所对应的是偶数。
  基于这个，我们就可以通过分割点的下标的奇偶和分割点与左右两边值的相等关系，确定x一定是位于分割点左边还是右边。
  具体来说：
  设分割点的下标为mid，则有：
  
  - mid是偶数，则如果nums[mid]==nums[mid+1]，则，mid位于x的左侧，也即x位于mid的右侧，因为在x的左侧是：成对元素中的第一个所对应的下标必然是偶数。而mid是偶数，且mid是成对元素的第一个（因为nums[mid]==nums[mid+1]），所以mid位于x的左侧。这时就要把mid向右移，即lo = mid + 1。同理，如果nums[mid]!=nums[mid+1]。则mid位于x的右侧，即x位于mid的左侧。因为相等时mid是在x左侧，那么不等，mid肯定就在x右侧了。这时就要把mid左移，即hi = mid
  - mid是奇数，则如果nums[mid]==nums[mid-1]，mid位于x的左侧，也即x位于mid的右侧，因为在x的左侧是：成对元素中的第二个所对应的下标必然是奇数。而mid是奇数，且mid是成对元素的第二个（因为nums[mid]==nums[mid-1]），所以mid位于x的左侧。这时就要把mid向右移，即lo = mid + 1。同理，如果nums[mid]!=nums[mid-1]。则mid位于x的右侧，即x位于mid的左侧。因为相等时mid是在x左侧，那么不等，mid肯定就在x右侧了。这时就要把mid左移，即hi = mid

- 异或技巧：
  
  - 当 mid 是偶数时，mid +1 = mid⊕1；
  - 当 mid 是奇数时，mid - 1 = mid⊕1。

## [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

难度：简单:star::star::star:

### 题目

给你一个链表的头节点 head ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。

如果链表中存在环 ，则返回 true 。 否则，返回 false 。

示例 1：

![img](noteImage/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：true
解释：链表中有一个环，其尾部连接到第二个节点。
```

示例 2：

![img](noteImage/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：true
解释：链表中有一个环，其尾部连接到第一个节点。
```

示例 3：

![img](noteImage/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：false
解释：链表中没有环。
```

提示：

- 链表中节点的数目范围是 [0, 10^4^]
- -10^5^ <= Node.val <= 10^5^
- pos 为 -1 或者链表中的一个 有效索引 。

进阶：你能用 O(1)（即，常量）内存解决此问题吗？

### 代码

- 快慢指针

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while (fast != null && fast.next !=null) {
            fast = fast.next.next;
            slow = slow.next;
            if (fast == slow) {
                return true;
            }
        }
        return false;
    }
}
```

- 哈希表

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode p = head;
        HashSet<ListNode> set = new HashSet<>();
        while(p != null) {
            if (!set.add(p)) {
                return true;
            }
            p = p.next;
        }
        return false;
    }
}
```

### 笔记

- 快慢指针：快指针走两步，慢指针走一步。如果有环，快指针一定可以追上慢指针，追上了，说明有环，就返回true，跳出循环，如果没追上，则，快指针会先到终点，为空，然后自己出循环，说明没有环，返回false。

- 哈希集合：把访问过的节点保存到哈希集合中，如果节点已经保存过，说明有环。

- java关于哈希集合的定义和常用方法：
  
  ```java
  HashSet<E> set = new HashSet<>();
  set.add(E); // 如果E不在set中，将E插入set并返回true，如果E在set中，则不插入，并返回false
  set.remove(E); // 如果E在set中，将E删除并返回true，如果E不在set中，则返回false
  set.contains(E); // 如果set中有E，返回true，没有就返回false
  set.size(); // 返回set的元素个数
  set.isEmpty(); // set为空，返回true，不为空返回false
  ```

## [125. 验证回文串](https://leetcode-cn.com/problems/valid-palindrome/)

难度：简单:star::star::star:

### 题目

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

说明：本题中，我们将空字符串定义为有效的回文串。

示例 1:

```
输入: "A man, a plan, a canal: Panama"
输出: true
解释："amanaplanacanalpanama" 是回文串
```

示例 2:

```
输入: "race a car"
输出: false
解释："raceacar" 不是回文串
```

提示：

- 1 <= s.length <= 2 * 10^5^
- 字符串 s 由 ASCII 字符组成

### 代码

- 双指针

```java
class Solution {
    public boolean isPalindrome(String s) {
        int i = 0;
        int j = s.length() - 1;
        while (i < j) {
            while (!Character.isLetterOrDigit(s.charAt(i))) {
                i++;
                // 没有数字和字母
                if (i == s.length()) {
                    return true;
                }
            }
            while (!Character.isLetterOrDigit(s.charAt(j))) {
                j--;
            }
            if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) {
                return false;
            }
            i++;
            j--;
        }
        return true;
    }
}
```

- 提取字符串

```java
class Solution {
    public boolean isPalindrome(String s) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            if (Character.isLetterOrDigit(s.charAt(i))) {
                sb.append(Character.toLowerCase(s.charAt(i)));
            }
        }
        StringBuilder sb_rev = new StringBuilder(sb).reverse();
        return sb_rev.toString().equals(sb.toString());
    }
}
```

### 笔记

- Character类的常用方法：
  
  ```java
  Character.isDigit(char c);　　//判断字符c是否是数字字符，如‘1’，‘2’，是则返回true，否则返回false  
  
  Character.isLowerCase(char c) || Character.isUpperCase(char c);　　//判断c是否是字母字符，前面LowerCase是小写，后面UpperCase是大写，是返回True，否则返回False
  
  Character.isLetterOrDigit(char c);　　//判断c是否是字母或数字字符，是返回true,否则返回false
  Character.toUpperCase(char c); // 将字符c转换为大写
  Character.toLowerCase(char c); // 将字符c转换为小写
  Character.toString(char c); // 将字符c转换为字符串，长度为1
  ```

- StringBuilder类的定义和常用方法：
  
  ```java
  StringBuilder sb = new StringBuilder();
  sb.append(E); // 字符串拼接，append方法支持boolean,char,char[].double,float,int,long,String,Object
  sb.toString(); // 转字符串
  sb.reverse(); // 翻转字符串，执行这个之后，sb本身就被翻转了
  ```

- 关于StringBuilder的reverse：执行`sb.reverse();` 之后，sb本身就已经被翻转了。
  
  ```java
  StringBuilder sb = new StringBuilder("abcd");
  System.out.println(sb); // abcd
  sb.reverse(); 
  System.out.println(sb); // dcba
  ```
  
  ```java
  StringBuilder sb = new StringBuilder("abcd");
  System.out.println(sb); // abcd
  StringBuilder sb_rev = new StringBuilder(sb).reverse();
  System.out.println(sb); // abcd
  System.out.println(sb_rev); // dcba
  ```

## [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

难度：简单:star::star::star:

### 题目

给你二叉树的根节点 root ，返回它节点值的 前序 遍历。

示例 1：

![img](noteImage/inorder_1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,2,3]
```

示例 2：

```
输入：root = []
输出：[]
```

示例 3：

```
输入：root = [1]
输出：[1]
```

示例 4：

![img](noteImage/inorder_5.jpg)

```
输入：root = [1,2]
输出：[1,2]
```

示例 5：

![img](noteImage/inorder_4.jpg)

```
输入：root = [1,null,2]
输出：[1,2]
```

提示：

- 树中节点数目在范围 [0, 100] 内
- -100 <= Node.val <= 100

进阶：递归算法很简单，你可以通过迭代算法完成吗？

### 代码

- 递归-前序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        preOrder(root, result);
        return result;
    }
    public void preOrder(TreeNode root, List<Integer> result) {
        if (root != null) {
            result.add(root.val);
            preOrder(root.left, result);
            preOrder(root.right, result);
        }
    }
}
```

- 迭代-前序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root != null) {
            Deque<TreeNode> stack = new LinkedList<>();
            stack.push(root);
            while (!stack.isEmpty()) {
                TreeNode p = stack.pop();
                result.add(p.val);
                if (p.right != null) {
                    stack.push(p.right);
                }
                if (p.left != null) {
                    stack.push(p.left);
                }
            }
        }
        return result;
    }

}
```

- Morris遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) {
            return res;
        }

        TreeNode p1 = root, p2 = null;

        while (p1 != null) {
            p2 = p1.left;
            if (p2 != null) {
                while (p2.right != null && p2.right != p1) {
                    p2 = p2.right;
                }
                if (p2.right == null) {
                    res.add(p1.val);
                    p2.right = p1;
                    p1 = p1.left;
                    continue;
                } else {
                    p2.right = null;
                }
            } else {
                res.add(p1.val);
            }
            p1 = p1.right;
        }
        return res;
    }

}
```

### 笔记

- Java中ArrayList的定义及常用方法：
  
  ```java
  List<E> arr = new ArrayList<>();
  ArrayList<E> arr = new ArrayList<>();
  arr.add(E); // 将指定的元素追加到此列表的末尾。
  arr.get(i); // 返回此列表中指定位置的元素。
  arr.set(i, E); // 用指定的元素替换此列表中指定位置的元素。
  arr.remove(i); // 删除此列表中指定位置的元素。
  arr.size(); // 返回此列表中的元素数。
  arr.isEmpty(); // 如果此列表不包含任何元素，则返回 true 。
  ```

- 递归-前序遍历：（根左右）（是一个递归定义）
  
  - 访问根结点
  - 前序遍历左子树
  - 前序遍历右子树

- 迭代-前序遍历：（借助栈来完成）
  算法思想：
  
  1. 先把根结点入栈，然后在栈非空的情况下，对子数进行遍历。
  2. 先把根结点出栈，然后根据出栈的结点，访问该节点（输出访问节点的值）。
  3. 再将当前结点的右孩子入栈（如果有的话），再将当前根结点的左孩子入栈（如果有的话）。【注意：实现入栈右孩子，再入栈左孩子，这样可以先访问先出栈的左孩子，符合先序遍历】。
  4. 左右都入栈后，再将当前栈顶的元素出栈，并访问这个结点。
  5. 重复上述操作，直至栈空。

- Morris遍历：
  有一种巧妙的方法可以在线性时间内，只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。
  
  Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下：
  
  1. 新建临时节点，令该节点为 root；
  
  2. 如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；
  
  3. 如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点：
     
     - 如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。然后将当前节点加入答案，并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。
     
     - 如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。
  
  重复步骤 2 和步骤 3，直到遍历结束。

## [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

难度：简单:star::star::star:

### 题目

给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。

示例 1：

![img](noteImage/pre1.jpg)

```
输入：root = [1,null,2,3]
输出：[3,2,1]
```

示例 2：

```
输入：root = []
输出：[]
```

示例 3：

```
输入：root = [1]
输出：[1]
```

提示：

- 树中节点的数目在范围 [0, 100] 内
- -100 <= Node.val <= 100

进阶：递归算法很简单，你可以通过迭代算法完成吗？

### 代码

- 递归-后序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        postOrder(root, result);
        return result;
    }
    public void postOrder(TreeNode root, List<Integer> result) {
        if (root != null) {
            postOrder(root.left, result);
            postOrder(root.right, result);
            result.add(root.val);
        }
    }
}
```

- 迭代-后序遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root != null) {
            Deque<TreeNode> stack1 = new LinkedList<>();
            Deque<TreeNode> stack2 = new LinkedList<>();
            stack1.push(root);
            TreeNode p = new TreeNode();
            while(!stack1.isEmpty()) {
                p = stack1.pop();
                stack2.push(p);
                if (p.left != null) {
                    stack1.push(p.left);
                }
                if (p.right != null) {
                    stack1.push(p.right);
                }
            }
            while (!stack2.isEmpty()) {
                p = stack2.pop();
                result.add(p.val);
            }
        }
        return result;
    }

}
```

- Morris遍历

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }

        TreeNode p1 = root, p2 = null;

        while (p1 != null) {
            p2 = p1.left;
            if (p2 != null) {
                while (p2.right != null && p2.right != p1) {
                    p2 = p2.right;
                }
                if (p2.right == null) {
                    p2.right = p1;
                    p1 = p1.left;
                    continue;
                } else {
                    p2.right = null;
                    addPath(res, p1.left);
                }
            }
            p1 = p1.right;
        }
        addPath(res, root);
        return res;
    }

    public void addPath(List<Integer> res, TreeNode node) {
        int count = 0;
        while (node != null) {
            ++count;
            res.add(node.val);
            node = node.right;
        }
        int left = res.size() - count, right = res.size() - 1;
        while (left < right) {
            int temp = res.get(left);
            res.set(left, res.get(right));
            res.set(right, temp);
            left++;
            right--;
        }
    }

}
```

### 笔记

- 递归-后序遍历：（左右根）
  
  - 后序遍历左子树
  - 后序遍历右子树
  - 访问根结点

- 迭代-后序遍历：（借助两个栈来实现）
  算法思想：
  
  1. 先把根入栈1。
  2. 再把栈1的栈顶压入栈2.
  3. 从栈1出栈时，将其左右压入栈2.
  4. 再到3，重复，直至把右边都压入到栈2的下面，左边都压入到栈1的上面。
  5. 再把栈2中的依次出栈。

- Morris遍历：
  有一种巧妙的方法可以在线性时间内，只占用常数空间来实现后序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。
  
  Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其后序遍历规则总结如下：
  
  1. 新建临时节点，令该节点为 root；
  2. 如果当前节点的左子节点为空，则遍历当前节点的右子节点；
  3. 如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点；
     - 如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点，当前节点更新为当前节点的左子节点。
     - 如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。倒序输出从当前节点的左子节点到该前驱节点这条路径上的所有节点。当前节点更新为当前节点的右子节点。
  
  重复步骤 2 和步骤 3，直到遍历结束。

## [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

难度：简单:star::star::star:

### 题目

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

- push(x) —— 将元素 x 推入栈中。
- pop() —— 删除栈顶的元素。
- top() —— 获取栈顶元素。
- getMin() —— 检索栈中的最小元素。

示例:

输入：

```
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]
输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```

提示：

- pop、top 和 getMin 操作总是在 非空栈 上调用。

### 代码

- 辅助栈

```java
class MinStack {
    Deque<Integer> stack;
    Deque<Integer> hepler;
    public MinStack() {
        stack = new LinkedList<>();
        hepler = new LinkedList<>();
        hepler.push(Integer.MAX_VALUE);
    }

    public void push(int val) {
        stack.push(val);
        hepler.push(Math.min(hepler.peek(), val));
    }

    public void pop() {
        stack.pop();
        hepler.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return this.hepler.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

- 保存数组

```java
class MinStack {
    Deque<int[]> stack;
    public MinStack() {
        stack = new LinkedList<>();
    }

    public void push(int val) {
        if (stack.isEmpty()) {
            stack.push(new int[]{val, val});
        } else {
            stack.push(new int[]{val, Math.min(val, stack.peek()[1])});
        }

    }

    public void pop() {
        stack.pop();
    }

    public int top() {
        return stack.peek()[0];
    }

    public int getMin() {
        return stack.peek()[1];
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

### 笔记

- 辅助栈：增加一个辅助栈，使得每个元素 a 与其相应的最小值 m 时刻保持一一对应。因此我们可以使用一个辅助栈，与元素栈同步插入与删除，用于存储与每个元素对应的最小值。

- 保存数组：可以用一个栈，这个栈同时保存的是每个数字 x 进栈的时候的值 与 插入该值后的栈内最小值。即每次新元素 x 入栈的时候保存一个元组：（当前值 x，栈内最小值）

- 定义能插入数组的栈：
  
  ```java
  Deque<int[]> stack = new LinkedList<>();
  stack.push(new int[]{val, val});
  ```

## [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

难度：简单:star::star::star:

### 题目

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。

图示两个链表在节点 c1 开始相交：

![img](noteImage/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

注意，函数返回结果后，链表必须 **保持其原始结构** 。

自定义评测：

**评测系统** 的输入如下（你设计的程序 **不适用** 此输入）：

- intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0
- listA - 第一个链表
- listB - 第二个链表
- skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数
- skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数

评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 **视作正确答案** 。

示例 1：

![img](noteImage/160_example_1_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

示例 2：

```
输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

示例 3：

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
```

提示：

- listA 中节点数目为 m
- listB 中节点数目为 n
- 1 <= m, n <= 3 * 104
- 1 <= Node.val <= 105
- 0 <= skipA <= m
- 0 <= skipB <= n
- 如果 listA 和 listB 没有交点，intersectVal 为 0
- 如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]

进阶：你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？

### 代码

- 动态数组

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ArrayList<ListNode> list = new ArrayList<>();
        ListNode p = headA;
        while (p != null) {
            list.add(p);
            p = p.next;
        }
        p = headB;
        while (p != null) {
            if (list.contains(p)) {
                return p;
            }
            p = p.next;
        }
        return null;
    }
}
```

- 哈希集合

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        HashSet<ListNode> list = new HashSet<>();
        ListNode p = headA;
        while (p != null) {
            list.add(p);
            p = p.next;
        }
        p = headB;
        while (p != null) {
            if (list.contains(p)) {
                return p;
            }
            p = p.next;
        }
        return null;
    }
}
```

- 指针对齐

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p = headA;
        ListNode q = headB;
        int m = 0;
        int n = 0;
        while (p != null) {
            m++;
            p = p.next;
        }
        while (q != null) {
            n++;
            q = q.next;
        }
        p = headA;
        q = headB;
        if (m > n) {
            for(int i = 0; i < m-n; i++) {
                p = p.next;
            }
        }
        else {
            for (int i = 0; i < n-m; i++) {
                q = q.next;
            }
        }
        while(p != null && q != null && p != q) {
            p = p.next;
            q = q.next;
        }
        if (p == q) {
            return p;
        }
        return null;
    }
}
```

- 双指针

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p = headA;
        ListNode q = headB;
        while(p != q) {
            if (p == null) {
                p = headB;
            } else {
                p = p.next;
            }
            if (q == null) {
                q = headA;
            } else {
                q = q.next;
            }
        }
        if (p != null && q != null && p == q) {
            return p;
        }

        return null;
    }
}
```

### 笔记

- ArrayList判断元素是否在数组中：
  
  ```java
  ArrayList<E> list = new LinkedList<>();
  list.contains(E); // 如果指定的元素存在于动态数组中，则返回 true。否则返回false
  ```

- 使用HashSet判断是否包含某个元素比ArrayList要快很多。

- 指针对齐是双指针应用中的一个重要思想，尤其是需要遍历长度不同的链表时，可以先计数之后，找到长度差，然后让两个指针对齐，即使需要遍历的长度相同。

- 双指针：更巧妙一点的做法，指针p把headA遍历完之后，接着遍历headB；指针q把headB遍历完之后，接着遍历headA。这样p和q都是遍历了最多会m+n个结点，如果没有交点的话，都会遍历m+n个结点，然后都为空，退出循环。如果有交点的话。会提前退出。

## [168. Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)

难度：简单:star::star::star:

### 题目

给你一个整数 columnNumber ，返回它在 Excel 表中相对应的列名称。

例如：

```
A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...
```

示例 1：

```
输入：columnNumber = 1
输出："A"
```

示例 2：

```
输入：columnNumber = 28
输出："AB"
```

示例 3：

```
输入：columnNumber = 701
输出："ZY"
```

示例 4：

```
输入：columnNumber = 2147483647
输出："FXSHRXW"
```

提示：

- 1 <= columnNumber <= 2^31^ - 1

### 代码

- 找规律

```java
class Solution {
    public String convertToTitle(int columnNumber) {
        StringBuilder result = new StringBuilder();
        int quotient = columnNumber;
        int remainder = 0;
        while (quotient > 26) {
            remainder = quotient % 26;
            quotient /= 26;
            if (remainder == 0) {
                remainder = 26;
                quotient--;
            }
            result.append((char)('A' + remainder - 1));
        }
        result.append((char)('A' + quotient - 1));
        return result.reverse().toString();
    }
}
```

### 笔记

- 找规律：其实是用字母表示的26进制。逢26进1。比如AB就是1* 26+2 = 28。
  有一个特殊的地方：如果余数是0，比如52。
  52%26 = 0， 52/26=2。这时需要将余数改为26，然后将商减一，即**相当于**52%26=26,52/26=1
- A 的ASCII码是65，Z的ASCII码是90。
  java中字符+整型，会将字符转为对应的十进制ASCII码运算。使用(char)num强转类型可以将整型转为对应的ASCII码。

## [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

难度：简单:star::star::star:

### 题目

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

示例 1：

```
输入：[3,2,3]
输出：3
```

示例 2：

```
输入：[2,2,1,1,1,2,2]
输出：2
```

进阶：

- 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。

### 代码

- 哈希表计数

```java
class Solution {
    public int majorityElement(int[] nums) {
        HashMap<Integer, Integer> hashMap = new HashMap<>();
        int count = 0;
        for(int i = 0; i < nums.length; i++) {
            if (hashMap.containsKey(nums[i])) {
                hashMap.put(nums[i], hashMap.get(nums[i])+1);
            } else {
                hashMap.put(nums[i], 1);
            }
        }
        int maxKey = Integer.MIN_VALUE;
        int maxValue = Integer.MIN_VALUE;
        for (Map.Entry<Integer, Integer> entry : hashMap.entrySet()) {
            if (entry.getValue() > maxValue) {
                maxValue = entry.getValue();
                maxKey = entry.getKey();
            }
        }
        return maxKey;
    }
}
```

- 摩尔投票

```
class Solution {
    public int majorityElement(int[] nums) {
        int major = 0;
        int count = 0;
        for(int i : nums) {
            if (count == 0) {
                major = i;
            }
            if (i == major) {
                count++;
            } else {
                count--;
            }
        }
        return major;
    }
}
```

- 排序法

```java
class Solution {
    public int majorityElement(int[] nums) {
        Arrays.sort(nums);
        return nums[nums.length/2];
    }
}
```

### 笔记

- Java中关于HashMap的定义及常用方法：
  
  ```java
  HashMap<E, E> hashMap = new HashMap<>();
  hashMap.put(E, E); // 将键/值对添加到 hashMap 中,如果插入的 key 对应的 value 已经存在，则执行 value 替换操作，返回旧的 value 值，如果不存在则执行插入，返回 null。
  hashMap.containsKey(E); //    检查 hashMap 中是否存在指定的 key 对应的映射关系。
  hashMap.containsValue(E); // 检查 hashMap 中是否存在指定的 value 对应的映射关系。
  hashMap.get(E); // 获取指定 key 对应对 value
  hashMap.remove(E); // 删除 hashMap 中指定键 key 的映射关系
  hashMap.keySet(); // 返回 hashMap 中所有 key 组成的集合视图。
  hashMap.values(); // 返回 hashMap 中存在的所有 value 值。
  hashMap.entrySet(); // 返回此映射中包含的映射的 Set 视图。注意：Set 视图意思是 HashMap 中所有的键值对都被看作是一个 set 集合。
  hashMap.getOrDefault(E, defaultValue); // 返回指定键映射到的值，如果此映射不包含键的映射，则返回defaultValue 
  ```
  
  关于HashMap的常用遍历方法：
  
  ```java
  // 遍历HashMap的所有键
  Map<String, String> map = new HashMap<String, String>();
  for (String key : map.keySet()) {
      System.out.println(key);
      map.get(key);
  }
  ```
  
  ```java
  // 遍历HashMap的所有值
  Map<String, String> map = new HashMap<String, String>();
  for (String value : map.values()) {
      System.out.prntln(value);
  }
  ```
  
  ```java
  // 【推荐】遍历HashMap的键值对
  Map<String, String> map = new HashMap<String, String>();
  for (Map.Entry<String, String> entry : map.entrySet()) {
      entry.getKey();
      entry.getValue();
  }
  ```
  
  ```java
  // 使用forEach方法
  //通过 lambda 表达式使用 forEach()
  hashMap.forEach((key, value) -> {
          System.out.print(key + "=" + value + " ");
  });
  ```
  
- 关于Arrays.sort()：
  
  ```java
  Arrays.sort(nums); // 对数组进行升序排列（从小到大）
  ```
  
  ```java
  // 对数组进行降序排列
  Arrays.sort(nums, new Comparator<Integer>() {
      @Override
      public int compare(Integer o1, Integer o2) {
          return o2 - o1;
      }
  });
  // lambda 表达式，这种写法，nums中的类型需要是Integer
  Arrays.sort(nums, (o1, o2) -> o2 - o1);
  ```

- 摩尔投票：众数个数**至少**比非众数多一，把count加减当作一个众数抵消掉一个非众数，剩下的一定是众数。

## [171. Excel 表列序号](https://leetcode-cn.com/problems/excel-sheet-column-number/)

难度：简单:star::star::star:

### 题目

给你一个字符串 columnTitle ，表示 Excel 表格中的列名称。返回 该列名称对应的列序号 。

例如：

```
A -> 1
B -> 2
C -> 3
...
Z -> 26
AA -> 27
AB -> 28 
...
```

示例 1:

```
输入: columnTitle = "A"
输出: 1
```

示例 2:

```
输入: columnTitle = "AB"
输出: 28
```

示例 3:

```
输入: columnTitle = "ZY"
输出: 701
```

提示：

- 1 <= columnTitle.length <= 7
- columnTitle 仅由大写英文组成
- columnTitle 在范围 ["A", "FXSHRXW"] 内

### 代码

- 从后往前

```java
class Solution {
    public int titleToNumber(String columnTitle) {
        int res = 0;
        int n = columnTitle.length();
        for(int i = n-1; i >= 0; i--) {
            res += ((int)columnTitle.charAt(i) - 64)*Math.pow(26, n-1-i);
        }
        return res;
    }
}
```

- 从前往后

```java
class Solution {
    public int titleToNumber(String columnTitle) {
        int res = 0;
        int n = columnTitle.length();
        for(int i = 0; i < n; i++) {
            res = res * 26 + (columnTitle.charAt(i) - 'A' + 1);
        }
        return res;
    }
}
```

### 笔记

- Java计算幂次方：
  
  ```java
  Math.pow(a,b); // 返回a的b次方。
  ```

- 从后往前：从后往前遍历，最后的结果就是：每次字母对应的值 * 26的0,1,2,3...次幂 的和。‘

- 从前往后：res = res * 26 + (columnTitle.charAt(i) - 'A' + 1)

## [175. 组合两个表](https://leetcode-cn.com/problems/combine-two-tables/)

难度：简单:star::star::star:

### 题目

SQL架构

表1: `Person`

```
+-------------+---------+
| 列名         | 类型     |
+-------------+---------+
| PersonId    | int     |
| FirstName   | varchar |
| LastName    | varchar |
+-------------+---------+
PersonId 是上表主键
```

表2: `Address`

```
+-------------+---------+
| 列名         | 类型    |
+-------------+---------+
| AddressId   | int     |
| PersonId    | int     |
| City        | varchar |
| State       | varchar |
+-------------+---------+
AddressId 是上表主键
```

编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：

```
FirstName, LastName, City, State
```

### 代码

- 左连接

```mysql
# Write your MySQL query statement below
select a.FirstName, a.LastName, b.City, b.State from Person a left join Address b on a.PersonId = b.PersonId; 
```

### 笔记

- MySQL中连接的使用：你可以在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。
  
  JOIN 按照功能大致分为如下三类：
  
  INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。
  LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。
  RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。

- inner join：2表值都存在
  
  outer join：附表中值可能存在null的情况。
  
  总结：
  
  ①A inner join B：取交集
  
  ②A left join B：取A全部，B没有对应的值，则为null
  
  ③A right join B：取B全部，A没有对应的值，则为null
  
  ④A full outer join B：取并集，彼此没有对应的值为null
  
  上述4种的对应条件，在on后填写。

## [181. 超过经理收入的员工](https://leetcode-cn.com/problems/employees-earning-more-than-their-managers/)

难度：简单:star::star::star:

### 题目

SQL架构

表：`Employee` 

```
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| name        | varchar |
| salary      | int     |
| managerId   | int     |
+-------------+---------+
Id是该表的主键。
该表的每一行都表示雇员的ID、姓名、工资和经理的ID。
```

编写一个SQL查询来查找收入比经理高的员工。

以 **任意顺序** 返回结果表。

查询结果格式如下所示。

**示例 1:**

```
输入: 
Employee 表:
+----+-------+--------+-----------+
| id | name  | salary | managerId |
+----+-------+--------+-----------+
| 1  | Joe   | 70000  | 3         |
| 2  | Henry | 80000  | 4         |
| 3  | Sam   | 60000  | Null      |
| 4  | Max   | 90000  | Null      |
+----+-------+--------+-----------+
输出: 
+----------+
| Employee |
+----------+
| Joe      |
+----------+
解释: Joe 是唯一挣得比经理多的雇员。
```

### 代码

- 用where

```mysql
# Write your MySQL query statement below
select a.name as 'Employee'
from Employee as a, Employee as b
where a.managerId=b.id and a.salary > b.salary
```

- 用join

```mysql
# Write your MySQL query statement below
select a.name as 'Employee'
from Employee as a inner join Employee as b
on a.managerId=b.id and a.salary > b.salary
```

### 笔记

- 用where：自关联查询
  用Join：JOIN 是一个更常用也更有效的将表连起来的办法，我们使用 ON 来指明条件。

## [182. 查找重复的电子邮箱](https://leetcode-cn.com/problems/duplicate-emails/)

难度：简单:star::star::star:

### 题目

SQL架构

编写一个 SQL 查询，查找 `Person` 表中所有重复的电子邮箱。

**示例：**

```
+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
```

根据以上输入，你的查询应返回以下结果：

```
+---------+
| Email   |
+---------+
| a@b.com |
+---------+
```

**说明：**所有电子邮箱都是小写字母。

### 代码

- group by + 临时表

```mysql
# Write your MySQL query statement below
select tmp.Email from (
    select Email, count(Email) as num 
    from Person
    group by Email
) tmp 
where tmp.num > 1
```

- group by + having

```mysql
# Write your MySQL query statement below
select Email 
from Person 
group by Email 
having count(Email)>1
```

- 自连接+distinct

```mysql
# Write your MySQL query statement below
select distinct a.Email
from Person as a, Person as b
where a.Id != b.Id and a.Email = b.Email
```

- 左连接+distinct

```mysql
# Write your MySQL query statement below
select distinct a.Email
from Person as a
left join Person as b
on a.Email = b.Email
where a.Id != b.Id
```

### 笔记

- 向 GROUP BY 添加条件的一种更常用的方法是使用 HAVING 子句，该子句更为简单高效。
- 优先顺序：where>group by>having>order by

## [183. 从不订购的客户](https://leetcode-cn.com/problems/customers-who-never-order/)

难度：简单:star::star::star:

### 题目

SQL架构

某网站包含两个表，`Customers` 表和 `Orders` 表。编写一个 SQL 查询，找出所有从不订购任何东西的客户。

`Customers` 表：

```
+----+-------+
| Id | Name  |
+----+-------+
| 1  | Joe   |
| 2  | Henry |
| 3  | Sam   |
| 4  | Max   |
+----+-------+
```

`Orders` 表：

```
+----+------------+
| Id | CustomerId |
+----+------------+
| 1  | 3          |
| 2  | 1          |
+----+------------+
```

例如给定上述表格，你的查询应返回：

```
+-----------+
| Customers |
+-----------+
| Henry     |
| Max       |
+-----------+
```

### 代码

- 子查询+not in

```mysql
# Write your MySQL query statement below
select Name as 'Customers'
from Customers as a
where a.Id not in (
    select distinct CustomerId 
    from Orders
)
```

### 笔记

- 查询没有的时候可以考虑用not in

## [193. 有效电话号码](https://leetcode-cn.com/problems/valid-phone-numbers/)

难度：简单:star::star::star:

### 题目

给定一个包含电话号码列表（一行一个电话号码）的文本文件 file.txt，写一个单行 bash 脚本输出所有有效的电话号码。

你可以假设一个有效的电话号码必须满足以下两种格式： (xxx) xxx-xxxx 或 xxx-xxx-xxxx。（x 表示一个数字）

你也可以假设每行前后没有多余的空格字符。

示例：

假设 file.txt 内容如下：

```
987-123-4567
123 456 7890
(123) 456-7890
```

你的脚本应当输出下列有效的电话号码：

```
987-123-4567
(123) 456-7890
```

### 代码

- 正则表达式

```bash
# Read from the file file.txt and output all valid phone numbers to stdout.
grep -P '^([0-9]{3}-|\([0-9]{3}\) )[0-9]{3}-[0-9]{4}$' file.txt
```

### 笔记

- 正则表达式：[正则表达式中限定符与定位符的灵活使用](https://leetcode-cn.com/problems/valid-phone-numbers/solution/zheng-ze-biao-da-shi-zhong-xian-ding-fu-yu-ding-we/)

## [195. 第十行](https://leetcode-cn.com/problems/tenth-line/)

难度：简单:star::star::star:

### 题目

给定一个文本文件 file.txt，请只打印这个文件中的第十行。

示例:

假设 file.txt 有如下内容：

```
Line 1
Line 2
Line 3
Line 4
Line 5
Line 6
Line 7
Line 8
Line 9
Line 10
```

你的脚本应当显示第十行：

Line 10
说明:

1. 如果文件少于十行，你应当输出什么？
2. 至少有三种不同的解法，请尝试尽可能多的方法来解题。

### 代码

- awk

```bash
# Read from the file file.txt and output the tenth line to stdout.
awk 'NR==10' file.txt
```

- sed

```bash
# Read from the file file.txt and output the tenth line to stdout.
sed -n 10p file.txt
```

- tail + head

```bash
# Read from the file file.txt and output the tenth line to stdout.
tail -n +10 file.txt | head -1
```

### 笔记

- 打 印     第 十 行 ：sed -n '10p' file.txt
  打 印 一 到 十 行 ：sed -n '1,10p' file.txt
  查 找 指 定 字 符 ：grep -n 'KeyWord' file.txt
  打印指定字符上下5行：grep -C 5 'KeyWord' file.txt
  打印指定字符上下N行：grep -A 100 -B 100 'KeyWord' file.txt
  (-A after 后面, -B before 前面)
  
  查找指定字符出现次数： grep -o 'KeyWord' file.txt | wc -l

- 本题如果先head再tail的话会导致【假如文件不到10行依然会显示某一个错误的行】。所以先tail -n +10选出从第10行开始的所有行（保证了假如文件不到10行时，不应该有任何输出），然后再用head -1输出筛选出的内容的第1行。

## [196. 删除重复的电子邮箱](https://leetcode-cn.com/problems/delete-duplicate-emails/)

难度：简单:star::star::star:

### 题目

SQL架构

表: `Person`

```
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| email       | varchar |
+-------------+---------+
id是该表的主键列。
该表的每一行包含一封电子邮件。电子邮件将不包含大写字母。
```

编写一个SQL查询来 **删除** 所有重复的电子邮件，只保留一个id最小的唯一电子邮件。

以 **任意顺序** 返回结果表。

查询结果格式如下所示。

**示例 1:**

```
输入: 
Person 表:
+----+------------------+
| id | email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
| 3  | john@example.com |
+----+------------------+
输出: 
+----+------------------+
| id | email            |
+----+------------------+
| 1  | john@example.com |
| 2  | bob@example.com  |
+----+------------------+
解释: john@example.com重复两次。我们保留最小的Id = 1。
```

### 代码

- delete

```mysql
# Write your MySQL query statement below
delete a
from Person as a, Person as b
where a.email = b.email and a.id > b.id
```

- delete + left join

```mysql
# Write your MySQL query statement below
delete a
from Person as a
left join Person as b
on a.email = b.email
where a.id > b.id
```

### 笔记

## [197. 上升的温度](https://leetcode-cn.com/problems/rising-temperature/)

难度：简单:star::star::star:

### 题目

SQL架构

表： `Weather`

```
+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| id            | int     |
| recordDate    | date    |
| temperature   | int     |
+---------------+---------+
id 是这个表的主键
该表包含特定日期的温度信息
```

编写一个 SQL 查询，来查找与之前（昨天的）日期相比温度更高的所有日期的 `id` 。

返回结果 **不要求顺序** 。

查询结果格式如下例。

**示例 1：**

```
输入：
Weather 表：
+----+------------+-------------+
| id | recordDate | Temperature |
+----+------------+-------------+
| 1  | 2015-01-01 | 10          |
| 2  | 2015-01-02 | 25          |
| 3  | 2015-01-03 | 20          |
| 4  | 2015-01-04 | 30          |
+----+------------+-------------+
输出：
+----+
| id |
+----+
| 2  |
| 4  |
+----+
解释：
2015-01-02 的温度比前一天高（10 -> 25）
2015-01-04 的温度比前一天高（20 -> 30）
```

### 代码

- datediff

```mysql
# Write your MySQL query statement below
select b.id
from Weather as a, Weather as b
where datediff(b.recordDate, a.recordDate)=1 and b.Temperature > a.Temperature
```

- date diff + left join

```mysql
# Write your MySQL query statement below
select b.id
from Weather as a
left join Weather as b
on datediff(b.recordDate, a.recordDate)=1 
where b.Temperature > a.Temperature
```

### 笔记

- DATEDIFF() 函数返回两个日期之间的天数。

## [202. 快乐数](https://leetcode-cn.com/problems/happy-number/)

难度：简单:star::star::star:

### 题目

编写一个算法来判断一个数 n 是不是快乐数。

「快乐数」 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
- 如果这个过程 结果为 1，那么这个数就是快乐数。
- 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。

 

示例 1：

```
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

示例 2：

```
输入：n = 2
输出：false
```


提示：

- 1 <= n <= 2^31^ - 1

### 代码

- 暴力法

```java
class Solution {
    public boolean isHappy(int n) {
        HashSet<Integer> set = new HashSet<>();
        while (n != 1) {
            ArrayList<Integer> nums = new ArrayList<>();
            int i;
            while(n > 0) {
                i = n % 10;
                n = n / 10;
                nums.add(i);
            }
            int sumOfSquares = 0;
            for(int num : nums) {
                sumOfSquares += num * num;
            }
            if (set.contains(sumOfSquares)) {
                return false;
            }
            set.add(sumOfSquares);
            n = sumOfSquares;
        }
        return true;
    }
}
```

- 优化暴力法

```java
class Solution {
    public boolean isHappy(int n) {
        HashSet<Integer> set = new HashSet<>();
        while (n != 1) {
            int num;
            int sumOfSquares = 0;
            while(n > 0) {
                num = n % 10;
                n = n / 10;
                sumOfSquares += num * num;
            }
            if (set.contains(sumOfSquares)) {
                return false;
            }
            set.add(sumOfSquares);
            n = sumOfSquares;
        }
        return true;
    }
}
```

- 快慢指针

```java
class Solution {
    public boolean isHappy(int n) {
        int slow = n;
        int fast = n;
        while (fast != 1) {
            fast = squaresSum(fast);
            if (fast == 1) {
                return true;
            }
            fast = squaresSum(fast);
            if (fast == 1) {
                return true;
            }
            slow = squaresSum(slow);
            if (fast == slow) {
                return false;
            }
        }
        return true;
    }
    public int squaresSum(int n) {
        int num;
        int sumOfSquares = 0;
        while(n > 0) {
            num = n % 10;
            n = n / 10;
            sumOfSquares += num * num;
        }
        return sumOfSquares;
    }
}
```

### 笔记

- 无限循环即出现了循环，比如：
  2,4,16,37,58,89,145,42,20,4。又出现了4，就会陷入循环。

- 优化暴力：取出每一位的时候就顺便计算平方和

- 按照快乐数的计算方法，可能会出现3种情况：

  1. 最终会得到 1。
  2. 最终会进入循环。
  3. 值会越来越大，最后接近无穷大。

  但实际上第3种情况可以被证明（较复杂）不会出现，在代码只需要考虑第1和第2中情况。

- 对于循环问题可以考虑使用快慢指针：快指针算两次，慢指针算一次。如果有环，一定会相遇。

