[TOC]



# 力扣刷题笔记（一）

## [278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/)

难度 ： 简单:star::star::star:

### 题目

你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。

假设你有 `n` 个版本` [1, 2, ..., n]`，你想找出导致之后所有版本出错的第一个错误的版本。

你可以通过调用 `bool isBadVersion(version)` 接口来判断版本号 `version `是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。


示例 1：

```
输入：n = 5, bad = 4
输出：4
解释：
调用 isBadVersion(3) -> false 
调用 isBadVersion(5) -> true 
调用 isBadVersion(4) -> true
所以，4 是第一个错误的版本。
```

示例 2：

```
输入：n = 1, bad = 1
输出：1
```

提示：

- 1 <= bad <= n <= 2^31^ - 1​

### 代码

```python
class Solution:
    def firstBadVersion(self, n):
        """
        :type n: int
        :rtype: int
        """
        left, right = 1, n
        while left <= right:
            mid = left + (right - left) // 2
            if not isBadVersion(mid):
                left = mid + 1
            else:
                right = mid - 1    
        return left
```

### 笔记

- 最后返回的是left。
  如果最后返回mid，则在n = 6, bad = 4时会输出错误结果。

## [189. 旋转数组](https://leetcode-cn.com/problems/rotate-array/)

难度 ： 中等:star::star::star::star:

### 题目

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

 

进阶：

尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？

示例 1:

```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]
```

示例 2:

```
输入：nums = [-1,-100,3,99], k = 2
输出：[3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]
```


提示：

- 1 <= nums.length <= 2 * 10^4​​​^
- -2^31^ <= nums[i] <= 2^31^ - 1
- 0 <= k <= 10^5^

### 代码

- Python切片

```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        nums_c = nums[:]
        k %= n
        nums[:k] =  nums_c[n-k:]
        nums[k:] = nums_c[:n-k]
```

- 原地修改

```python
class Solution:
    def rotate(self, nums: List[int], k: int) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        n = len(nums)
        k %= n
        self.reverse(nums, 0, n-1)
        self.reverse(nums, 0, k-1)
        self.reverse(nums, k, n-1)
    

    def reverse(self, nums: List[int], l: int, r: int) -> None:
        while l <= r:
            nums[l], nums[r] = nums[r], nums[l]
            l += 1
            r -= 1
```

- 循环

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int n = nums.length;
        k %= n;
        int[] res = new int[n];
        for(int i = 0; i < n; i++) {
            res[i] = nums[(n - k + i) % n];
        }
        for(int i = 0; i < n; i++) {
            nums[i] = res[i];
        }
    }
}
```



### 笔记

- 由于需要modify nums in-place instead，所以nums的内存地址不能变，那就复制一份，再在原nums上修改。
- 注意，会出现循环的情况，k要取余。

## [283. 移动零](https://leetcode-cn.com/problems/move-zeroes/)

难度：简单:star::star::star:

### 题目

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

示例:

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```


说明:

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。

### 代码

- 方法一

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        count = 0
        for i in nums[:]:
            if not i:
                nums.remove(i)
                nums.append(0)
```

- 双指针

```python
class Solution:
    def moveZeroes(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        left, right = 0, 0
        while right < len(nums):
            if nums[right]:
                nums[left], nums[right] = nums[right], nums[left]
                left += 1
            right += 1
```

### 笔记

- 方法一：先删除，再添加
- 方法二：双指针，官方题解思想，很强。
  right找非0，left记录第一个0

## [167. 两数之和 II - 输入有序数组](https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/)

难度：简单:star::star::star:

### 题目

给定一个已按照 升序排列  的整数数组 `numbers` ，请你从数组中找出两个数满足相加之和等于目标数 `target` 。

函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。`numbers `的下标 **从 1 开始计数** ，所以答案数组应当满足` 1 <= answer[0] < answer[1] <= numbers.length` 。

你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

示例 1：

```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```


示例 2：

```
输入：numbers = [2,3,4], target = 6
输出：[1,3]
```


示例 3：

```
输入：numbers = [-1,0], target = -1
输出：[1,2]
```


提示：

- 2 <= numbers.length <= 3 * 10^4^
- -1000 <= numbers[i] <= 1000
- numbers 按 递增顺序 排列
- -1000 <= target <= 1000
- 仅存在一个有效答案

### 代码

- 暴力解法

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        left, right = 0, 1
        while True:
            if (numbers[left] + numbers[right]) < target:
                right += 1
            elif (numbers[left] + numbers[right]) > target:
                left += 1
                right = left + 1
            elif (numbers[left] + numbers[right]) == target:
                return [left + 1, right + 1]
            
            if right == len(numbers):
                left += 1
                right = left + 1
```

- 双指针

```python
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        left, right = 0, len(numbers) - 1
        while left < right:
            if (numbers[left] + numbers[right]) < target:
                left += 1
            elif (numbers[left] + numbers[right]) > target:
                right -= 1
            elif (numbers[left] + numbers[right]) == target:
                return [left + 1, right + 1]
        return [-1, -1]
```

### 笔记

- 优化解法：左边向右找，右边向左找。

## [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

难度：简单:star::star::star:

### 题目

给定一个整数数组 `nums `和一个整数目标值 `target`，请你在该数组中找出 和为目标值 `target  `的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

 

示例 1：

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```


示例 2：

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```


示例 3：

```
输入：nums = [3,3], target = 6
输出：[0,1]
```


提示：

- 2 <= nums.length <= 10^4^
- -10^^9 <= nums[i] <= 10^9^
- -10^9^ <= target <= 10^9^
- 只会存在一个有效答案



**进阶：**你可以想出一个时间复杂度小于 O(n^2^) 的算法吗？

### 代码

- 暴力法

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        n = len(nums)
        for i in range(n):
            sub = target - nums[i]
            for j in range(i+1, n):
                if (sub - nums[j]) == 0:
                    return [i, j]
```

- 优化查找索引

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        n = len(nums)
        for i in range(n):
            sub = target - nums[i]
            nums_c = nums[i+1:]
            if sub in nums_c:
                return [i, nums_c.index(sub)+i+1]
        return []
```

- 哈希表

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hashtable = {}
        for i in range(len(nums)):
            sub = target - nums[i]
            if sub in hashtable.keys():
                return [hashtable[sub], i]
            else:
                hashtable[nums[i]] = i
        return []
```

### 笔记

- 将值作为key，索引作为value。这样查找索引时可以直接拿到

## [557. 反转字符串中的单词 III](https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/)

难度：简单:star::star::star:

### 题目

给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

 

示例：

```
输入："Let's take LeetCode contest"
输出："s'teL ekat edoCteeL tsetnoc"
```


提示：

- 在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。

### 代码

- 暴力翻转

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        left, right = 0, 0
        s_list = list(s)
        while right < len(s):
            if s[right] == ' ':
                l, r = left, right - 1
                while l < r:
                    s_list[l], s_list[r] = s_list[r], s_list[l]
                    l += 1
                    r -= 1
                left = right + 1
            if right == len(s) - 1:
                l, r = left, right
                while l < r:
                    s_list[l], s_list[r] = s_list[r], s_list[l]
                    l += 1
                    r -= 1
            right += 1
        st = ''
        for si in s_list:
            st = st + si
        return st
```

- Python切片

```python
class Solution:
    def reverseWords(self, s: str) -> str:
        return ' '.join([i[::-1] for i in s.split()])
```

### 笔记

- Python好用的小技巧：
  - `str[::-1]`可以翻转字符串
  - `join()`函数可以将列表转为字符串
  - `split()`函数可以将字符串转为列表

## [1711. 大餐计数](https://leetcode-cn.com/problems/count-good-meals/)

难度：中等:star::star::star::star:

### 题目

大餐 是指 **恰好包含两道不同餐品** 的一餐，其美味程度之和等于 2 的幂。

你可以搭配 **任意** 两道餐品做一顿大餐。

给你一个整数数组 `deliciousness `，其中 `deliciousness[i]` 是第 i 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 大餐 的数量。结果需要对 10^9^ + 7 取余。

注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。

 

示例 1：

```
输入：deliciousness = [1,3,5,7,9]
输出：4
解释：大餐的美味程度组合为 (1,3) 、(1,7) 、(3,5) 和 (7,9) 。
它们各自的美味程度之和分别为 4 、8 、8 和 16 ，都是 2 的幂。
```

示例 2：

```
输入：deliciousness = [1,1,1,3,3,3,7]
输出：15
解释：大餐的美味程度组合为 3 种 (1,1) ，9 种 (1,3) ，和 3 种 (1,7) 。
```

提示：

- 1 <= deliciousness.length <= 10^5^
- 0 <= deliciousness[i] <= 2^20^

### 代码

- ~~暴力解法【超时】~~

```python
class Solution:
    def countPairs(self, deliciousness: List[int]) -> int:
        mod = 10**9 + 7
        # 存储2的幂
        two_power = [2**i for i in range(21)]
        # 去个重，并用哈希表记录重复的个数
        hashtable = dict()
        for i in deliciousness:
            if i not in hashtable:
                hashtable[i] = 1
            else:
                hashtable[i] += 1
        # 再统计符合条件的数量
        count = 0
        # 美味程度相同，组成的大餐
        for key, value in hashtable.items():
            if value > 1 and (key * 2 in two_power):
                count = count + (value * (value - 1)) // 2
        # 美味程度不同，组成的大餐
        left, right = 0, 1
        deli_diff = list(hashtable.keys())
        while left < len(deli_diff) - 1:
            if (deli_diff[left] + deli_diff[right]) in two_power:
                v_l = hashtable[deli_diff[left]]
                v_r = hashtable[deli_diff[right]]
                count = count + v_l * v_r
            right += 1
            if right == len(deli_diff):
                left += 1
                right = left + 1
        return count % mod
```

- 用哈希表找差值

```python
class Solution:
    def countPairs(self, deliciousness: List[int]) -> int:
        mod = 10 ** 9 + 7
        # 存储2的幂
        two_power = [2**i for i in range(22)]
        # 去个重，并用哈希表记录重复的个数
        hashtable = dict()
        for i in deliciousness:
            if i not in hashtable:
                hashtable[i] = 1
            else:
                hashtable[i] += 1
        # 再统计符合条件的数量
        count = 0
        for key, value in hashtable.items():
            # 美味程度相同，组成的大餐
            if value > 1 and (key * 2 in two_power):
                count = count + (value * (value - 1)) // 2
            # 美味程度不同，组成的大餐
            for power in two_power:
                sub = power - key
                # 这个判断很关键，但是的确不太好理解
                if sub > key and (sub in hashtable.keys()):
                    count = count + value * hashtable[sub]
        return count % mod
```

### 笔记

- 优化方法：找一个满足某个条件的值，都可以考虑使用哈希表。

  注意点：
  - 存储2的幂的时候要到2^22^次幂，因为可能有两个2^21，比如：[1048576, 1048576]，输出应为1。
  - 寻找相同的组成的个数用组合的知识知道，是$C_{n}^{2}=\frac{n*(n-1)}{2}$，这个比较简单
  - 如何减少次数的寻找不同的组成的个数比较麻烦。这种情况下，稍微用了一点逆向思维：不是枚举两两元素的和，看是不是2的某次幂，而是用2的某次幂减去一个元素，再看它们的差是不是在哈希表中。`if sub > key and (sub in hashtable.keys()):`这个判断是最关键的，下面来仔细理解一下，`sub + key = power`，那么`sub > 0`这个好理解，为什么要`sub > key`呢？来举个例子：比如[149, 107, 254, 1]。key=149的时候，满足`sub in hashtable.keys()`就只有107了，但是sub=107是小于key=149的，这种情况是不是就漏掉了呢？确实漏掉了，这种情况是一种重复的情况，的确需要“被漏掉”，因为当key=107的时候，会找到sub=149>key=107这个满足要求的情况，也就是说已经会计算一次107,149这种组合，那么149,107这种组合就不用再重复计算了。同样的，254,1这种组合由于不满足sub=1>key=254,但sub=254>key=1的情况会被计算，即254和1这两个数的组合会被计算。**总结一下：每次找差值的时候，找比当前值要大的那个差值即可。如果当前值和一个比它小的值的组合满足条件，这种组合的计算交给那个比它小的值去找，它会找到这个当前值。**

## [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

难度：中等:star::star::star::star:

### 题目

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**进阶：**你能尝试使用一趟扫描实现吗？

 

**示例 1：**

![img](noteImage/remove_ex1.jpg)

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```


示例 2：

```
输入：head = [1], n = 1
输出：[]
```


示例 3：

```
输入：head = [1,2], n = 1
输出：[1]
```


提示：

- 链表中结点的数目为 sz
- 1 <= sz <= 30
- 0 <= Node.val <= 100
- 1 <= n <= sz

### 代码

- 双指针

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* removeNthFromEnd(struct ListNode* head, int n){
    struct ListNode* p = head;
    struct ListNode* q = head;
    while(n > 0) {
        p = p->next;
        n--;
    }
    while(p && p->next) {
        p = p->next;
        q = q->next;
    }

    if(q != head || (q == head && p)){
        if(q->next) {
            q->next = q->next->next;
        }
    }
    if(q == head && !p) {
        head = q->next;
    }
    return head;

}
```

- 快慢指针

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* removeNthFromEnd(struct ListNode* head, int n){
    struct ListNode* p = head;
    struct ListNode* q = head;
    while(n > 0) {
        p = p->next;
        n--;
    }
    while(p && p->next) {
        p = p->next;
        q = q->next;
    }
    if(q != head || (q == head && p)) // 这时是删除q后面的
        q->next = q->next->next;
    if(q == head && !p) // 这时是删除q自己
        head = q->next;
    return head;
}
```

- 加一个虚拟头结点的快慢指针

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        h = ListNode()
        h.next = head
        p, q = head, h
        while n:
            p = p.next
            n -= 1
        while p:
            p = p.next
            q = q.next
        q.next = q.next.next
        return h.next
```

### 笔记

- 快慢指针很好用！

  加一个空的头结点可以省去很多判断。p先走n步，然后p,q再一起走，p走到None的时候，要删除的就是q的后面的那一个。直接：`q.next = q.next.next`就可以删除q后面的那个

## [1710. 主要元素](https://leetcode-cn.com/problems/find-majority-element-lcci/)

难度：简单:star::star::star:

### 题目

数组中占比超过一半的元素称之为主要元素。给你一个 整数 数组，找出其中的主要元素。若没有，返回 -1 。请设计时间复杂度为 O(N) 、空间复杂度为 O(1) 的解决方案。

 

示例 1：

```
输入：[1,2,5,9,5,9,5,5,5]
输出：5
```

示例 2：

```
输入：[3,2]
输出：-1
```

示例 3：

```
输入：[2,2,1,1,1,2,2]
输出：2
```

### 代码

- 摩尔投票

```python
class Solution:
    def majorityElement(self, nums: List[int]) -> int:
        major = -1
        count = 0
        for num in nums:
            # 这个判断必须要放在前面
            if count == 0:
                major = num
            if num == major:
                count += 1
            else:
                count -= 1
        count = 0
        for num in nums:
            if num == major:
                count += 1
        return major if count > len(nums) // 2 else -1
```

### 笔记

- 摩尔投票算法：第一遍找到可能为众数的那个数，主要就是找到major，第一遍遍历完，那个count就没有意义了。第二遍再确定第一遍找到的那个major在数组中的个数是不是大于一半。

## [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

难度：中等:star::star::star::star:

### 题目

给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

 

示例 1:

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

示例 2:

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

示例 3:

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```


示例 4:

```
输入: s = ""
输出: 0
```


提示：

- 0 <= s.length <= 5 * 10^4^
- s 由英文字母、数字、符号和空格组成

### 代码

- 暴力解法

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        p = 0
        sub_s = []
        len_s = len(s)
        len_sub = 0
        while p < len(s):
            if s[p] not in sub_s:
                sub_s.append(s[p])
                p += 1
            else:
                sub_s = sub_s[sub_s.index(s[p]) + 1:]
                sub_s.append(s[p])
                p += 1
            if len(sub_s) > len_sub:
                len_sub = len(sub_s)

        return len_sub
```

- 简化代码

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        p = 0
        sub_s = []
        len_s = len(s)
        len_sub = 0
        while p < len(s):
            if s[p] in sub_s:
                sub_s = sub_s[sub_s.index(s[p]) + 1:]
            sub_s.append(s[p])
            p += 1
            if len(sub_s) > len_sub:
                len_sub = len(sub_s)

        return len_sub
```

- 滑动窗口

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        left, right = 0, 0
        sub_set = set()
        s_len = len(s)
        sub_len = 0
        while left < s_len:
            while right < s_len and s[right] not in sub_set:
                sub_set.add(s[right])
                right += 1
            sub_len = max(sub_len, right - left)
            sub_set.remove(s[left])
            left += 1
        return sub_len
```

- 滑动窗口

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int n = s.length();
        if (n == 1) {
            return 1;
        }
        HashMap<Character, Integer> map = new HashMap<>();
        int left = 0;
        int right = 0;
        int res = 0;
        while(right < n) {
            char c1 = s.charAt(right);
            right++;
            map.put(c1, map.getOrDefault(c1, 0) + 1);
            // 收缩窗口时是出现重复字符
            while(map.get(c1) > 1) {
                char c2 = s.charAt(left);
                left++;
                map.put(c2, map.get(c2) - 1);
            }
            // 收缩完之后是没有重复字符，所以在这里更新res
            res = Math.max(right - left, res);
        }
        return res;
    }
}
```





### 笔记

- 注意：s[p]在sub_s中时，要把sub_s中从开始到s[p]的字符都删掉，只保留s[p]后面的一部分。

## [567. 字符串的排列](https://leetcode-cn.com/problems/permutation-in-string/)

难度：中等:star::star::star::star:

### 题目

给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。

换句话说，s1 的排列之一是 s2 的 子串 。

 

示例 1：

```
输入：s1 = "ab" s2 = "eidbaooo"
输出：true
解释：s2 包含 s1 的排列之一 ("ba").
```

示例 2：

```
输入：s1= "ab" s2 = "eidboaoo"
输出：false
```


提示：

- 1 <= s1.length, s2.length <= 10^4^
- s1 和 s2 仅包含小写字母

### 代码

- 滑动窗口

```python
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        s1_len, s2_len = len(s1), len(s2)
        if s1_len > s2_len:
            return False
        
        s1_count, s2_count = [0] * 26, [0] * 26

        for i in range(s1_len):
           s1_count[ord(s1[i]) - ord('a')] += 1
           s2_count[ord(s2[i]) - ord('a')] += 1
        if s1_count == s2_count:
            return True
        
        for i in range(s1_len, s2_len):
            s2_count[ord(s2[i]) - ord('a')] += 1
            s2_count[ord(s2[i - s1_len]) - ord('a')] -= 1
            if s1_count == s2_count:
                return True
        return False
```

- 滑动窗口优化

```python
class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        s1_len, s2_len = len(s1), len(s2)
        if s1_len > s2_len:
            return False
        
        s_count = [0] * 26

        for i in range(s1_len):
           s_count[ord(s1[i]) - ord('a')] -= 1
           s_count[ord(s2[i]) - ord('a')] += 1
        
        diff = 0
        for i in range(26):
            if s_count[i] != 0:
                diff += 1
        if diff == 0:
            return True
        for i in range(s1_len, s2_len):
            x, y = ord(s2[i]) - ord('a'), ord(s2[i - s1_len]) - ord('a')
            if x == y:
                continue
            
            if s_count[x] == 0:
                diff += 1
            s_count[x] += 1
            if s_count[x] == 0:
                diff -= 1
            if s_count[y] == 0:
                diff += 1
            s_count[y] -= 1
            if s_count[y] == 0:
                diff -= 1

            if diff == 0:
                return True
        return False
```

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int m = s1.length();
        int n = s2.length();
        if (m > n) {
            return false;
        }
        HashMap<Character, Integer> map1 = new HashMap<>();
        HashMap<Character, Integer> map2 = new HashMap<>();
        for(int i = 0; i < m; i++) {
            map1.put(s1.charAt(i), map1.getOrDefault(s1.charAt(i), 0) + 1);
        }
        int left = 0;
        int right = 0;
        int count = 0;
        while (right < n) {
            char c1 = s2.charAt(right);
            right++;
            if (map1.containsKey(c1)) {
                map2.put(c1, map2.getOrDefault(c1, 0) + 1);
                // map的值是Integer类型，比较用equals
                if (map2.get(c1).equals(map1.get(c1))) {
                    count++;
                }
            }
            // 控制窗口大小为m
            while(right-left == m) {
                // 在窗口大小为m里面，个数都一样
                if (count == map1.size()) {
                    return true;
                }
                char c2 = s2.charAt(left);
                left++;
                if (map1.containsKey(c2)) {
                    // map的值是Integer类型，比较用equals
                    if (map2.get(c2).equals(map1.get(c2))) {
                        count--;
                    }
                    map2.put(c2, map2.get(c2) - 1);
                }
            }
        }
        return false;
    }
}
```

- 滑动窗口-两个数组

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int m = s1.length();
        int n = s2.length();
        if (m > n) {
            return false;
        }
        // 仅包含小写字母，可以用数组替代
        int[] map1 = new int[26];
        int[] map2 = new int[26];
        int num1 = 0;
        for(int i = 0; i < m; i++) {
            map1[s1.charAt(i) - 'a']++;
            if (map1[s1.charAt(i) - 'a'] == 1) {
                num1++;
            }
        }
        int left = 0;
        int right = 0;
        int num2 = 0;
        while(right < n) {
            char c1 = s2.charAt(right);
            right++;
            if (map1[c1 - 'a'] != 0) {
                map2[c1 - 'a']++;
                if (map2[c1- 'a'] == map1[c1 - 'a']) {
                    num2++;
                }
            }
            while (right - left == m) {
                if (num2 == num1) {
                    return true;
                }
                char c2 = s2.charAt(left);
                left++;
                if (map1[c2 - 'a'] != 0) {
                    if (map2[c2- 'a'] == map1[c2 - 'a']) {
                        num2--;
                    }
                    map2[c2 - 'a']--;
                }
            }
        }
        return false;
        
    }
}
```

- 滑动窗口-一个数组

```java
class Solution {
    public boolean checkInclusion(String s1, String s2) {
        int m = s1.length();
        int n = s2.length();
        if (m > n) {
            return false;
        }
        // 仅包含小写字母，可以用数组替代
        int[] map = new int[26];
        for(int i = 0; i < m; i++) {
            map[s1.charAt(i) - 'a']++;
        }
        int left = 0;
        int right = 0;
        while(right < n) {
            char c1 = s2.charAt(right);
            map[c1 - 'a']--;
            right++;
            while (map[c1 - 'a'] < 0) {
                char c2 = s2.charAt(left);
                map[c2 - 'a']++;
                left++;
            }
            // 出上面的循环就表示从left到right的对应的map中的值都是0，说明能够匹配s1中的一些字符,
            // 如果这时right和left之间的距离刚好也是s1的长度，那就说明找到了一个排列
            if (right - left == m) {
                return true;
            }
        }
        return false;
        
    }
}
```



### 笔记

- 值得学习的小技巧：
  - 将字母映射到0-25这26个索引值，每个索引值就对应一个字母，改变对应索引下的值就可以统计每个字母的个数。（忽略大小写）
  - 滑动窗口的基本思想是：进一个，出一个，维护一个固定大小的窗口，然后针对这个固定大小的窗口进行比较（这个比较过程也是一个可以优化的部分，因为每次只进一个，出一个，可以不比较整个窗口）。

- 本题还要注意一点：题目没有说s1的长度一定比s2要小，所以要判断一下。

  **遇到两个字符串之间的相关算法，要记得看看要不要判断两个字符串的长度关系**



## [733. 图像渲染](https://leetcode-cn.com/problems/flood-fill/)

难度：简单:star::star::star:

### 题目

有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。

给你一个坐标` (sr, sc) `表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 `newColor`，让你重新上色这幅图像。

为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。

最后返回经过上色渲染后的图像。

示例 1:

```
输入: 
image = [[1,1,1],[1,1,0],[1,0,1]]
sr = 1, sc = 1, newColor = 2
输出: [[2,2,2],[2,2,0],[2,0,1]]
解析: 
在图像的正中间，(坐标(sr,sc)=(1,1)),
在路径上所有符合条件的像素点的颜色都被更改成2。
注意，右下角的像素没有更改为2，
因为它不是在上下左右四个方向上与初始点相连的像素点。
```


注意:

- `image `和` image[0]` 的长度在范围` [1, 50]` 内。
- 给出的初始点将满足` 0 <= sr < image.length` 和 `0 <= sc < image[0].length`。
- `image[i][j] `和 `newColor `表示的颜色值在范围` [0, 65535]`内。

### 代码

- 广度优先搜索

```python
class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        from collections import deque

        if newColor == image[sr][sc]:
            return image
        
        d = deque()
        # 上下左右
        directions = {(-1, 0), (1, 0), (0, -1), (0, 1)} # 集合

        d.append((sr, sc))
        originalColor = image[sr][sc]

        while len(d):
            point = d.popleft()
            r, c = point[0], point[1]
            image[r][c] = newColor
            for direction in directions:
                new_r = r + direction[0]
                new_c = c + direction[1]
                if (0 <= new_r < len(image)) and (0 <= new_c < len(image[0])) and (image[new_r][new_c] == originalColor):
                    d.append((new_r, new_c))
        return image
```

- 递归-深度优先搜索

```python
class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        m, n = len(image), len(image[0])
        originalColor =  image[sr][sc]
        directions = {(-1, 0), (1, 0), (0, -1), (0, 1)}

        def dfs(x: int, y: int):
            if 0 <= x < m and 0 <= y < n and image[x][y] == originalColor:
                image[x][y] = newColor
                for direction in directions:
                    dfs(x + direction[0], y + direction[1])
        


        if newColor != image[sr][sc]:
            dfs(sr, sc)
        return image

```

- BFS-避免重复添加

```python
class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        from collections import deque

        if newColor == image[sr][sc]:
            return image
        
        d = deque()
        # 上下左右
        directions = {(-1, 0), (1, 0), (0, -1), (0, 1)} # 集合
        visited = set()

        d.append((sr, sc))
        originalColor = image[sr][sc]
        visited.add((sr, sc))

        while len(d):
            point = d.popleft()
            r, c = point[0], point[1]
            image[r][c] = newColor
            for direction in directions:
                new_r = r + direction[0]
                new_c = c + direction[1]
                if ((new_r, new_c) not in visited) and (0 <= new_r < len(image)) and (0 <= new_c < len(image[0])) and (image[new_r][new_c] == originalColor):
                    d.append((new_r, new_c))
                    visited.add((new_r, new_c))
        return image
```

- 栈-深度优先搜索

```python
class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
        m, n = len(image), len(image[0])
        originalColor =  image[sr][sc]
        directions = {(-1, 0), (1, 0), (0, -1), (0, 1)}
        stack = []
        
        if newColor == originalColor:
            return image
        
        stack.append((sr, sc))
        while stack:
            x, y = stack.pop()
            if 0 <= x < m and 0 <= y < n and image[x][y] == originalColor:
                image[x][y] = newColor
                for direction in directions:
                    stack.append((x + direction[0], y + direction[1]))
        return image
```

### 笔记

- 深度优先搜索（DFS）：和栈密切相关。有递归版本和使用栈的版本。
  基于递归的DFS：从起点开始，判断起点是否符合条件，符合条件，（符合条件的话就可以执行一些操作了），开始for循环，往一个方向开始递归，得到一个该方向上的点，判断是否符合条件，（……），开始for循环，……，不符合条件的话会从这个点（已经在一个方向上到了底的点）往第二个方向，第三个方向，……。

- 广度优先搜索（BFS）：和队列紧密相连。
  首先将起点添加到队列，然后当队列不为空时开始循环循环，将队首元素出队，（出队后，对这个出队的元素执行一些操作），然后将与其相邻的元素（满足一定条件）入队。每次出一个，入好几个。

  由于BFS需要将元素入队，为了避免未被访问过的元素重复入队，通常会使用`visited = set()`来记录访问过的点

- 队列：Python中可以使用deque()，参考链接：[https://docs.python.org/zh-cn/3/library/collections.html#collections.deque](https://docs.python.org/zh-cn/3/library/collections.html#collections.deque)
  示例：
  ```python
  from collections import deque
  d = deque()
  d.append('a') # 从右端入队
  d.popleft() # 从左端出队
  ```
  deque()是双向队列，使用时可以当单向队列来用。

- 栈：在python中直接用列表list()代替即可。
  示例：
  
  ```python
  stack = []
  stack.append('a') # 从尾部入栈
  stack.pop() # 从尾部出栈
  ```

## [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

难度：中等:star::star::star::star:

### 题目

给定一个包含了一些 0 和 1 的非空二维数组 grid 。

一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。

找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)

 

示例 1:

```
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,1,1,0,1,0,0,0,0,0,0,0,0],
 [0,1,0,0,1,1,0,0,1,0,1,0,0],
 [0,1,0,0,1,1,0,0,1,1,1,0,0],
 [0,0,0,0,0,0,0,0,0,0,1,0,0],
 [0,0,0,0,0,0,0,1,1,1,0,0,0],
 [0,0,0,0,0,0,0,1,1,0,0,0,0]]
```


对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。

示例 2:

```
[[0,0,0,0,0,0,0,0]]
```


对于上面这个给定的矩阵, 返回 0。

 

**注意:** 给定的矩阵grid 的长度和宽度都不超过 50。

### 代码

- 广度优先搜索

```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        from collections import deque

        m, n = len(grid), len(grid[0])
        count = 0
        ans = 0

        d = deque()
        directions = {(-1, 0), (1, 0), (0, -1), (0, 1)}
        # visited = set()

        for i in range(m):
           for j in range(n):
                d.append((i, j))

                while d:
                    x, y = d.popleft()
                    if 0 <= x < m and 0 <= y < n and grid[x][y]:
                        count += 1
                        for direction in directions:
                            next_x, next_y = x + direction[0], y + direction[1]
                            d.append((next_x, next_y))
                        grid[x][y] = 0
                ans = max(count, ans)
                count = 0
        return ans
```

- 递归-深度优先遍历

```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:

        m, n = len(grid), len(grid[0])
        ans = 0

        directions = {(-1, 0), (1, 0), (0, -1), (0, 1)}

        def dfs(x: int, y: int) -> int:
            count = 0
            if 0 <= x < m and 0 <= y < n and grid[x][y]:
                count = 1
                grid[x][y] = 0
                for direction in directions:
                    next_x, next_y = x + direction[0], y + direction[1]
                    count += dfs(next_x, next_y)
            return count
        
        # 还是得一个一个的遍历
        for i in range(m):
           for j in range(n):
                # 对每一个都进行一个DFS
                ans = max(ans, dfs(i, j))
        return ans
```

- 栈-深度优先遍历

```python
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:

        m, n = len(grid), len(grid[0])
        ans = 0

        directions = {(-1, 0), (1, 0), (0, -1), (0, 1)}
        stack = []

        # 还是得一个一个的遍历
        for i in range(m):
           for j in range(n):
                # 对每一个都进行一个DFS
                count = 0
                stack.append((i, j))
                while stack:
                    x, y = stack.pop()
                    if 0 <= x < m and 0 <= y < n and grid[x][y]:
                        count += 1
                        grid[x][y] = 0
                        for direction in directions:
                            next_x, next_y = x + direction[0], y + direction[1]
                            stack.append((next_x, next_y))
                ans = max(ans, count)
        return ans

```

### 笔记

- 沉岛思想：每次找到岛屿，则直接把找到的岛屿改成0，这是传说中的沉岛思想，就是遇到岛屿就把它沉没。
- 还是得一个一个的遍历，对每一个都进行一个BFS或DFS，但只有是1的时候，才往周围四个方向找。

## [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

难度：简单:star::star::star:

### 题目

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则**不为** NULL 的节点将直接作为新二叉树的节点。

示例 1:

```
输入: 
	Tree 1                     Tree 2                  
          1                         2                             
         / \                       / \                            
        3   2                     1   3                        
       /                           \   \                      
      5                             4   7                  
输出: 
合并后的树:
	     3
	    / \
	   4   5
	  / \   \ 
	 5   4   7
```

**注意:** 合并必须从两个树的根节点开始。

### 代码

- 广度优先遍历

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        from collections import deque

        if root1 is None:
            return root2
        if root2 is None:
            return root1

        merge = TreeNode()
        queue1 = deque()
        queue2 = deque()
        queue = deque()

        queue1.append(root1)
        queue2.append(root2)
        queue.append(merge)

        while queue1 and queue2:
            node1 = queue1.popleft()
            node2 = queue2.popleft()
            node = queue.popleft()

            node.val = node1.val + node2.val

            left1, right1 = node1.left, node1.right
            left2, right2 = node2.left, node2.right

            if left1 and left2:
                node_l = TreeNode()
                node.left = node_l
                queue1.append(left1)
                queue2.append(left2)
                queue.append(node_l)
            elif left1:
                node.left = left1
            elif left2:
                node.left = left2
            
            if right1 and right2:
                node_r = TreeNode()
                node.right = node_r
                queue1.append(right1)
                queue2.append(right2)
                queue.append(node_r)
            elif right1:
                node.right = right1
            elif right2:
                node.right = right2
        
        return merge
```

- 递归-深度优先遍历

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        if root1 is None:
            return root2
        if root2 is None:
            return root1

        def dfs(tree1: TreeNode, tree2: TreeNode) -> TreeNode:
            if tree1 and tree2:
                tree1.val = tree1.val + tree2.val
                tree1.left = dfs(tree1.left, tree2.left)
                tree1.right = dfs(tree1.right, tree2.right)
            elif tree2:
                tree1 = tree2
            return tree1
        
        root1 = dfs(root1, root2)
        
        return root1
```

- 栈-深度优先遍历

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def mergeTrees(self, root1: TreeNode, root2: TreeNode) -> TreeNode:
        if not root1:
            return root2
        if not root2:
            return root1

        stack1 = []
        stack2 = []

        stack1.append(root1)
        stack2.append(root2)

        while stack1 and stack2:
            node1 = stack1.pop()
            node2 = stack2.pop()

            node1.val += node2.val

            if node1.right and node2.right:
                stack1.append(node1.right)
                stack2.append(node2.right)
            elif node2.right:
                node1.right = node2.right

            if node1.left and node2.left:
                stack1.append(node1.left)
                stack2.append(node2.left)
            elif node2.left:
                node1.left = node2.left
            
        return root1
```

### 笔记

- 二叉树中，对左右子树的操作通常是相同的，所以可以先只考虑对左边子树的操作，然后对右边子树的操作照着左边写即可。
- 二叉树中的DFS和BFS：
  - 递归-深度优先搜索：先递归左子树，再递归右子树。
  - 广度优先搜索：分左右添加到队列。
- 合并的关键部分：
  合并到一个：`tree1 = tree2`，一个为空的话，直接另一个的（当前）根节点接过来，相当于把整个子树都接过来。
  新建一个树：`node.left = left1`，`node.left = left2`，`node.right = right1`，`node.right = right2`。

## [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

难度：中等:star::star::star::star:

给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```


填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

 

进阶：

- 你只能使用常量级额外空间。
- 使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。

示例：

![img](noteImage/116_sample.png)

```
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
```


提示：

- 树中节点的数量少于 4096
- -1000 <= node.val <= 1000

### 代码

- 暴力解法

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""

class Solution:
    def connect(self, root: 'Node') -> 'Node':
        from collections import deque

        queue = deque()
        l = []
        if not root:
            return root
        queue.append(root)
        l.append(root)
        while queue:
            node = queue.popleft()
            if node.left and node.right:
                queue.append(node.left)
                queue.append(node.right)
                l.append(node.left)
                l.append(node.right)
        j = 1
        for i in range(len(l)):
            if i == 2**j - 2:
                l[i].next = None
                j += 1
            else:
                l[i].next = l[i+1]
            
        
        # l[0].next = None
        # l[1].next = l[2]
        # l[2].next = None
        # l[3].next = l[4]
        # l[4].next = l[5]
        # l[5].next = l[6]
        # l[6].next = None

        return root
```

- 层次遍历

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""

class Solution:
    def connect(self, root: 'Node') -> 'Node':
        from collections import deque

        if not root:
            return root

        queue = deque()
        queue.append(root)
       
        while queue:
            size = len(queue)
            for i in range(size):
                node = queue.popleft()
                # 每一层最右边的结点的next默认就为空，不用更新
                if i < size - 1:
                    # 使用queue[0]可以快速访问队列的首个元素
                    node.next = queue[0]
                if node.left and node.right:
                    queue.append(node.left)
                    queue.append(node.right)

        return root
```

- 递归-深度优先搜索

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""

class Solution:
    def connect(self, root: 'Node') -> 'Node':

        if not root:
            return root

        def dfs(node: 'Node', nextnode: 'Node'):
            if not node:
                return None
            node.next = nextnode
            if node.left and node.right:
                dfs(node.left, node.right)
                dfs(node.right, node.next.left if node.next else None )
        
        dfs(root, None)
            

        return root
```

- 进阶版

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""

class Solution:
    def connect(self, root: 'Node') -> 'Node':

        if not root:
            return root

        leftmost = root
        while leftmost.left:
            head = leftmost
            while head:
                head.left.next = head.right
                if head.next:
                    head.right.next = head.next.left
                head = head.next
            leftmost = leftmost.left
            

        return root
```

### 笔记

- 暴力解法：先通过BFS将所有结点添加到一个列表中，然后再对列表中每个结点的next作出相应的修改。二叉树最右边的结点在列表中的索引是2^n^-2，n为该节点所在的层数，满足这个索引的，就把它的next=None,不是最右边的结点，next就等于它的下一个节点
- 层次遍历：使用一个size记录当前层的结点个数，再使用for循环来遍历并连接。每一层最右边的结点的next默认就为空，不用更新。使用queue[0]可以快速访问队列的首个元素
- 递归-深度优先遍历：同一个父节点，则左节点的next=右节点。不同父节点，右节点指向相邻的左节点，即该右节点的父节点的右节点的左孩子。
  利用了上一层已经建立的next，来找下一层中相邻的右节点和左节点。

## [542. 01 矩阵](https://leetcode-cn.com/problems/01-matrix/)

难度：中等:star::star::star::star:

### 题目

给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。

两个相邻元素间的距离为 1 。

 

示例 1：

![img](noteImage/1626667201-NCWmuP-image.png)

```
输入：mat = [[0,0,0],[0,1,0],[0,0,0]]
输出：[[0,0,0],[0,1,0],[0,0,0]]
```

示例 2：

![img](noteImage/1626667205-xFxIeK-image.png)

```
输入：mat = [[0,0,0],[0,1,0],[1,1,1]]
输出：[[0,0,0],[0,1,0],[1,2,1]]
```


提示：

- m == mat.length
- n == mat[i].length
- 1 <= m, n <= 10^4^
- 1 <= m * n <= 10^4^
- mat[i][j] is either 0 or 1.
- mat 中至少有一个 0 

### 代码

- 广度优先搜索

```python
class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        from collections import deque

        queue = deque()
        visited = set()
        m, n = len(mat), len(mat[0])
        directions = {(-1, 0), (1, 0), (0, -1), (0, 1)}

        # 把所有的0入队，当成一个整体
        for i in range(m):
            for j in range(n):
                if mat[i][j] == 0:
                    queue.append((i, j))
                    visited.add((i, j))
        
        while queue:
            x, y = queue.popleft()
            for direction in directions:
                nextx, nexty = x + direction[0], y + direction[1]
                # 所有的0已经入队了，这里再往四个方向上搜索的时候就是到了1的位置
                if (nextx, nexty) not in visited and 0 <= nextx < m and 0 <= nexty < n:
                    # 从0到达的1，那么距离就是1，再从1到达1的，距离就是2，...
                    mat[nextx][nexty] = mat[x][y] + 1
                    queue.append((nextx, nexty))
                    visited.add((nextx, nexty))
        return mat
```

- 动态规划

```python
class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        m, n = len(mat), len(mat[0])
        dist = [[m + n] * n for _ in range(m)]

        for i in range(m):
            for j in range(n):
                if mat[i][j] == 0:
                    dist[i][j] = 0
        # 往左上方向找。j,i往右下方向变化
        for i in range(m):
            for j in range(n):
                # 往上
                if i - 1 >= 0:
                    dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1)
                # 往左
                if j - 1 >= 0:
                    dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1)

        # 往右上方向找。j,i往左下方向变化
        for i in range(m):
            for j in range(n - 1, -1, -1):
                # 往上
                if i - 1 >= 0:
                    dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1)
                # 往右
                if j + 1 < n:
                    dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1)

        # 往左下方向找。j,i往右上方向变化
        for i in range(m - 1, -1, -1):
            for j in range(n):
                # 往下
                if i + 1 < m:
                    dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1)
                # 往左
                if j - 1 >= 0:
                    dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1)
        
        # 往右下方向找。j,i往左上方向变化
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                # 往下
                if i + 1 < m:
                    dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1)
                # 往右
                if j + 1 < n:
                    dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1)
        return dist
```

- 简化动态规划

```python
class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        m, n = len(mat), len(mat[0])
        dist = [[m + n] * n for _ in range(m)]

        for i in range(m):
            for j in range(n):
                if mat[i][j] == 0:
                    dist[i][j] = 0
        
        # # 或者不用这个
        # # 往左上方向找。j,i往右下方向变化
        # for i in range(m):
        #     for j in range(n):
        #         # 往上
        #         if i - 1 >= 0:
        #             dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1)
        #         # 往左
        #         if j - 1 >= 0:
        #             dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1)

        # 可以不用这个
        # 往右上方向找。j,i往左下方向变化
        for i in range(m):
            for j in range(n - 1, -1, -1):
                # 往上
                if i - 1 >= 0:
                    dist[i][j] = min(dist[i][j], dist[i - 1][j] + 1)
                # 往右
                if j + 1 < n:
                    dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1)

        # 可以不用这个
        # 往左下方向找。j,i往右上方向变化
        for i in range(m - 1, -1, -1):
            for j in range(n):
                # 往下
                if i + 1 < m:
                    dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1)
                # 往左
                if j - 1 >= 0:
                    dist[i][j] = min(dist[i][j], dist[i][j - 1] + 1)
        
        # # 或者不用这个
        # # 往右下方向找。j,i往左上方向变化
        # for i in range(m - 1, -1, -1):
        #     for j in range(n - 1, -1, -1):
        #         # 往下
        #         if i + 1 < m:
        #             dist[i][j] = min(dist[i][j], dist[i + 1][j] + 1)
        #         # 往右
        #         if j + 1 < n:
        #             dist[i][j] = min(dist[i][j], dist[i][j + 1] + 1)

        return dist
```

### 笔记

- 逆向思维：找到1到最近的0，处理起来比较麻烦，尤其是1比较多，0比较少的时候。可以换个思路，找到0最近的1。比如说，一个0上下左右（是1的元素）到0的距离为1，那么上（、下、左、右这个元素）的上下左右到这个0的距离就是2，再往四个方向上走一层，距离就是3。这样处理起来就比较简单。
- 多源点最短路径问题中的一个常见思想：添加一个超级源点，将多源点连接到这个超级源点上，或者把多源点当成一个整体。这里就是把0当做起点，1当做终点，找出每个终点到最近的起点的距离。
  在最短路问题中，如果我们要求多个源点出发的最短路时，一般我们都会建立一个「超级源点」连向所有的源点，用「超级源点」到终点的最短路等价多个源点到终点的最短路。

## [994. 腐烂的橘子](https://leetcode-cn.com/problems/rotting-oranges/)

难度：中等:star::star::star::star:

### 题目

在给定的网格中，每个单元格可以有以下三个值之一：

- 值 0 代表空单元格；
- 值 1 代表新鲜橘子；
- 值 2 代表腐烂的橘子。

每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。

返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。

 

示例 1：

![img](noteImage/oranges.png)

```
输入：[[2,1,1],[1,1,0],[0,1,1]]
输出：4
```

示例 2：

```
输入：[[2,1,1],[0,1,1],[1,0,1]]
输出：-1
解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。
```

示例 3：

```
输入：[[0,2]]
输出：0
解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。
```


提示：

- 1 <=` grid.length` <= 10
- 1 <=` grid[0].length` <= 10
- `grid[i][j]` 仅为 0、1 或 2

### 代码

```python
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        from collections import deque

        queue = deque()
        m, n = len(grid), len(grid[0])
        visited = set()
        directions = {(-1, 0), (1, 0), (0, -1), (0, 1)}

        # 把所有的2先放入队列，后面一起扩散
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 2:
                    queue.append((i, j))
                    visited.add((i, j))
        
        count = 0
        while queue:
            flag = False
            size = len(queue)
            # 一次搜索完队列中所有为2的
            while size > 0:
                x, y = queue.popleft()
                size -= 1
                for direction in directions:
                    nextx, nexty = x + direction[0], y + direction[1]
                    if (nextx, nexty) not in visited and 0 <= nextx < m and 0 <= nexty < n and grid[nextx][nexty] == 1:
                        # 把找到了的改为2
                        grid[nextx][nexty] = 2
                        # 说明这一次搜索腐烂过橘子
                        flag = True
                        queue.append((nextx, nexty))
                        visited.add((nextx, nexty))
            # 只有腐烂过橘子才把这一次搜索记为有效的
            if flag:
                count += 1
        # 搜索完成后，如果还有为1的，就那个1搜索不到
        for i in range(m):
            if 1 in grid[i]:
                return -1
        return count
```

### 笔记

- 使用【超级源点】的思路，把最开始所有腐烂的橘子当成整体，一起扩散。一下次扩散的时候也是把上一次扩散感染的橘子当成整体，一起扩散。

## [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

难度：简单:star::star::star:

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例 1：

![img](noteImage/merge_ex1.jpg)

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

示例 2：

```
输入：l1 = [], l2 = []
输出：[]
```

示例 3：

```
输入：l1 = [], l2 = [0]
输出：[0]
```


提示：

- 两个链表的节点数目范围是 [0, 50]
- -100 <= Node.val <= 100
- l1 和 l2 均按 **非递减顺序** 排列

### 代码

- 暴力解法一

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        merge = []
        while l1:
            merge.append(l1.val)
            l1 = l1.next
        while l2:
            merge.append(l2.val)
            l2 = l2.next
        merge.sort()
        if not merge:
            return l1
        mergel = ListNode()
        p = mergel
        for i in merge[:-1]:
            p.val = i
            p.next = ListNode()
            p = p.next
        p.val = merge[-1]
        return mergel
```

- 暴力解法二

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1:
            return l2
        elif not l2:
            return l1
        
        m = ListNode()
        merge = m
        while l1 and l2:
            if l1.val <= l2.val:
                m.val = l1.val
                l1 = l1.next
            else:
                m.val = l2.val
                l2 = l2.next
            m.next = ListNode()
            m = m.next
        if not l1:
            m.val = l2.val
            m.next = l2.next
        elif not l2:
            m.val = l1.val
            m.next = l1.next
        return merge
```

- 穿针引线法

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1:
            return l2
        elif not l2:
            return l1
        m = ListNode()
        merge = m
        while l1 and l2:
            if l1.val <= l2.val:
                m.next = l1
                l1 = l1.next
            else:
                m.next = l2
                l2 = l2.next
            m = m.next
        if not l1:
            m.next = l2
        elif not l2:
            m.next = l1
        return merge.next
```

- 递归解法

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1:
            return l2
        elif not l2:
            return l1
        elif l1.val <= l2.val:
            l1.next = self.mergeTwoLists(l1.next, l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1, l2.next)
            return l2
```

### 笔记

- 穿针引线法：新建一个头结点，然后把l1和l2中小的那个接到m的后面，只需要不断修改m的next即可，不需要新建多余的结点，直接让m.next指向已存在的结点
- 递归解法还是很值得学习的。
  l1: 1->2->3
  l2: 1->3->4
  递归的过程是这样的：如果`l1.val <= l2.val`，那就把l2拼接到l1上，也就是把l2拼接到l1.next上，即：`l1.next = self.mergeTwoLists(l1.next, l2)`
  如果`l1.val > l2.val`，那就把l1拼接到l2上，也就是把l1拼接到l2.next上，即：`l2.next = self.mergeTwoLists(l1, l2.next)`

## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

难度：简单:star::star::star:

### 题目

给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。

示例 1：

![img](noteImage/rev1ex1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

示例 2：

![img](noteImage/rev1ex2.jpg)

```
输入：head = [1,2]
输出：[2,1]
```

示例 3：

```
输入：head = []
输出：[]
```


提示：

- 链表中节点的数目范围是 [0, 5000]
- -5000 <= Node.val <= 5000

**进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？

### 代码

- 头插法建立新链表

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        dumb = ListNode()
        while head:
            t = head.next
            head.next = dumb.next
            dumb.next = head
            head = t
        return dumb.next
```

- 递归

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        if not head or not head.next:
            return head
        newhead = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return newhead
```

### 笔记

- 头插法，但是不需要新建太多结点，只需要修改指针即可

  递归解法：很巧妙，`head.next.next = head`这个可以实现指针翻转的效果

- 递归解法：递归解题首先要做的是明确递推公式的含义，在这里对于结点1来说，它只需要知道它之后的所有节点反转之后的结果就可以了，也就是说递推公式reverseList的含义是：把拿到的链表进行反转，然后返回新的头结点。
  接着要做的就是反转结点1，也就是将head指向的结点作为其下一个结点的下一个结点，即head.next.next=head。
  作者：hardcore-aryabhata
  链接：https://leetcode-cn.com/problems/reverse-linked-list/solution/yi-bu-yi-bu-jiao-ni-ru-he-yong-di-gui-si-67c3/

## [77. 组合](https://leetcode-cn.com/problems/combinations/)

难度：中等:star::star::star::star:

### 题目

给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。

你可以按 **任何顺序** 返回答案。

 

示例 1：

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

示例 2：

```
输入：n = 1, k = 1
输出：[[1]]
```


提示：

- 1 <= n <= 20
- 1 <= k <= n

### 代码

- Python一行代码

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        return list(itertools.combinations(range(1, n+1), k))
```

- 改写`itertools.combinations()`的源码

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        result = []
        pool = tuple(range(1, n+1))
        if k > n:
            return
        indices = list(range(k))
        result.append(list(pool[i] for i in indices))
        # yield tuple(pool[i] for i in indices)

        while True:
            for i in reversed(range(k)):
                if indices[i] != i + n - k:
                    break
            else:
                return result
            indices[i] += 1
            for j in range(i+1, k):
                indices[j] = indices[j-1] + 1
            result.append(list(pool[i] for i in indices))
            # yield tuple(pool[i] for i in indices)
```

- 回溯法（深度优先搜索）

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        result = []
        temp = []
        def dfs(n: int, k: int, start: int):
            if len(temp) == k:
                # 这里要添加temp的副本，否则之后的pop()和append()操作会影响这里的temp
                result.append(temp[:])
                return
            for i in range(start, n+1):
                temp.append(i)
                dfs(n, k, i + 1)
                temp.pop()
            
            
        dfs(n, k, 1)
        return result
```

- 回溯+剪枝

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        result = []
        temp = []
        def dfs(n: int, k: int, start: int):
            if len(temp) == k:
                # 这里要添加temp的副本，否则之后的pop()和append()操作会影响这里的temp
                result.append(temp[:])
                return
            
            for i in range(start, n - (k - len(temp)) + 2):
                temp.append(i)
                dfs(n, k, i + 1)
                temp.pop()
            
            
        dfs(n, k, 1)
        return result
```

- 回溯

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combine(int n, int k) {
        List<Integer> path = new ArrayList<>();
        backtrack(n, k, 1, path);
        return res;
    }
    public void backtrack(int n, int k, int start, List<Integer> path) {
        if (k == 0) {
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = start; i <= n; i++) {
            path.add(i);
            backtrack(n, k - 1, i + 1, path);
            path.remove(path.size() - 1);
        }
    }
}
```

- 回溯+剪枝

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combine(int n, int k) {
        List<Integer> path = new ArrayList<>();
        backtrack(n, k, 1, path);
        return res;
    }
    public void backtrack(int n, int k, int start, List<Integer> path) {
        if (k == path.size()) {
            res.add(new ArrayList<>(path));
            return;
        }
        for(int i = start; i <= n - (k - path.size()) + 1; i++) {
            path.add(i);
            backtrack(n, k, i + 1, path);
            path.remove(path.size() - 1);
        }
    }
}
```



### 笔记

- 改写itertools.combinations()的源码:
  [https://docs.python.org/3/library/itertools.html#itertools.combinations](https://docs.python.org/3/library/itertools.html#itertools.combinations)

- 回溯法：
  代码框架：
  ```python
  result = []
  def backtrack(路径, 选择列表):
      if 满足结束条件:
          result.add(路径)
          return
  
      for 选择 in 选择列表:
          做选择
          backtrack(路径, 选择列表)
          撤销选择
  ```
  其中for循环的部分的选择列表可以做剪枝。

- 回溯法：可以自己画个树来帮助理解dfs的过程。

- 剪枝：画出回溯法的树之后，可以看出那些搜索是可以剪枝的。剪枝部分主要修改做选择的那个for循环的选择列表。注意，这个选择列表的范围的缩减与搜索起点、当前还需要选几个数、已经选了几个数有关。
  比如：从当前起点到结束的元素个数 >= 总共需要的个数-已经有的个数
  也即：`n - start + 1 >= k - len(path)`

## [46. 全排列](https://leetcode-cn.com/problems/permutations/)

难度：中等:star::star::star::star:

### 题目

给定一个不含重复数字的数组 nums ，返回其 **所有可能的全排列** 。你可以 **按任意顺序** 返回答案。

 

示例 1：

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

示例 2：

```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

示例 3：

```
输入：nums = [1]
输出：[[1]]
```


提示：

- 1 <= nums.length <= 6
- -10 <= nums[i] <= 10
- nums 中的所有整数 互不相同

### 代码

- 回溯法

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        n = len(nums)
        result = []
        path = []


        def backtrack(nums: List[int]):
            if len(path) == n:
                result.append(path[:])
                return

            for i in range(n):
                if nums[i] not in path:
                    path.append(nums[i])
                    backtrack(nums)
                    path.pop()
        
        backtrack(nums)
        return result
```

- Python一行代码

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        return list(itertools.permutations(nums))
```

- 修改`itertools.permutations()`源码

```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        result = []
        pool = tuple(nums)
        n = len(pool)
        indices = list(range(n))
        cycles = list(range(n, 0, -1))
        result.append(list(pool[i] for i in indices[:n]))
        while n:
            for i in reversed(range(n)):
                cycles[i] -= 1
                if cycles[i] == 0:
                    indices[i:] = indices[i+1:] + indices[i:i+1]
                    cycles[i] = n - i
                else:
                    j = cycles[i]
                    indices[i], indices[-j] = indices[-j], indices[i]
                    result.append(list(pool[i] for i in indices[:n]))
                    break
            else:
                return result
```

### 笔记

- 一行代码链接：[https://docs.python.org/3/library/itertools.html#itertools.permutations](https://docs.python.org/3/library/itertools.html#itertools.permutations)
- 这里的回溯法就不需要设置起点了，直接在整个nums里面遍历即可，但是要注意排除已经用过的。

## [784. 字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/)

难度：中等:star::star::star::star:

### 题目

给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。

 

示例：

```
输入：S = "a1b2"
输出：["a1b2", "a1B2", "A1b2", "A1B2"]

输入：S = "3z4"
输出：["3z4", "3Z4"]

输入：S = "12345"
输出：["12345"]
```


提示：

- S 的长度不超过12。
- S 仅由数字和字母组成。

### 代码

- 暴力回溯

```python
class Solution:
    def letterCasePermutation(self, s: str) -> List[str]:
        n = len(s)
        sl = list(s)
        result = []
        path = []

        def backtrack(sl: List, start: int):
            if len(path) == n:
                result.append(''.join(path[:]))
                return
            if start > n-1:
                return
            for i in range(start, n):
                if sl[i].islower():
                    path.append(sl[i])
                    backtrack(sl, i+1)
                    path.pop()
                    sl[i] = sl[i].upper()
                elif sl[i].isupper():
                    path.append(sl[i])
                    backtrack(sl, i+1)
                    path.pop()
                    sl[i] = sl[i].lower()
                path.append(sl[i])
                backtrack(sl, i+1)
                path.pop()
        backtrack(sl, 0)
        return result
```

- 笛卡尔积

```python
class Solution:
    def letterCasePermutation(self, s: str) -> List[str]:
        f = lambda x: (x.lower(), x.upper()) if x.isalpha() else x
        return list(map(''.join, itertools.product(*map(f, s))))
```

- 备份扩展法

```python
class Solution:
    def letterCasePermutation(self, s: str) -> List[str]:
        result = []
        n = len(s)
        if s[0].isalpha():
            result.append(s[0].lower())
            result.append(s[0].upper())
        else:
            result.append(s[0])
        for i in range(1, n):
            if s[i].isalpha():
                result.extend(result)
                for j in range(len(result)):
                    if j < len(result)//2:
                        result[j] += s[i].lower()
                    else:
                        result[j] += s[i].upper()
            else:
                for j in range(len(result)):
                    result[j] += s[i]
        return result
```

### 笔记

- 备份扩展法：按官方题解方法一的思路，挺有意思的。例如：'a1b1'。首先把第一个字符添加进去，如果是字母，就添加其大小写进去；如果是数字，就直接添加进去。如result = ['a', 'A']，然后，遇到数字，就把result中的每个字符都连接上数字，result=['a1', 'A1']；遇到字母，就先把result扩展一份，result=['a1', 'A1', 'a1', 'A1']，然后前一半中的每个字符都拼接上字母的小写，后一半拼接上字母的大写，result=['a1b', 'A1b', 'a1B', 'A1B']。遇到数字，就直接拼接到每个字符后面，不用扩展，result=['a1b1', 'A1b1', 'a1B1', 'A1B1']。

## [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

难度：简单:star::star::star:

### 题目

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 n 是一个正整数。

示例 1：

```
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。

1.  1 阶 + 1 阶
2.  2 阶
```

示例 2：

```
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。

1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```

### 代码

- 迭代

```python
class Solution:
    
    def climbStairs(self, n: int) -> int:
        if n == 1 or n == 2:
            return n
        f1 = 1
        f2 = 2
        count = 0
        for i in range(2, n):
            fn = f1 + f2
            f1, f2 = f2, fn
        return fn
```

- 公式法

```python
class Solution:
    
    def climbStairs(self, n: int) -> int:
        c = pow(5, 0.5)
        return round((pow((1 + c) / 2, n + 1) - pow((1 - c) / 2, n + 1)) / c)
```

### 笔记

- 递归法：f(n) = f(n-1)+f(n-2)。f(1)=1,f(2)=2,f(3)=3,f(4)=5,f(5)=8
  只需要算出f(n)的值即可，f(n)就是代表到达n的方法种树。
- 记忆化递归法：`fn = f1 + f2`，`f1, f2 = f2, fn`。保存前面计算的结果
- 斐波那契数列公式：[https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145](https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/99145)

## [198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

难度：中等:star::star::star::star:

### 题目

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。**

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

 

示例 1：

```
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

示例 2：

```
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```


提示：

- 1 <= nums.length <= 100
- 0 <= nums[i] <= 400

### 代码

- 假动态规划

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1:
            return nums[0]
        dp = [0] * n
        dp[0], dp[1] = nums[0], nums[1]
        for k in range(2, n):
            dp[k] = max(dp[k-2], nums[k] + dp[k-2])
            dp[k-1] = max(dp[k-1], dp[k-2])
        print(dp)
        return max(dp)
```

- 动态规划

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1:
            return nums[0]
        dp = [0] * n
        dp[0]= nums[0]
        dp[1] = max(dp[0], nums[1])
        for k in range(2, n):
            dp[k] = max(dp[k-1], nums[k] + dp[k-2])
        # print(dp)
        return dp[-1]
```

- 动态规划+状态压缩

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 1:
            return nums[0]
        first = nums[0]
        second = max(first, nums[1])
        for k in range(2, n):
           first, second = second, max(second, nums[k] + first)
        return second
```

### 笔记

- 状态转移方程：
  1, 2, 3, 4, 5, ..., k-2, k-1, k, ..., n

  dp(k) = max(dp(k-1), k + dp(k-2))
  对于第k个房子，偷还是不偷，取决于：第k个房子的金额加上前k-2个房子得到的总金额是不是比前k-1个房子的总金额要高。
  ```python
  if k + dp(k-2) >= dp(k-1):
      dp(k) = k + dp(k-2)
  if k + dp(k-2) < dp(k-1):
      dp(k) = dp(k-1)
  ```

- 动态规划问题，不直接考虑状态压缩的问题，直接想状态压缩想不出来，先想不压缩的情况。用一个dp[]数组来存储每个元素的状态（选、不选），这里的dp数组就是存储到当前元素的最大金额。
  再回过头来观察，发现dp[k]只和dp[k-1],dp[k-2]有关，即，只和其前两个状态有关，那么就可以用两个变量来存储其前两个状态。

## [120. 三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

难度：中等:star::star::star::star:

### 题目

给定一个三角形 triangle ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。**相邻的结点** 在这里指的是 **下标** 与 **上一层结点下标** 相同或者等于 **上一层结点下标 + 1** 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。

 

示例 1：

```python
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
```

示例 2：

```python
输入：triangle = [[-10]]
输出：-10
```


提示：

- 1 <= triangle.length <= 200
- triangle[0].length == 1
- triangle[i].length == triangle[i - 1].length + 1
- -10^4^ <= triangle[i][j] <= 10^4^

**进阶：**

- 你可以只使用 `O(n)` 的额外空间（`n` 为三角形的总行数）来解决这个问题吗？

### 代码

- 状态更新法

```python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        m = len(triangle)
        dp = triangle
        for i in range(1, m):
            # 每一行的第一个可以直接更新
            dp[i][0] = dp[i - 1][0] + dp[i][0]
            # 每一行的最后一个可以直接更新
            dp[i][-1] = dp[i - 1][-1] + dp[i][-1]
            # 中间的取其左上角和正上方的最小值与自己相加后更新
            for j in range(1, len(triangle[i]) - 1):
                dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j]
        return min(dp[-1])
```

- 修改原数组

```python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        m = len(triangle)
        dp = triangle
        for i in range(1, m):
            # 每一行的第一个可以直接更新
            triangle[i][0] = triangle[i - 1][0] + triangle[i][0]
            # 每一行的最后一个可以直接更新
            triangle[i][-1] = triangle[i - 1][-1] + triangle[i][-1]
            # 中间的取其左上角和正上方的最小值与自己相加后更新
            for j in range(1, len(triangle[i]) - 1):
                triangle[i][j] = min(triangle[i - 1][j - 1], triangle[i - 1][j]) + triangle[i][j]
        return min(triangle[-1])
```

- 自底向上

```python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        m = len(triangle)
        dp = triangle[:]
        for i in range(m - 2, -1, -1):
            for j in range(0, i + 1):
                dp[i][j] = min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle[i][j]
        return dp[0][0]
```

- 自底向上+状态压缩

```python
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        m = len(triangle)
        dp = triangle[-1]
        for i in range(m - 2, -1, -1):
            for j in range(0, i + 1):
                dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j]
        return dp[0]
```

### 笔记

- 状态更新法（自己取的名字）（好像也算是动态规划法）：走到每个结点，就更新当前结点的值，表示自顶点到当前结点的路径和，最后，取三角形最后一行中的最小值即可。
  注意到：每一行的第一个只和上一行的第一个有关，那就可以简单的直接更新。同样的，每一行的最后一个只和上一行的最后一个有关，那也是直接简单的更新。
  中间的值，则是取其左上角的那个和其正上方的最小值与其相加。
- 自底向上法：第i层的每个数选择其正下方和右对角中小的那一个和自己相加，这样每一层中都有一个是最小值，且该值一定是最短路径中自底向上的那个最小值。这种寻找最短路径值的办法是成立的，它不是简单的自底向上找每一层的最小值，而是自底向上，对每一层和其下一层相应求和之后找“和”值中的最小值，再往上一层，也是找“和”值中的最小值，最终，最上面的那一个，就是最短路径的值
- 空间优化：在实际递推中我们发现，计算` dp[i][j] `时，只用到了下一行的 `dp[i + 1][j]] `和` dp[i + 1][j + 1]`。
  因此 dp数组不需要定义 N行，只要定义 1 行就可以了。

## [231. 2 的幂](https://leetcode-cn.com/problems/power-of-two/)

难度：简单:star::star::star:

### 题目

给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。

如果存在一个整数 x 使得 n == 2^x^ ，则认为 n 是 2 的幂次方。

 

示例 1：

```
输入：n = 1
输出：true
```

解释：2^0^ = 1

示例 2：

```
输入：n = 16
输出：true
```

解释：2^4^ = 16

示例 3：

```
输入：n = 3
输出：false
```

示例 4：

```
输入：n = 4
输出：true
```

示例 5：

```
输入：n = 5
输出：false
```


提示：

- -2^31^ <= n <= 2^31^ - 1

**进阶：**你能够不使用循环/递归解决此问题吗？

### 代码

- 循环法

```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n == 1:
            return True
        while n > 2:
            n = n / 2
        if n == 2:
            return True
        return False
```

- 用函数

```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n < 0:
            return False
        m = collections.Counter(bin(n))['1']
        if m != 1:
            return False
        else:
            return True
```

- 位运算

```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and (n & (-n) == n)
```

- 位运算

```python
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and (n & (n - 1) == 0)
```

### 笔记

- 补码：0的补码还是0，正数的补码是正数的原码，负数的补码是除符号位之外的位取反，然后加1。
  符号位：0表示正数，1表示负数
  (补码表示方式很多，有8位2进制表示，有16位二进制补码表示形式，以及32位二进制补码表示形式，64位进制补码表示形式等。每一种补码表示形式都只能表示有限的数字。以下都使用8位2进制来表示)
  -5用补码表示的过程就是：10000101 ->（取反）11111010 -> （加1）11111011
  -8用补码表示的过程就是：10001000 -> 11110111->11111000

- 位运算（一）：`n & (n - 1) == 0`则n为2的幂，例：
  n = 5
      101
  & 100
      100 != 0。5不是2的幂
  n = 8
      1000
  & 0111
      0000 == 0。8是2的幂

- 位运算（二）：参考补码的定义，有：
  `n & (-n) == n`，n为2的幂。
  如：
  n = 5
      00000101
  & 11111011
      00000001 != 00000101。5不是2的幂

  n = 8
      00001000
  & 11111000
      00001000 == 00001000。8是2的幂



## [191. 位1的个数](https://leetcode-cn.com/problems/number-of-1-bits/)

难度：简单:star::star::star:

### 题目

编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为**汉明重量**）。

 

提示：

- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
- 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。

示例 1：

```
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
```

示例 2：

```
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
```

示例 3：

```
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
```


提示：

- 输入必须是长度为 32 的 **二进制串** 。


进阶：

- 如果多次调用这个函数，你将如何优化你的算法？

### 代码

- 用函数

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        return bin(n).count('1')
```

- 位运算

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        count = 0
        for i in range(32):
            if n & (1 << i):
                count += 1
        return count
```

- 位运算

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        count = 0
        while n:
            n = n & (n - 1)
            count += 1
        return count
```

### 笔记

- 位运算：当检查第 i位时，我们可以让 n 与 2^i进行与运算，当且仅当 n的第 i 位为 1时，运算结果不为 0。
  如：
      101
  & 001
      001 != 0 ->有一个1

  ​    101

  & 010
      000 == 0 -> 没有1

  ​    101

  & 100
      100  != 0 -> 有一个1
  		
  总共就有2个1

- 位运算：注意`n & (n - 1)`这个位运算的特点，每运算一次，会将n（二进制表示）中的最低位的1变为0。

  如：
      110      6
  & 101   &5
      100   =4
  & 011   &3
      000   =0
  &运算两次，6的二进制表示中1的个数为2

  ​    0111    7

  & 0110  &6
      0110  =6
  & 0101  &5
      0100  =4
  & 0011  &3
      0000  =0
  &运算3次，7的二进制表示中1的个数为3

## [190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)

难度：简单:star::star::star:

### 题目

颠倒给定的 32 位无符号整数的二进制位。

 

**提示：**

- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
- 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。

进阶:

- 如果多次调用这个函数，你将如何优化你的算法？

 

示例 1：

```
输入: 00000010100101000001111010011100
输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
```

示例 2：

```
输入：11111111111111111111111111111101
输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。
```


提示：

- 输入是一个长度为 32 的二进制字符串

### 代码

- 使用列表翻转

```python
class Solution:
    def reverseBits(self, n: int) -> int:
        m = list(bin(n))[2:]
        m.reverse()
        m = ''.join(m)
        m += '0'*(32 - len(m))
        # print(m)
        m = '0b' + m
        return int(m, 2)
```

- 移位操作

```python
class Solution:
    def reverseBits(self, n: int) -> int:
        result = 0
        for i in range(32):
            # n & 1 是取n的最后一位
            result |= (n & 1) << (31 - i)
            n = n >> 1
        return result
```

- 对称操作

```python
class Solution:
    def reverseBits(self, n: int) -> int:
        result = 0
        for i in range(32):
            temp = (n >> i) & 1
            if temp:
                result |= temp << (31 - i)
        return result
```

- 分治交换

```python
class Solution:
    def reverseBits(self, n: int) -> int:
        # 1位交换: 10 -> 01 、01 -> 10
        n = ((n >> 1) & 0x55555555) | ((n & 0x55555555) << 1)
        # 2位交换：1010 -> 1010、 0110 -> 1001
        n = ((n >> 2) & 0x33333333) | ((n & 0x33333333) << 2)
        # 4位交换：10100011 -> 00111010
        n = ((n >> 4) & 0x0f0f0f0f) | ((n & 0x0f0f0f0f) << 4)
        # 8位交换：1010001111001001 -> 1010001111001001 
        n = ((n >> 8) & 0x00ff00ff) | ((n & 0x00ff00ff) << 8)
        # 16位交换：10100011110010011010001111001001 -> 10100011110010011010001111001001
        n = ((n >> 16) & 0x0000ffff) | ((n & 0x0000ffff) << 16)
        return n
```

### 笔记

- `result |= a`表示 `result = result | a`
- 对称位构造：如果某一位是 1 的话，则将答案相应的对称位置修改为 1
- 常用的位运算：
  - `n & 1` ：取n二进制表示下的最后一位。如`0010 & 0001 = 0000`，`0011 & 0001 = 0001`。n为十进制下的奇数，则 `n & 1` 的结果为1；n为十进制下的偶数，则 `n & 1` 的结果为0；
  - `n & (-n)`：n为偶数，则`n&(-n)=n`；n为奇数，则`n&(-n)=1`。

## [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

难度：简单:star::star::star:

给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

示例 1:

```
输入: [2,2,1]
输出: 1
```

示例 2:

```
输入: [4,1,2,1,2]
输出: 4
```

### 代码

- 遍历统计

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        for n in nums:
            if nums.count(n) == 1:
                return n
```

- 异或运算

```
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        result = 0
        for n in nums:
            result = result ^ n
        return result
```

- reduce()函数

```python
class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        return functools.reduce(lambda x, y: x ^ y, nums)
```

### 笔记

- 异或运算：不同为1，相同为0。
  ```python
  >>> 2 ^ 2
  0
  >>> 2 ^ 1
  3
  >>> 2 ^ 2 ^ 1
  1
  >>> 4 ^ 1 ^ 2 ^1 ^ 2
  4
  >>> 2 ^ 0
  2
  >>> 3 ^ 0
  3
  >>> 
  ````
  由于有两个相同的数，那这两个数异或之后肯定是0

- 异或运算的性质：
  - 任何数和 0做异或运算，结果仍然是原来的数，即`a ^ 0 = a`
  - 任何数和其自身做异或运算，结果是 0，即`a ^ a = 1`
  - 异或运算满足交换律和结合律，即`a ^ b ^ a = b ^ a ^ a = b ^ (a ^ a) = b ^ 0 = b`。

## [495. 提莫攻击](https://leetcode-cn.com/problems/teemo-attacking/)

难度：简单:star::star::star:

### 题目

在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄，他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。现在，给出提莫对艾希的攻击时间序列和提莫攻击的中毒持续时间，你需要输出艾希的中毒状态总时长。

你可以认为提莫在给定的时间点进行攻击，并立即使艾希处于中毒状态。

 

示例1:

```
输入: [1,4], 2
输出: 4
原因: 第 1 秒初，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒末结束。
第 4 秒初，提莫再次攻击艾希，使得艾希获得另外 2 秒中毒时间。
所以最终输出 4 秒。
```

示例2:

```
输入: [1,2], 2
输出: 3
原因: 第 1 秒初，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒末结束。
但是第 2 秒初，提莫再次攻击了已经处于中毒状态的艾希。
由于中毒状态不可叠加，提莫在第 2 秒初的这次攻击会在第 3 秒末结束。
所以最终输出 3 。
```


提示：

- 你可以假定时间序列数组的总长度不超过 10000。
- 你可以假定提莫攻击时间序列中的数字和提莫攻击的中毒持续时间都是非负整数，并且不超过 10,000,000。

### 代码

- 暴力解法

```python
class Solution:
    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:
        total = set()
        for time in timeSeries:
            for i in range(max(time, len(total)), time + duration):
                total.add(i)
        return len(total)
```

- 官方题解

```python
class Solution:
    def findPoisonedDuration(self, timeSeries: List[int], duration: int) -> int:
        total = 0
        n = len(timeSeries)
        for i in range(n - 1):
            if timeSeries[i] + duration < timeSeries[i + 1]:
                total += duration
            else:
                total += timeSeries[i + 1] - timeSeries[i]
        return total + duration
```

### 笔记

- 注意：中毒状态不可叠加，`timeSeries[i] + duration >= timeSeries[i + 1]`的时候，把第`timeSeries[i]`秒的攻击时间算到第`timeSeries[i]`秒的这一次攻击上，但是攻击时间压缩到`timeSeries[i + 1]`为止，第`timeSeries[i]`秒本身多余的攻击时间，算到第`timeSeries[i+1]`秒的攻击时间中。

## [414. 第三大的数](https://leetcode-cn.com/problems/third-maximum-number/)

难度：简单:star::star::star:

给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。

 

示例 1：

```
输入：[3, 2, 1]
输出：1
解释：第三大的数是 1 。
```

示例 2：

```
输入：[1, 2]
输出：2
解释：第三大的数不存在, 所以返回最大的数 2 。
```

示例 3：

```
输入：[2, 2, 3, 1]
输出：1
解释：注意，要求返回第三大的数，是指在所有不同数字中排第三大的数。
此例中存在两个值为 2 的数，它们都排第二。在所有不同数字中排第三大的数为 1 。
```

**提示：**

- 1 <= nums.length <= 10^4^
- -2^31^ <= nums[i] <= 2^31^ - 1

**进阶：**你能设计一个时间复杂度 O(n) 的解决方案吗？

### 代码

- 暴力解法

```python
class Solution:
    def thirdMax(self, nums: List[int]) -> int:
        firstMax = max(nums)
        while firstMax in nums:
            nums.remove(firstMax)
        if nums:
            secondMax = max(nums)
            while secondMax in nums:
                nums.remove(secondMax)
        if nums:
            thirdMax = max(nums)
            return thirdMax
        return firstMax
```

### 笔记

- 暴力解法：删除所有第一大和第二大的，剩下的最大的，存在，则为第三大的

## [628. 三个数的最大乘积](https://leetcode-cn.com/problems/maximum-product-of-three-numbers/)

难度：简单:star::star::star:

给你一个整型数组 nums ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。

 

示例 1：

```
输入：nums = [1,2,3]
输出：6
```

示例 2：

```
输入：nums = [1,2,3,4]
输出：24
```

示例 3：

```
输入：nums = [-1,-2,-3]
输出：-6
```


提示：

- 3 <= nums.length <= 10^4^
- -1000 <= nums[i] <= 1000

### 代码

- 排序法

```python
class Solution:
    def maximumProduct(self, nums: List[int]) -> int:
        nums.sort()
        return max(nums[-1] * nums[-2] * nums[-3], nums[-1] * nums[0] * nums[1])
```

- 遍历法

```python
class Solution:
    def maximumProduct(self, nums: List[int]) -> int:
        firstMax, secondMax, thirdMax = -1001, -1001, -1001
        firstMin, secondMin = 1001, 1001
        
        for n in nums:
            if n > firstMax:
                thirdMax = secondMax
                secondMax = firstMax
                firstMax = n
            elif n > secondMax:
                thirdMax = secondMax
                secondMax = n
            elif n > thirdMax:
                thirdMax = n

            if n < firstMin:
                secondMin = firstMin
                firstMin = n
            elif n < secondMin:
                secondMin = n
        return max(firstMax * secondMax * thirdMax, firstMax * firstMin * secondMin)
```

### 笔记

- 注意，这个题和[第三大的数](https://leetcode-cn.com/problems/third-maximum-number/)这个题有一点区别，那个题是返回在所有不同数字中排第三大的数。这个题不是在不同数中的三个大数相乘，只要最后的乘积最大即可。比如有nums = [1,1,1,2,2,2]，那最大的乘积就是2*2*2。
- 排序思路：排序之后，比较最后的三个数相乘和 最小的两个数与最大的数相乘，取最大值即可。
- 遍历法，遍历一遍，找到最大的三个数和最小的两个数。
  寻找的思路：更新最大值的时候，要先把最大值给到第二大，更新第二大的时候，要先把第二大的给到第三大。
  更新最小值的时候，要先把最小值给到第二小。

## [645. 错误的集合](https://leetcode-cn.com/problems/set-mismatch/)

难度：简单:star::star::star:

### 题目

集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 **丢失了一个数字** 并且 **有一个数字重复** 。

给定一个数组 nums 代表了集合 S 发生错误后的结果。

请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

 

示例 1：

```
输入：nums = [1,2,2,4]
输出：[2,3]
```

示例 2：

```
输入：nums = [1,1]
输出：[1,2]
```


提示：

- 2 <= nums.length <= 10^4^
- 1 <= nums[i] <= 10^4^

### 代码

- 用集合

```python
class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        n = len(nums)
        s = (n * (n + 1)) // 2
        refer = set()
        res = []
        for num in nums:
            if num not in refer:
                refer.add(num)
            else:
                res.append(num)
        # 差值就是缺的那一个
        t = s - sum(refer)
        res.append(t)
        return res
```

- 用切片

```python
class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = []
        s = (n * (n + 1)) // 2
        for i in range(n - 1):
            if nums[i] in nums[i + 1:]:
                res.append(nums[i])
        res.append(s - (sum(nums) - res[0]))
        return res
```

- 用集合

```python
class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = []
        s = (n * (n + 1)) // 2
        refer = set()
        for num in nums:
            if num not in refer:
                refer.add(num)
            else:
                res.append(num)
                break
        res.append(s - (sum(nums) - res[0]))
        return res
```

- 数学解法

```python
class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        res = []
        n = len(nums)
        s = sum(set(nums))
        # 重复的数字
        res.append(sum(nums) - s)
        # 丢失的数字
        res.append((n * (n + 1)) // 2 - s)
        return res
```

- 哈希表

```python
class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        hashtable = dict()
        n = len(nums)
        for i in range(1, n + 1):
            hashtable[i] = 0
        for num in nums:
            hashtable[num] += 1
        res = []
        for k, v in hashtable.items():
            if v == 2:
                res.append(k)
        for k, v in hashtable.items():
            if v == 0:
                res.append(k)
        return res
```

- 位运算

```python
class Solution:
    def findErrorNums(self, nums: List[int]) -> List[int]:
        n = len(nums)
        xor = 0
        for num in nums:
            xor ^= num
        for i in range(1, n + 1):
            xor ^= i
        lowbit = xor & (-xor)
        num1, num2 = 0, 0
        for num in nums:
            if (num & lowbit) == 0:
                num1 ^= num
            else:
                num2 ^= num
        for i in range(1, n + 1):
            if (i & lowbit) == 0:
                num1 ^= i
            else:
                num2 ^= i
        for num in nums:
            if num == num1:
                return [num1, num2]
        return [num2, num1]
```

### 笔记

- 用数学解法找重复数字和缺失数字是个好思路。

- 位运算：还是没能理解背后的真正原理。
  留几个测试用例：
  ```
  1,2,2,4
  [2,3]
  ```

  ```
  1,3,3,4
  [3,2]
  ```

  ```
  3,2,3,4,6,5
  [3,1]
  ```

## [442. 数组中重复的数据](https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/)

难度：中等:star::star::star::star:

### 题目

给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现**两次**而其他元素出现**一次**。

找到所有出现**两次**的元素。

你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？

示例：

```
输入:
[4,3,2,7,8,2,3,1]

输出:
[2,3]
```

### 代码

- 哈希表

```python
class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        hashtable = dict()
        res = []
        for num in nums:
            if num not in hashtable.keys():
                hashtable[num] = 1
            else:
                res.append(num)
        return res
```

- 原地修改

```python
class Solution:
    def findDuplicates(self, nums: List[int]) -> List[int]:
        res = []
        for num in nums:
            if nums[abs(num) - 1] > 0:
                nums[abs(num) - 1] *= -1
            else:
                res.append(abs(num))
        return res
```

### 笔记

- 原地修改：当遇到`1 ≤ a[i] ≤ n （n为数组长度）`这种条件时，可以考虑采用原地修改的办法，因为数组中每一个元素值-1后都不超过数组的索引，所以可以利用这个特点对数组进行原地修改。常用的办法是遍历一遍数组，遍历过程中将索引为当前的遍历值减一的数组元素`*-1`，表示当前的元素已经遍历过，再次遇到的时候，如果数组元素小于0，则表示该元素已经出现过。

## [41. 缺失的第一个正数](https://leetcode-cn.com/problems/first-missing-positive/)

难度：困难:star::star::star::star::star:

### 题目

给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。

示例 1：

```
输入：nums = [1,2,0]
输出：3
```

示例 2：

```
输入：nums = [3,4,-1,1]
输出：2
```

示例 3：

```
输入：nums = [7,8,9,11,12]
输出：1
```


提示：

- 1 <= nums.length <= 5 * 10^5^
- -2^31^ <= nums[i] <= 2^31^ - 1

### 代码

- set集合

```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        s = set(nums)
        n = len(nums)
        for i in range(1, n + 1):
            if i not in s:
                return i
        return n + 1
```

- 原地哈希

```python
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        n = len(nums)
        for i in range(n):
            if nums[i] <= 0:
                nums[i] = n + 1
        for i in range(n):
            num = abs(nums[i])
            if num <= n:
                nums[num - 1] = -abs(nums[num - 1])
        for i in range(n):
            if nums[i] > 0:
                return i + 1
        return n + 1
```

### 笔记

- 原地哈希：如果数组中的数不在[1,N]之间，那么可以只考虑abs(nums[i])<=N的那些数，然后对这些数进行原地修改（取相反数）。修改时，对于nums[i]，是修改`nums[nums[i]-1]`，其中1<=nums[i]<=N

## [274. H 指数](https://leetcode-cn.com/problems/h-index/)

难度：中等:star::star::star::star:

### 题目

给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 **h 指数**。

h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （n 篇论文中）**总共**有 h 篇论文分别被引用了**至少** h 次。且其余的 n - h 篇论文每篇被引用次数 **不超过** h 次。

例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。

提示：如果 h 有多种可能的值，**h 指数** 是其中最大的那个。

 

示例 1：

```
输入：citations = [3,0,6,1,5]
输出：3 
解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。
     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。
```

示例 2：

```
输入：citations = [1,3,1]
输出：1
```


提示：

- n == citations.length
- 1 <= n <= 5000
- 0 <= citations[i] <= 1000

### 代码

- 排序

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        citations.sort()
        n = len(citations)
        h = 0
        for i in range(n-1, -1, -1):
            if citations[i] > h:
                h += 1
        return h
```

- 计数

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        counter = [0] * (n + 1)
        for c in citations:
            if c >= n:
                counter[n] += 1
            else:
                counter[c] += 1
        total = 0
        for i in range(n, -1, -1):
            total += counter[i]
            if total >= i:
                return i
```

- 二分查找

```python
class Solution:
    def hIndex(self, citations: List[int]) -> int:
        n = len(citations)
        l, r = 0, n
        while l < r:
            h = (l + r + 1) // 2
            # 判断h是否满足要求
            count = 0
            for c in citations:
                if c >= h:
                    count += 1
            if count >= h:
                l = h
            else:
                r = h - 1
        return l
```

### 笔记

- 题意：对排序后的数组从大到小遍历。根据 H 指数的定义，如果当前 H 指数为 h 并且在遍历过程中找到当前值citations[i] > h，则说明我们找到了一篇被引用了至少 h+1次的论文，所以将现有的 h 值加 1。继续遍历直到 h无法继续增大。最后返回 h作为最终答案。
- 题意理解：参考：[https://leetcode-cn.com/problems/h-index/solution/er-fen-cai-lun-wen-pian-shu-java-by-liwe-zoh7/](https://leetcode-cn.com/problems/h-index/solution/er-fen-cai-lun-wen-pian-shu-java-by-liwe-zoh7/)
- 题意再理解：不要被n-h迷惑了。排序后，按引用次数从大到小看，找一个数h，满足有h篇引用次数大于等于h，第h+1篇的引用次数小于等于h。0<=h<=n，h本质上代表论文的篇数。表示超过这些篇数的文章，每一篇文章的引用次数也超过这些篇数。
  例：[4,0,6,1,5]
  排序后：[6,5,4,1,0]
  h=0,
  一篇引用次数大于0，h=1
  又有一篇引用次数大于1，h=2
  又有一篇引用次数大于2，h=3
  一篇引用次数小于3，h=3。返回。说明有3篇论文引用次数>=3，剩下的论文引用次数小于等于 3。
- 二分查找：h一定在[0,1,2,...,n]这个有序数组中，h代表篇数，n是总篇数，在这个有序数组中找到一个h,看h是否满足有h篇论文每一篇的引用次数都大于h。

##  [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

难度：中等:star::star::star::star:

### 题目

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

进阶：

你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？

示例 1：

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

示例 2：

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

示例 3：

```
输入：nums = [], target = 0
输出：[-1,-1]
```


提示：

- 0 <= nums.length <= 10^5^
- -10^9^ <= nums[i] <= 10^9^
- nums 是一个非递减数组
- -10^9^ <= target <= 10^9^

### 代码

- 两个二分查找

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        return [self.leftBinarySearch(nums, target), self.rightBinarySearch(nums, target)]
    
    def leftBinarySearch(self, nums, k):
        n = len(nums)
        l, r = 0, n - 1
        while l <= r:
            m = l + (r - l) // 2
            if nums[m] == k:
                r = m - 1
            elif nums[m] < k:
                l = m + 1
            elif nums[m] > k:
                r = m - 1
        if l >= n or nums[l] != k:
            return -1
        return l
    def rightBinarySearch(self, nums, k):
        l, r = 0, len(nums) - 1
        while l <= r:
            m = l + (r - l) // 2
            if nums[m] == k:
                l = m + 1
            elif nums[m] < k:
                l = m + 1
            elif nums[m] > k:
                r = m - 1
        if r < 0 or nums[r] != k:
            return -1
        return r
```

- 列表索引

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        try:
            left = nums.index(target)
            nums.reverse()
            right = len(nums) - 1 - nums.index(target)
        except ValueError:
            left = -1
            right = -1
        return [left, right]
```

- bisect库

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        import bisect
        left = bisect.bisect_left(nums, target)
        right = bisect.bisect_right(nums, target) - 1
        if left != len(nums) and nums[left] == target:
            return [left, right]
        else:
            return [-1, -1]
```

- 一个二分查找

```python
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        left = self.leftBinarySearch(nums, target)
        right = self.leftBinarySearch(nums, target + 1)
        if left == right:
            return [-1, -1]
        return [left, right - 1]



    def leftBinarySearch(self, nums, x):
        lo, hi = 0, len(nums)
        while lo < hi:
            mid = lo + (hi - lo) // 2
            if nums[mid] < x:
                lo = mid + 1
            else:
                hi = mid
        return lo
```

### 笔记

- 两个二分查找：一个二分查找找左边界，一个二分查找找右边界。
  找左边界的二分查找：相等的时候压缩右边界。
  找右边界的二分查找：相等的时候压缩左边界。
  找左右边界的时候均要判断是否越界。
- bisect库：[https://docs.python.org/zh-cn/3/library/bisect.html](https://docs.python.org/zh-cn/3/library/bisect.html)
- 一个二分查找：找两次，第一次找最左边的target，第二次找第一个大于target的（也即在所有大于target的值中找最左边的）。所以可以用同一个找左边界的二分查找。

## [69. x 的平方根 ](https://leetcode-cn.com/problems/sqrtx/)

难度：简单:star::star::star:

### 题目

实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

示例 1:

```
输入: 4
输出: 2
```

示例 2:

```
输入: 8
输出: 2
说明: 8 的平方根是 2.82842..., 
     由于返回类型是整数，小数部分将被舍去。
```

### 代码

- int(x**0.5)

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        return int(x**0.5)
```

- 二分近似

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        if x <= 1:
            return x
        lo, hi = 0, x
        while lo < hi:
            mid = lo + (hi - lo) // 2
            if x < mid**2 :
                hi = mid
            else:
                lo = mid + 1
        return lo - 1
```

- math.isqrt(x)

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        return math.isqrt(x)
```

- 用对数代替根号

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        if x == 0:
            return 0
        ans = int(math.exp(0.5 * math.log(x)))
        return ans + 1 if (ans + 1) ** 2 <= x else ans
```

- 牛顿迭代法

```python
class Solution:
    def mySqrt(self, x: int) -> int:
        if x == 0:
            return 0
        C, x0 = x, x
        while True:
            xi = 0.5 * (x0 + C / x0)
            if abs(x0 - xi) < 1e-7:
                break
            x0 = xi
        return int(x0)
```

### 笔记

- 「袖珍计算器算法」是一种用指数函数 exp 和对数函数 ln 代替平方根函数的方法。我们通过有限的可以使用的数学函数，得到我们想要计算的结果。
  注意： 由于计算机无法存储浮点数的精确值（浮点数的存储方法可以参考 IEEE 754，这里不再赘述），而指数函数和对数函数的参数和返回值均为浮点数，因此运算过程中会存在误差。
  因此在得到结果的整数部分 ans 后，我们应当找出 ans 与 ans+1 中哪一个是真正的答案（取平方更接近x的那一个）。
- 二分近似：通过二分查找，找到最后一个平方小于x的那个整数。
- 牛顿迭代法：用公式不断逼近零点，得到开方的近似值。

## [925. 长按键入](https://leetcode-cn.com/problems/long-pressed-name/)

难度：简单:star::star::star:

### 题目

你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。

你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。

 

示例 1：

```
输入：name = "alex", typed = "aaleex"
输出：true
解释：'alex' 中的 'a' 和 'e' 被长按。
```

示例 2：

```
输入：name = "saeed", typed = "ssaaedd"
输出：false
解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。
```

示例 3：

```
输入：name = "leelee", typed = "lleeelee"
输出：true
```

示例 4：

```
输入：name = "laiden", typed = "laiden"
输出：true
解释：长按名字中的字符并不是必要的。
```


提示：

- name.length <= 1000
- typed.length <= 1000
- name 和 typed 的字符都是小写字母。

### 代码

- 笨办法

```python
class Solution:
    def isLongPressedName(self, name: str, typed: str) -> bool:
        # if typed.find(name) >= 0:
            # return True
        name_list = list(name)
        typed_list = list(typed)

        for n in name_list[:-1]:
            if len(typed_list) == 0:
                return False
            flag = 1
            if n == name_list[name_list.index(n) + 1]:
                typed_list.remove(n)
                flag = 0
            else:
                while typed_list and n == typed_list[0]:
                    typed_list.remove(n)
                    flag = 0
            if flag:
                return False
            name_list.pop(0)
        if len(typed_list) == 0:
            return False

        while typed_list and name_list[-1] == typed_list[0]:
            typed_list.remove(name_list[-1])

        if typed_list:
            return False
        else:
            return True
```

### 笔记

## [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

难度：:star::star::star:

### 题目

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

示例 1:

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```


示例 2:

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```


提示：

- 你可以假设 nums 中的所有元素是不重复的。
- n 将在 [1, 10000]之间。
- nums 的每个元素都将在 [-9999, 9999]之间。

### 代码

- 二分法

```python
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        min = 0
        max = len(nums) - 1
        while min <= max:
            mid = min + (max - min)//2
            if target < nums[mid]:
                max = mid - 1
            elif target > nums[mid]:
                min = mid + 1
            elif target == nums[mid]:
                return mid
        return -1
```

### 笔记

## [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/)

难度：简单:star::star::star:

### 题目

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

 

示例 1:

```
输入: nums = [1,3,5,6], target = 5
输出: 2
```

示例 2:

```
输入: nums = [1,3,5,6], target = 2
输出: 1
```

示例 3:

```
输入: nums = [1,3,5,6], target = 7
输出: 4
```

示例 4:

```
输入: nums = [1,3,5,6], target = 0
输出: 0
```

示例 5:

```
输入: nums = [1], target = 0
输出: 0
```


提示:

- 1 <= nums.length <= 10^4^
- -10^4^ <= nums[i] <= 10^4^
- nums 为无重复元素的升序排列数组
- -10^4^ <= target <= 10^4^

### 代码

- 二分法

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + (right - left) // 2
            if target < nums[mid]:
                right = mid - 1
            elif target > nums[mid]:
                left = mid + 1
            elif target == nums[mid]:
                return mid
        return right + 1
```

- 二分法

```python
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + ((right - left) >> 1)
            if target < nums[mid]:
                right = mid - 1
            elif target > nums[mid]:
                left = mid + 1
            elif target == nums[mid]:
                return mid
        return left
```

### 笔记

## [977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)

难度：简单:star::star::star:

### 题目

给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

 

示例 1：

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

示例 2：

```
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```


提示：

- 1 <= nums.length <= 10^4^
- -10^4^ <= nums[i] <= 10^4^
- nums 已按 非递减顺序 排序


进阶：

- 请你设计时间复杂度为 O(n) 的算法解决本问题

### 代码

- 笨办法

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        left, right = 0, len(nums) - 1
        while left <= right:
            mid = left + ((right - left) >> 1)
            if nums[mid] < 0:
                left = mid + 1
            elif nums[mid] > 0:
                right = mid - 1
            elif nums[mid] == 0:
                divide = mid
                break
        if left > right:
            divide = left
        nums_squares = []
        nums_p = nums[divide:]
        nums_n = nums[:divide]
        for i in nums_p:
            nums_squares.append(i**2)
        for i in nums_n:
            t = i**2
            position = self.findInsertPosition(nums_squares, t)
            nums_squares.insert(position, t)
        return nums_squares

    
    def findInsertPosition(self, numss: List[int], target: int) -> int:
        l, r = 0, len(numss) - 1
        while l <= r:
            m = l + ((r - l) >> 1)
            if target < numss[m]:
                r = m - 1
            elif target > numss[m]:
                l = m + 1
            elif target == numss[m]:
                return m
        return l
```

- 双指针

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        l, r, p = 0, len(nums) - 1, len(nums)-1
        ans = [0] * (p + 1)
        while l <= r:
            if -nums[l] <= nums[r]:
                ans[p] = nums[r] ** 2
                r -= 1
            else:
                ans[p] = nums[l] ** 2
                l += 1
            p -= 1
        return ans
```

- 双指针

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        l, r = 0, len(nums) - 1
        ans = []
        while l <= r:
            if -nums[l] <= nums[r]:
                ans.insert(0, nums[r] ** 2)
                r -= 1
            elif -nums[l] >= nums[r]:
                ans.insert(0, nums[l] ** 2)
                l += 1
        return ans
```

- 双指针

```python
class Solution:
    def sortedSquares(self, nums: List[int]) -> List[int]:
        l, r, p = 0, len(nums) - 1, len(nums)
        ans = [0] * p
        while l <= r:
            if -nums[l] <= nums[r]:
                ans[p-1] = nums[r] ** 2
                p -= 1
                r -= 1
            else:
                ans[p-1] = nums[l] ** 2
                p -= 1
                l += 1
        return ans
```

### 笔记

## [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

难度：简单:star::star::star:

### 题目

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

 

示例 1：

```
输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```

示例 2：

```
输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

### 代码

- 双指针

```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        left, right = 0, len(s) - 1
        while left < right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
```

- 用Python函数

```python
class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        s.reverse()
```

### 笔记

## [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

难度：简单:star::star::star:

### 题目

给定一个头结点为 head 的非空单链表，返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

 

示例 1：

```
输入：[1,2,3,4,5]
输出：此列表中的结点 3 (序列化形式：[3,4,5])
返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。
注意，我们返回了一个 ListNode 类型的对象 ans，这样：
ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.
```

示例 2：

```
输入：[1,2,3,4,5,6]
输出：此列表中的结点 4 (序列化形式：[4,5,6])
由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。
```


提示：

- 给定链表的结点数介于 1 和 100 之间。

### 代码

- 单指针

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        size = 0
        p = head
        while p!= None:
            size += 1
            p = p.next
        mid = size // 2 + 1
        p = head
        while mid > 1:
            p = p.next
            mid -= 1
        return p
```

- 快慢指针

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def middleNode(self, head: ListNode) -> ListNode:
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow
```

### 笔记

## [485. 最大连续 1 的个数](https://leetcode-cn.com/problems/max-consecutive-ones/)

难度：简单:star::star::star:

### 题目

给定一个二进制数组， 计算其中最大连续 1 的个数。

 

示例：

```
输入：[1,1,0,1,1,1]
输出：3
解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3.
```


提示：

- 输入的数组只包含 0 和 1 。
- 输入数组的长度是正整数，且不超过 10,000。

### 代码

- 遍历

```python
class Solution:
    def findMaxConsecutiveOnes(self, nums: List[int]) -> int:
        result, count = 0, 0
        for n in nums:
            if n:
                count += n
            else:
                result = max(result, count)
                count = 0
        result = max(result, count)
        return result
```

### 笔记

## [697. 数组的度](https://leetcode-cn.com/problems/degree-of-an-array/)

难度：简单:star::star::star:

### 题目

给定一个非空且只包含非负数的整数数组 nums，数组的度的定义是指数组里任一元素出现频数的最大值。

你的任务是在 nums 中找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。

 

示例 1：

```
输入：[1, 2, 2, 3, 1]
输出：2
解释：
输入数组的度是2，因为元素1和2的出现频数最大，均为2.
连续子数组里面拥有相同度的有如下所示:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
最短连续子数组[2, 2]的长度为2，所以返回2.
```

示例 2：

```
输入：[1,2,2,3,1,4,2]
输出：6
```


提示：

- nums.length 在1到 50,000 区间范围内。
- nums[i] 是一个在 0 到 49,999 范围内的整数。

### 代码

- 暴力解法

```python
class Solution:
    def findShortestSubArray(self, nums: List[int]) -> int:
        hashtable = dict()
        for num in nums:
            if num not in hashtable.keys():
                hashtable[num] = 0
            else:
                hashtable[num] += 1
        degree = max(hashtable.values())
        dk = []
        for k, v in hashtable.items():
            if v == degree:
                dk.append(k)
        n = len(nums)
        count = 50001
        for key in dk:
            for i in range(n):
                if nums[i] == key:
                    fisrt = i
                    break
            for j in range(n-1, -1, -1):
                if nums[j] == key:
                    last = j
                    break
            count = min(count, j - i + 1)
        return count
```

- 哈希表

```python
class Solution:
    def findShortestSubArray(self, nums: List[int]) -> int:
        hashtable = dict()
        n = len(nums)
        for i in range(n):
            if nums[i] not in hashtable.keys():
                hashtable[nums[i]] = [1, i, i]
            else:
                hashtable[nums[i]][0] += 1
                hashtable[nums[i]][2] = i
        # print(hashtable)
        degree = 0
        minLen = 50001
        for count, left, right in hashtable.values():
            if count > degree:
                degree = count
                minLen = right - left + 1
            elif count == degree:
                minLen = min(minLen, right - left + 1)

        return minLen
```

### 笔记

## [448. 找到所有数组中消失的数字](https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/)

难度：:star::star::star:

### 题目

给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。

 

示例 1：

```
输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]
```

示例 2：

```
输入：nums = [1,1]
输出：[2]
```


提示：

- n == nums.length
- 1 <= n <= 10^5^
- 1 <= nums[i] <= n

进阶：

- 你能在不使用额外空间且时间复杂度为 O(n) 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。

### 代码

- 哈希集合

```python
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = []
        s = set(nums)
        for num in range(1, n + 1):
            if num not in s:
                res.append(num)
        return res
```

- 集合的差集

```python
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        n = len(nums)
        return list(set(range(1, n + 1)) - set(nums))
```

- 原地修改

```python
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        for num in nums:
            if nums[abs(num) - 1] > 0:
                nums[abs(num) - 1] *= -1
        res = []
        n = len(nums)
        for i in range(n):
            if nums[i] > 0:
                res.append(i + 1)
        return res
```

### 笔记

## [453. 最小操作次数使数组元素相等](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/)

难度：简单:star::star::star:

### 题目

给定一个长度为 n 的 非空 整数数组，每次操作将会使 n - 1 个元素增加 1。找出让数组所有元素相等的最小操作次数。

 

示例：

```
输入：
[1,2,3]
输出：
3
解释：
只需要3次操作（注意每次操作会增加两个元素的值）：
[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
```

### 代码

- ~~暴力解法【超时】~~

```python
class Solution:
    def minMoves(self, nums: List[int]) -> int:
        n = len(nums)
        count = 0
        while len(set(nums)) != 1:
            maxi = nums.index(max(nums))
            for i in range(n):
                if i == maxi:
                    continue
                else:
                    nums[i] += 1
            count += 1
            # print(nums)
        return count
```

- 逆向思维

```python
class Solution:
    def minMoves(self, nums: List[int]) -> int:
        min_num = min(nums)
        ans = 0
        for i in nums:
            ans += i - min_num
        return ans
```

- 排序+diff

```python
class Solution:
    def minMoves(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        count = 0
        for i in range(n-1, 0, -1):
            diff = nums[i] - nums[0]
            count += diff
            nums[0] += diff
            nums[i - 1] += count
        return count
```

- 利用排序

```python
class Solution:
    def minMoves(self, nums: List[int]) -> int:
        nums.sort()
        n = len(nums)
        count = 0
        for i in range(n-1, 0, -1):
            count += nums[i] - nums[0]
        return count
```

### 笔记

- 暴力解法：每次除了最大值之外的所有值+1。
- 逆向思维：将每次n-1个元素+1转化为每次1个元素-1，至所有元素相等（是nums中的最小值）。
  最后的次数就等于nums中的每个元素减最小值的和。
  因为所有的值都被减到了最小值。
- 排序+diff：思想是题解中的动态规划。排序之后，每次让最小值加到和最大值相等，由于排好序，所以每次的最大值是nums中从n-1往前，最小值是nums[0]。遍历完后，所有值就会相等。
- 利用排序：详解参考官方题解方法三：[https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/solution/zui-xiao-yi-dong-ci-shu-shi-shu-zu-yuan-su-xiang-d/](https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/solution/zui-xiao-yi-dong-ci-shu-shi-shu-zu-yuan-su-xiang-d/)

## [367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)

难度：简单:star::star::star:

### 题目

给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。

进阶：不要 使用任何内置的库函数，如  sqrt 。

 

示例 1：

```
输入：num = 16
输出：true
```

示例 2：

```
输入：num = 14
输出：false
```


提示：

- 1 <= num <= 2^31 - 1

### 代码

- num ** 0.5

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        return True if (num ** 0.5) - int(num ** 0.5) == 0 else False
```

- 二分查找

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        lo, hi = 0, num
        while lo < hi:
            mid = lo + (hi - lo) // 2
            if mid**2 < num:
                lo = mid + 1
            else:
                hi = mid
        return True if (lo**2 == num) else False
```

- 缩小右边界

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        if num == 1:
            return True
        lo, hi = 0, num // 2
        while lo < hi:
            mid = lo + (hi - lo) // 2
            if mid**2 < num:
                lo = mid + 1
            else:
                hi = mid
        return True if (lo**2 == num) else False
```

- 牛顿迭代法

```python
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        if num == 1:
            return True
        x0, C = num/2, num
        while True:
            xi = 0.5 * (x0 + C / x0)
            if abs(x0 - xi) < 1e-7:
                break
            x0 = xi
        if int(xi)**2 - num == 0:
            return True
        else:
            return False
```

### 笔记

- 二分查找：可采用标准的二分查找模板，通过二分查找来不断逼近根号值，最后验证该值是否为平方根。
- 缩小右边界：由于根号的特点，可以缩小右边界。
- 牛顿迭代法：通过递推公式不断逼近根号值。
  注意：结束逼近条件是判断$x_{i+1}$ 和$x_{i}$之间的距离非常小，就不用再逼近了。

## [4. 寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

难度：困难:star::star::star::star::star:

### 题目

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

 

示例 1：

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

示例 2：

```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

示例 3：

```
输入：nums1 = [0,0], nums2 = [0,0]
输出：0.00000
```

示例 4：

```
输入：nums1 = [], nums2 = [1]
输出：1.00000
```

示例 5：

```
输入：nums1 = [2], nums2 = []
输出：2.00000
```

提示：

- nums1.length == m
- nums2.length == n
- 0 <= m <= 1000
- 0 <= n <= 1000
- 1 <= m + n <= 2000
- -10^6^ <= nums1[i], nums2[i] <= 10^6^

进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？

### 代码

- 用二分查找来合并

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        m, n = len(nums1), len(nums2)
        if m == 0 and n == 0:
            return None
        elif m == 0 :
            return nums2[n//2] if n % 2 != 0 else (nums2[n//2] + nums2[n//2 - 1]) / 2
        elif n == 0:
            return nums1[m//2] if m % 2 != 0 else (nums1[m//2] + nums1[m//2 - 1]) / 2
        
        import bisect
        for i in nums2:
            bisect.insort_left(nums1, i)
        total = m + n
        return nums1[total//2] if total % 2 != 0 else (nums1[total//2] + nums1[total//2 - 1]) / 2
```

- 合并有序表

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        m, n = len(nums1), len(nums2)
        if m == 0 and n == 0:
            return None
        elif m == 0 :
            return nums2[n//2] if n % 2 != 0 else (nums2[n//2] + nums2[n//2 - 1]) / 2
        elif n == 0:
            return nums1[m//2] if m % 2 != 0 else (nums1[m//2] + nums1[m//2 - 1]) / 2
        
        total = m + n
        nums = [0] * total
        i, j, k = 0, 0, 0
        while i < m and j < n:
            if nums1[i] <= nums2[j]:
               nums[k] = nums1[i]
               i += 1
            else:
                nums[k] = nums2[j]
                j += 1
            k += 1
    
        while j < n:
            nums[k] = nums2[j]
            j += 1
            k += 1
        
        while i < m:
            nums[k] = nums1[i]
            i += 1
            k += 1
        
        return nums[total//2] if total % 2 != 0 else (nums[total//2] + nums[total//2 - 1]) / 2
```

- 找第k小的数

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        m, n = len(nums1), len(nums2)

        def getKthElement(k):
            index1_start, index2_start = 0, 0
            while True:
                if index1_start >= m :
                    return nums2[index2_start + k - 1]
                if index2_start >= n :
                    return nums1[index1_start + k - 1]
                if k == 1:
                    return min(nums1[index1_start], nums2[index2_start])

                index1 = min(index1_start + k // 2 - 1, m - 1)
                index2 = min(index2_start + k // 2 - 1, n - 1)
                if nums1[index1] <= nums2[index2]:
                    k = k - (index1 - index1_start + 1)
                    index1_start = index1 + 1
                else:
                    k = k - (index2 - index2_start + 1)
                    index2_start = index2 + 1
        
        total = m + n
        if total % 2 == 0:
            return (getKthElement(total//2) + getKthElement(total//2 + 1)) / 2
        else:
            return getKthElement(total//2 + 1)
```

- 二分法

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        if len(nums1) > len(nums2):
            return self.findMedianSortedArrays(nums2, nums1)
        
        m, n = len(nums1), len(nums2)
        
        # 使用二分来查找满足条件的i
        # 主要是要找到满足`nums1[i - 1] <= nums2[j]`的最大的i
        lo, hi = 0, m
        leftTotal = (m + n + 1) // 2
        while lo < hi:
            i = lo + (hi - lo + 1) // 2
            j = leftTotal - i
            if nums1[i - 1] <= nums2[j]:
                lo = i
            else:
                hi = i - 1
        i = lo
        j = leftTotal - i
        # 确定i和j之后，分割线位于i和j的左边
        # 然后找分割线左边的最大值和分割线右边的最小值
        nums1LeftMax = float('-inf') if i == 0 else nums1[i - 1]
        nums2LeftMax = float('-inf') if j == 0 else nums2[j - 1]
        nums1RightMin = float('inf') if i == m else nums1[i]
        nums2RightMin = float('inf') if j == n else nums2[j]

        if (m + n) % 2 == 0:
            return (max(nums1LeftMax, nums2LeftMax) + min(nums1RightMin, nums2RightMin)) / 2
        else:
            return max(nums1LeftMax, nums2LeftMax)
```

### 笔记

- 找第k小的数：
  - m+n为奇数，找第(m+n)/2 + 1小的（就是中位数）。m+n为偶数，找第(m+n)/2和第(m+n)/2 + 1小的两个，再取平均值。
  - 找第k小的数，关键是比较一次之后，看排除了多少个,一般情况下是排除k/2个，但是，当一个已经都排除的时候，就不是排除k/2个，所以，计算排除多少个，用index1 - index1_start + 1和index2 - index2_start + 1，k更新的时候就相应的减去排除的个数。比如，k=7是找第7小的，排除3个后，再就是找第7-3=4小的。
  - 同时，还需要更新起始位置，排除几个元素并不是真的将他们删除，而是排除几个，下一次的起始位置就从几开始。
  - 一个数组如果排除完了，就是在另一个数组的未排除元素中找当前第k小的（反映到下标上就是k-1），那么再加上起始位置，就是最开始的第k小的。
  - k==1的时候，说明是在当前未排除的元素中找第1小的，也就是两个数组中未排除元素的最小值。
- 二分法：
  - 从在一个序列中的二分扩展到两个序列的二分。
  - 看到有序和log复杂度，就要想到二分法。
  - 中位数刚好也是有二分的作用，再深入一步，对于一个偶数序列，中位数是中间两个数的平均值；对于一个奇数序列，中位数是最中间的那个数。
  - 在一个序列中是找一个或两个数，在两个序列中就是找两个或四个数。
  - 中位数在一个序列中具有“分割”的作用，这个性质在一个序列中不容易被重视，因为很容易就可以得到一个有序序列的中位数。但是，这个“分割”作用，在两个有序序列中就很重要，利用这个分割作用，我们可以确定一条“分割线”来分割这两个序列，使这两个序列在这个分割线左边和右边的元素个数相等（m+n为偶数时），或左边比右边多一个（m+n为奇数时）。
  - 为了简化边界条件的讨论，我们设定m<=n，当m>n时，交换两个数组。
  - i和j都位于分割线的右边，也即分割线位于`A[i-1]`和`A[i]`之间，`B[j-1]`和`B[j]`之间。
  - 现在使用二分法的目的主要就是找到满足中位数的性质的i和j，其实主要是找i，因为，`j = (m + n +1) / 2 - i`，其中+1可以避免讨论m+n为奇数还是偶数。确定了i之后，就可以确定j。
  - 使用二分来查找满足条件的i，主要是要找到满足`nums1[i - 1] <= nums2[j]`的最大的i。
  - 确定i和j之后，分割线位于i和j的左边，然后找分割线左边的最大值和分割线右边的最小值。

