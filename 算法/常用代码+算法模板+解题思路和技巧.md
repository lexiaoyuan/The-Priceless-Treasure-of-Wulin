# 常用代码总结

## Java中常用代码

- `map.put(a, map.getOrDefault(a, 0) + 1);`可以用来计数

- map的值是Integer类型时，比较用equals。`map2.get(c1).equals(map1.get(c1))`

- 二叉树结点定义：

  ```java
  public class TreeNode {
      int val;
      TreeNode left;
      TreeNode right;
      TreeNode() {}
      TreeNode(int val) { this.val = val; }
      TreeNode(int val, TreeNode left, TreeNode right) {
          this.val = val;
          this.left = left;
          this.right = right;
      }
  }
  ```

- Java中栈的定义及常用操作：

  ```java
  Deque<E> stack = new LinkedList<>();
  stack.empty(); // 为空返回true，不为空返回false。
  stack.isEmpty(); // 为空返回true，不为空返回false(与stack.empty()无结果上的区别)。
  stack.peek(); // 为空返回null，不为空返回栈顶元素。
  stack.size(); // 为空返回0，不为空返回一个大于1的整数。
  stack.push(E); // 在栈的顶部添加元素
  stack.pop(); // 返回栈的顶部元素，并将其从栈顶删除
  ```

- Java中队列的定义及常用操作：

  ```java
  Queue<E> queue = new LinkedList<>();
  queue.offer(E); // 在队列尾部插入元素
  queue.poll(); // 返回队列首部元素，并在队列中删除
  queue.peek(); // 返回队列首部元素
  queue.isEmpty(); // 判断队列是否为空
  ```

- 选择中间靠左边的值:`int m = left + (right - left) / 2;`。选择中间靠右边的值：`int m = left + (right - left + 1) / 2;`

- Java中定义一个二维的动态数组：

  ```java
  List<List<Integer>> yangHui = new ArrayList<List<Integer>>();
  List<List<Integer>> yangHui = new ArrayList<>();
  ```

- Java中ArrayList的常用方法：

  ```java
  yangHui.add(E); // 添加元素到 ArrayList
  yangHui.get(i); // 访问第i+1个元素。索引从0开始
  yanghui.set(2, E); // 第一个参数为索引位置，第二个为要修改的值
  yanghui.remove(3); // 删除第四个元素
  yanghui.size(); // 计算 ArrayList 中的元素数量可以使用 size() 方法
  ```

- Java关于哈希集合的定义和常用方法：

  ```java
  HashSet<E> set = new HashSet<>();
  set.add(E); // 如果E不在set中，将E插入set并返回true，如果E在set中，则不插入，并返回false
  set.remove(E); // 如果E在set中，将E删除并返回true，如果E不在set中，则返回false
  set.contains(E); // 如果set中有E，返回true，没有就返回false
  set.size(); // 返回set的元素个数
  set.isEmpty(); // set为空，返回true，不为空返回false
  ```

- Character类的常用方法：

  ```java
  Character.isDigit(char c);　　//判断字符c是否是数字字符，如‘1’，‘2’，是则返回true，否则返回false  
  Character.isLowerCase(char c) || Character.isUpperCase(char c);　　//判断c是否是字母字符，前面LowerCase是小写，后面UpperCase是大写，是返回True，否则返回False
  Character.isLetterOrDigit(char c);　　//判断c是否是字母或数字字符，是返回true,否则返回false
  Character.toUpperCase(char c); // 将字符c转换为大写
  Character.toLowerCase(char c); // 将字符c转换为小写
  Character.toString(char c); // 将字符c转换为字符串，长度为1
  ```

- StringBuilder类的定义和常用方法：

  ```java
  StringBuilder sb = new StringBuilder();
  sb.append(E); // 字符串拼接，append方法支持boolean,char,char[].double,float,int,long,String,Object
  sb.toString(); // 转字符串
  sb.reverse(); // 翻转字符串，执行这个之后，sb本身就被翻转了
  ```

- 关于StringBuilder的reverse：执行`sb.reverse();` 之后，sb本身就已经被翻转了。

  ```java
  StringBuilder sb = new StringBuilder("abcd");
  System.out.println(sb); // abcd
  sb.reverse(); 
  System.out.println(sb); // dcba
  ```

  ```java
  StringBuilder sb = new StringBuilder("abcd");
  System.out.println(sb); // abcd
  StringBuilder sb_rev = new StringBuilder(sb).reverse();
  System.out.println(sb); // abcd
  System.out.println(sb_rev); // dcba
  ```

- Java中单链表结点定义：

  ```java
  class ListNode {
      int val;
      ListNode next;
      ListNode(int x) {
          val = x;
          next = null;
      }
  }
  ```

- Java中ArrayList的定义及常用方法：

  ```java
  List<E> arr = new ArrayList<>();
  ArrayList<E> arr = new ArrayList<>();
  arr.add(E); // 将指定的元素追加到此列表的末尾。
  arr.get(i); // 返回此列表中指定位置的元素。
  arr.set(i, E); // 用指定的元素替换此列表中指定位置的元素。
  arr.remove(i); // 删除此列表中指定位置的元素。
  arr.size(); // 返回此列表中的元素数。
  arr.isEmpty(); // 如果此列表不包含任何元素，则返回 true 。
  ```

- Java中定义能插入数组的栈：

  ```java
  Deque<int[]> stack = new LinkedList<>();
  stack.push(new int[]{val, val});
  ```

- Java中关于HashMap的定义及常用方法：

  ```java
  HashMap<E, E> hashMap = new HashMap<>();
  hashMap.put(E, E); // 将键/值对添加到 hashMap 中,如果插入的 key 对应的 value 已经存在，则执行 value 替换操作，返回旧的 value 值，如果不存在则执行插入，返回 null。
  hashMap.containsKey(E); //    检查 hashMap 中是否存在指定的 key 对应的映射关系。
  hashMap.containsValue(E); // 检查 hashMap 中是否存在指定的 value 对应的映射关系。
  hashMap.get(E); // 获取指定 key 对应对 value
  hashMap.remove(E); // 删除 hashMap 中指定键 key 的映射关系
  hashMap.keySet(); // 返回 hashMap 中所有 key 组成的集合视图。
  hashMap.values(); // 返回 hashMap 中存在的所有 value 值。
  hashMap.entrySet(); // 返回此映射中包含的映射的 Set 视图。注意：Set 视图意思是 HashMap 中所有的键值对都被看作是一个 set 集合。
  hashMap.getOrDefault(E, defaultValue); // 返回指定键映射到的值，如果此映射不包含键的映射，则返回defaultValue 
  ```

- Java中关于HashMap的常用遍历方法：

  ```java
  // 遍历HashMap的所有键
  Map<String, String> map = new HashMap<String, String>();
  for (String key : map.keySet()) {
      System.out.println(key);
      map.get(key);
  }
  ```

  ```java
  // 遍历HashMap的所有值
  Map<String, String> map = new HashMap<String, String>();
  for (String value : map.values()) {
      System.out.prntln(value);
  }
  ```

  ```java
  // 【推荐】遍历HashMap的键值对
  Map<String, String> map = new HashMap<String, String>();
  for (Map.Entry<String, String> entry : map.entrySet()) {
      entry.getKey();
      entry.getValue();
  }
  ```

  ```java
  // 使用forEach方法
  //通过 lambda 表达式使用 forEach()
  hashMap.forEach((key, value) -> {
          System.out.print(key + "=" + value + " ");
  });
  ```

- 关于Arrays.sort()：

  ```java
  Arrays.sort(nums); // 对数组进行升序排列（从小到大）
  ```

  ```java
  // 对数组进行降序排列
  Arrays.sort(nums, new Comparator<Integer>() {
      @Override
      public int compare(Integer o1, Integer o2) {
          return o2 - o1;
      }
  });
  // lambda 表达式，这种写法，nums中的类型需要是Integer
  Arrays.sort(nums, (o1, o2) -> o2 - o1);
  ```

- Java计算幂次方：

  ```java
  Math.pow(a,b); // 返回a的b次方。
  ```

- Java计算绝对值：

  ```java
  Math.abs(a-b);
  ```

- 判断int型的差值为1时，采用`if(a - b > 1)`的方式不行，因为

  ```
  int a = 2147483647;
  int b = -2147483647;
  System.out.println(a-b); // -2
  ```

  可以用`if(a > b + 1)`。

- StringBuilder清空数据：

  ```java
  StringBuilder sb = new StringBuilder(); // 1. 重新new一个
  sb.delete(0, sb.length()); // 2. 使用delete
  sb.setLength(0); // 3. 使用setLength
  ```

- String转char数组：

  ```java
  String s;
  char[] c = s.toCharArray();
  ```

- char数组排序：

  ```java
  char[] c;
  Arrays.sort(c); // 调用完之后数组c就会改变
  ```

- 比较char数组是否相等：

  ```java
  Arrays.equals(sArray, tArray);
  ```

- Java数组转HashSet:

  ```java
  Integer[] nums = new Integer[size];
  HashSet<Intger> set = new HashSet<>(Arrays.asList(nums));
  ```

  **注意：只有当nums是包装类型的数组时才可以使用`Arrays.asList()`进行转换，如果nums是原始类型（比如int[]）的数组，就不能使用`Arrays.asList()`进行转换。**

- String转char数组：

  ```java
  String s = "abcd";
  char[] c = s.toCharArray();
  ```

- char数组转String：

  ```java
  char[] c = {'a', 'b', 'c', 'd'};
  String s = String.valueOf(c);
  ```

- Java求集合的交集：

  ```java
  HashSet<Integer> set1 = new HashSet<>();
  HashSet<Integer> set2 = new HashSet<>();
  set1.retainAll(set2);
  ```

- Java求集合的并集：

  ```java
  HashSet<Integer> set1 = new HashSet<>();
  HashSet<Integer> set2 = new HashSet<>();
  set1.addAll(set2);
  ```

- Java中HashSet转数组：

  ```java
  HashSet<Integer> set1 = new HashSet<>();
  Integer[] tmp = set1.toArray(Integer[]::new);
  ```

- Java中Integer转int:

  ```java
  Integer a = new Integer();
  int b = a.intValue();
  ```

- Java中int转Integer：

  ```java
  int b = 1;
  Integer a = new Integer(b);
  Integer c = Integer.valueOf(b);
  ```

- Java中ArrayList<Integer>转int[] ：

  ```java
  ArrayList<Integer> res = new ArrayList<>();
  int ans = res.stream().mapToInt(k->k).toArray();
  ```

- Java中Arrays的copyOfRange方法：

  ```java
  int[] res = new int[n];
  int resCopy = Arrays.copyOfRange(res, 0, n-2); // 将指定数组的指定范围复制到新数组中。不包括n-2
  ```

- 判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。
  判断是否是左叶子结点：

  ```java
  if (root.left != null && root.left.left == null && root.left.right == null) {
          System.out.println(root.left.val);
  }
  ```

- Java中char转int：

  ```java
  int num = Character.getNumericValue(ch);
  ```

  ```java
  int num = ch - '0'; // ch是数字字符
  ```

  ```java
  int num = Integer.parseInt(String.valueOf(ch))
  ```

- Java中int转char:

  ```java
  char ch = Character.forDigit(num,10); // num是数字
  ```

  ```java
  char ch = String.valueOf(num).charAt(0);
  ```

  ```java
  char ch = (char)('0' + num); // num是数字
  ```

- Java中Math类的常用方法：

  ```java
  double num;
  double res = Math.sqrt(num); // 计算num的算术平方根
  double res = Math.floor(num); // 返回给定参数最大的整数，该整数小于或等给定的参数。
  ```

- Java中String的indexOf():

  ```java
  int indexOf(String str, int fromIndex);
  // 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。
  ```

- Java二维网格中定义上下左右四个方向：

  ```java
  int[][] direction = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
  ```

- Java中字母转大写字母：

  ```java
  Character.toUpperCase(); // 方法用于将小写字符转换为大写。返回转换后字符的大写形式，如果有的话；否则返回字符本身。
  ```

- StringBuilder的常用方法：

  ```java
  StringBuilder sb = new StringBuilder();
  char ch = sb.charAt(int index); //返回指定索引处的此序列中的 char值。
  sb.deleteCharAt(int index); //按此顺序删除指定位置的 char 。
  ```

- Java中二维数组按第一维降序排列:

  ```java
  int[][] map = new int[n][2];
  Arrays.sort(map, (a, b) -> b[0] - a[0]); // 按第一维降序排列
  ```

- Java中的ArrayList的subList() 方法用于截取并返回动态数组中的一部分。

  ```java
  arraylist.subList(int fromIndex, int toIndex);
  // 注：arraylist 是 ArrayList 类的一个对象。
  // 参数说明：
  // fromIndex - 截取元素的起始位置，包含该索引位置元素
  // toIndex - 截取元素的结束位置，不包含该索引位置元素
  ```

- Java返回空数组：

  ```java
  return new int[]{};
  ```

- Java中ArrayList定义时赋值：

  ```java
  ArrayList<Integer> res = new ArrayList<Integer>(){{add(1); add(2);}};
  ```

- Java中Arrays.asList():

  ```java
  public static <T> List<T> asList(T... a); //返回由指定数组支持的固定大小的列表。 （对返回列表的更改“直写”到数组。）
  // 此方法还提供了一种方便的方法来创建初始化为包含多个元素的固定大小的列表：
  List<String> stooges = Arrays.asList("Larry", "Moe", "Curly"); 
  ```

- Java中的优先队列PriorityQueue的定义和常用方法：

  ```java
  PriorityQueue<E> priQueue = new PriorityQueue<>(); // 使用默认的比较器
  priQueue.add(E); // 将指定的元素插入此优先级队列。插入后，队列会保持有序
  priQueue.offer(E); // 将指定的元素插入此优先级队列。插入后，队列会保持有序
  priQueue.poll(); //  返回优先级最高的元素
  priQueue.isEmpty(); // 是否为空
  priQueue.size(); // 返回元素个数
  ```

- Java中ArrayList可以直接添加到头部：

  ```java
  arraylist.add(int index，E element); // 添加元素到指定位置，如果 index 没有传入实际参数，元素将追加至数组的最末尾。index=0，则是每次添加到头部
  ```

- Java中HashSet转List：

  ```java
  HashSet<List<Integer>> res = new HashSet<>();
  return new ArrayList<>(res);
  ```

- Java中char数组转字符串：

  ``` java
  char[] c;
  String.copyValueOf(c); // 返回char数组参数的字符串表示形式。 复制字符数组的内容; 后续修改字符数组不会影响返回的字符串。
  ```

- Java中二维数组赋初始值：

  ``` java
  char[][] chessboard = new char[n][n];
  for(int i = 0; i < n; i++) {
      Arrays.fill(chessboard[i], '.'); // 将指定的char值分配给指定的chars数组的每个元素。
  }
  ```

- Java中char类型也可以遍历：

  ```java
  for (char ch = '1'; ch <= '9'; ch++) {
      // do something
  }
  ```

- Java中List转HashSet：

  ``` java
  List<String> wordDict = new ArrayList<>();
  HashSet<String> set = new HashSet<>(wordDict);
  ```

- Java二维数组排序（第一维升序，第二维降序）：

  ```java
  int[][] envelopes;
  Arrays.sort(envelopes, new Comparator<int[]>(){
      // 按宽度升序排列，如果宽度一样，则按高度降序排列
      public int compare(int[] a, int[] b) {
          return a[0] == b[0] ? b[1] - a[1] : a[0] - b[0];
      }
  });
  ```

- Java中二维数组排序，第一维降序，第二维升序：

  ```java
  int[][] people;
  Arrays.sort(people, new Comparator<int[]>(){
      // 按高度降序，高度相同，则按个数升序
      public int compare(int[] a, int[] b) {
          return a[0] == b[0] ? a[1] - b[1] : b[0] - a[0];
      }
  });
  ```

- Java中二维数组排序，按第二维升序排列:

  ```java
  int[][] points;
  Arrays.sort(points, new Comparator<int[]>(){
      public int compare(int[] a, int[] b) {
          return Integer.compare(a[1], b[1]);
      }
  });
  ```

- Java中二维数组排序，按第二维升序排列:

  ```java
  int[][] intervals;
  Arrays.sort(intervals, new Comparator<int[]>(){
      public int compare(int[] a, int[] b) {
          return a[1] - b[1];
      }
  });
  ```

- Java中int[]类型的ArrayList转二维数组：

  ```java
  ArrayList<int[]> res = new ArrayList<>();
  res.toArray(new int[res.size()][]);
  ```

- Java中双向链表结点定义：

  ```java
  class DLinkedList {
      private int key;
      private int value;
      private DLinkedList next;
      private DLinkedList prev;
      public DLinkedList() {}
      public DLinkedList(int key, int value) {
          this.key = key;
          this.value = value;
      }
  }
  ```

- Java中String转char数组：

  ```java
  String str;
  char[] c = str.toCharArray();
  ```

- Java中char数组转String：

  ```java
  char[] c;
  String key = new String(c);
  ```

- Java中输入：

  ```java
  import java.util.Scanner;
  Scanner sc = new Scanner(System.in);
  int n = sc.nextInt(); // 读入一个整数
  String s = sc.next(); // 以空格为分隔符读入一个字符串
  double t = sc.nextDouble(); // 读入一个浮点数
  String line = sc.nextLine(); // 读入一整行
  sc.hasNext(); // 是否有下一个输入
  sc.hasNextInt(); // 是否有下一个int输入
  sc.hasNextDouble(); // 是否有下一个double输入
  sc.hasNextLine(); // 
  ```





## Python中常用代码

- `str[::-1]`可以翻转字符串

- `join()`函数可以将列表转为字符串

- `split()`函数可以将字符串转为列表

- 队列：Python中可以使用deque()，参考链接：[https://docs.python.org/zh-cn/3/library/collections.html#collections.deque](https://docs.python.org/zh-cn/3/library/collections.html#collections.deque)

  ```python
  from collections import deque
  d = deque()
  d.append('a') # 从右端入队
  d.popleft() # 从左端出队
  ```

  deque()是双向队列，使用时可以当单向队列来用。

- 栈：在python中直接用列表list()代替即可。

  ```python
  stack = []
  stack.append('a') # 从尾部入栈
  stack.pop() # 从尾部出栈
  ```

- Python中`float('inf')`表示正无穷，`float('-inf')`表示负无穷

## MySQL中常用代码

### 建表

```sql
create database if not exists leblog
default character set utf8mb4
default collate utf8mb4_unicode_ci;
```

```sql
drop table if exists blogger_info;
create table blogger_info (
    id int unsigned primary key auto_increment comment 'id',
    nickname varchar(20) not null comment '博主昵称',
    avatar_url varchar(100) not null comment '头像地址',
    motto varchar(50) comment '个性签名',
    location varchar(20) comment '地点',
    create_time datetime not null comment '创建时间',
    update_time datetime not null comment '修改时间'
)engine = InnoDB default charset = utf8mb4 comment '博主信息表';
```

### 查询

```sql
SELECT DISTINCT column, AGG_FUNC(column_or_expression), …
FROM mytable
    JOIN another_table
      ON mytable.column = another_table.column
    WHERE constraint_expression
    GROUP BY column
    HAVING constraint_expression
    ORDER BY column ASC/DESC
    LIMIT count OFFSET COUNT;
```

### 查询第二高的薪水

>  [176. 第二高的薪水 - 力扣（LeetCode）](https://leetcode.cn/problems/second-highest-salary/)

- 两次select

```sql
select max(salary) SecondHighestSalary from Employee where salary < (select max(salary) from Employee)
```

- 排序+limit

```sql
select (select distinct salary from Employee order by salary desc limit 1, 1) as SecondHighestSalary
```

### 查询第N高的薪水

> [177. 第N高的薪水 - 力扣（Leetcode）](https://leetcode.cn/problems/nth-highest-salary/description/)

- 排序+limit

```sql
CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT
BEGIN
  set N = N-1;
  RETURN (
      # Write your MySQL query statement below.
      select (select distinct salary from Employee order by salary desc limit N, 1)
  );
END
```

### 按分数排名

> [178. 分数排名 - 力扣（LeetCode）](https://leetcode.cn/problems/rank-scores/)

- count + distinct

```sql
select a.score as score, (select count(distinct b.score) from Scores as b where b.score >= a.score) as `rank` from Scores as a order by `rank`
```

- dense_rank()

```sql
select score, dense_rank() over (order by score desc) as `Rank` from Scores;
```

### 连续出现3次的数字

> [180. 连续出现的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/consecutive-numbers/)

- 自关联3次

```sql
select distinct l1.Num as ConsecutiveNums 
from Logs l1, Logs l2, Logs l3 
where l1.Id = l2.Id-1
and l2.Id = l3.Id-1
and l1.Num = l2.Num
and l2.Num = l3.Num
```

### 查找部门中工资最高的员工

> [184. 部门工资最高的员工 - 力扣（LeetCode）](https://leetcode.cn/problems/department-highest-salary/)

- in + group by

```sql
select b.name as Department, a.name as Employee, a.salary as Salary 
from Employee as a, Department as b
where a.departmentId=b.id
and (a.departmentId, a.salary) in 
    (select departmentId, max(salary) 
     from Employee
     group by departmentId)
```

### 查找部门工资前三高的所有员工

> [185. 部门工资前三高的所有员工 - 力扣（LeetCode）](https://leetcode.cn/problems/department-top-three-salaries/)

- count + distinct

```sql
select b.name Department, a.name Employee, a.salary Salary
from Employee a, Department b
where a.departmentId = b.id
and 3 > (select count(distinct salary) 
         from Employee c
         where c.departmentId = a.departmentId and c.salary > a.salary
          )
```



# 常用算法模板

## 二分查找模板

> 参考：Python中的[bisect模块源码](https://github.com/python/cpython/blob/3.10/Lib/bisect.py)

### Java版

#### 寻找左边界模板

```java
private static int bisect_left(int[] a, int x, int lo, int hi) {
    /*
    * 参考：https://github.com/python/cpython/blob/3.10/Lib/bisect.py#L68
    * 返回在数组a中插入项目x的索引，假设a已排序。
    * 参数：
    *    a - 要搜索的数组
    *    x - 要搜索的值
    *    lo - 要搜索的第一个元素（包括）的索引
    *    hi - 要搜索的最后一个元素（不包括）的索引
    * 返回值：
    *    返回值i是这样的: a[:i]中的所有e都有e < x，以及a[i:]中的所有e都有e >= x。因此，如果x已经出现在列表中，a.insert(i, x)将在已经存在的最左边的x之前插入
    **/
    while (lo < hi) {
        int mid = lo + (hi - lo) / 2;
        if (a[mid] < x) {
            lo = mid + 1;
        } else {
            hi = mid;
        }
    }
    return lo;
}
```

#### 寻找右边界模板

```java
private static int bisect_right(int[] a, int x, int lo, int hi) {
    /*
    *  参考: https://github.com/python/cpython/blob/3.10/Lib/bisect.py#L19
    * 返回在数组a中插入项目x的索引，假设a已排序。
    * 参数：
    *    a - 要搜索的数组
    *    x - 要搜索的值
    *    lo - 要搜索的第一个元素（包括）的索引
    *    hi - 要搜索的最后一个元素（不包括）的索引
    * 返回值：
    *    返回值i是这样的: a[:i]中的所有e都有e <= x，而a[i:]中的所有e都有e > x。因此，如果x已经出现在列表中，a.insert(i, x)将插入到已经存在的最右边的x之后。
    **/
    while (lo < hi) {
        int mid = lo + (hi - lo) / 2;
        if (x < a[mid]) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
    return lo;
}
```

### Python版

#### 寻找左边界模板

```python
def bisect_left(a, x, lo, hi):
    """ 
    参考：https://github.com/python/cpython/blob/3.10/Lib/bisect.py#L68
    返回在数组a中插入项目x的索引，假设a已排序。
    参数：
        a - 要搜索的数组
        x - 要搜索的值
        lo - 要搜索的第一个元素（包括）的索引
        hi - 要搜索的最后一个元素（不包括）的索引
    返回值：
        返回值i是这样的: a[:i]中的所有e都有e < x，以及a[i:]中的所有e都有e >= x。因此，如果x已经出现在列表中，a.insert(i, x)将在已经存在的最左边的x之前插入
    """
    while lo < hi:
        mid = lo + (hi - lo) // 2
        if a[mid] < x:
            lo = mid + 1
        else:
            hi = mid
    return lo
```

#### 寻找右边界模板

```python
def bisect_right(a, x, lo, hi):
    """ 
    参考：https://github.com/python/cpython/blob/3.10/Lib/bisect.py#L19
    返回在数组a中插入项目x的索引，假设a已排序。
    参数：
        a - 要搜索的数组
        x - 要搜索的值
        lo - 要搜索的第一个元素（包括）的索引
        hi - 要搜索的最后一个元素（不包括）的索引
    返回值：
        返回值i是这样的: a[:i]中的所有e都有e <= x，而a[i:]中的所有e都有e > x。因此，如果x已经出现在列表中，a.insert(i, x)将插入到已经存在的最右边的x之后。
    """
    while lo < hi:
        mid = lo + (hi - lo) // 2
        if x < a[mid]:
            hi = mid
        else:
            lo = mid + 1
    return lo
```

## 滑动窗口模板

### Java版

```java
int left = 0;
int right = 0;
while(right < n) {
	... // 右边进入窗口，更新一些东西
	right++;
	// 要收缩窗口
	while(...) {
		... // 左边出窗口前，更新一些东西
		left++;
	}
}
```

> 一般来说，左边出窗口时的操作和右边进窗口时的操作是对称的，右边进的时候往里加，左边出的时候就往外减。

## 广度优先搜索模板

### Java版

// TODO


## 深度优先搜索模板

### Java版

// TODO

## 回溯法模板

### Java版

```java
public void backtrack(参数) {
	if (终止条件) {
		保存结果;
		return;
	}
	for (选择: 本层集合中的元素) {
		处理结点;
		backtrack(参数); // 递归
		回溯; // 撤销处理结果
	}
}
```

### Python版

```python
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return

    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

> 其中for循环的部分的选择列表可以做剪枝。

## 二叉树前序遍历模板

### Java版（递归）

```java
public void preorder(TreeNode root, List<Integer> result) {
    if (root != null) {
        result.add(root.val);
        preorder(root.left, result);
        preorder(root.right, result);
    }
}
```

### Java版（非递归）

```java
public List<Integer> preorder(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root != null) {
        Deque<TreeNode> stack = new LinkedList<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            TreeNode p = stack.pop();
            result.add(p.val);
            if (p.right != null) {
                stack.push(p.right);
            }
            if (p.left != null) {
                stack.push(p.left);
            }
        }
    }
    return result;
}
```

## 二叉树中序遍历模板

### Java版（递归）

```java
public void inorder(TreeNode root, List<Integer> result) {
    if (root != null) {
        inorder(root.left, result);
        result.add(root.val);
        inorder(root.right, result);
    }
}
```

### Java版（非递归）

```java
public List<Integer> inorder(TreeNode root) {
    List<Integer> result = new LinkedList<>();
    if (root != null) {
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode p = new TreeNode();
        p = root;
        while ( p != null || !stack.isEmpty()) {
            while (p != null) {
                stack.push(p);
                p = p.left;
            }
            if (!stack.isEmpty()) {
                p = stack.pop();
                result.add(p.val);
                p = p.right;
            }
        }
    }
    return result;
} 
```

## 二叉树后序遍历模板

### Java版（递归）

```java
public void postOrder(TreeNode root, List<Integer> result) {
    if (root != null) {
        postOrder(root.left, result);
        postOrder(root.right, result);
        result.add(root.val);
    }
}
```

### Java版（非递归）

```java
public List<Integer> postorder(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root != null) {
        Deque<TreeNode> stack1 = new LinkedList<>();
        Deque<TreeNode> stack2 = new LinkedList<>();
        stack1.push(root);
        TreeNode p = new TreeNode();
        while(!stack1.isEmpty()) {
            p = stack1.pop();
            stack2.push(p);
            if (p.left != null) {
                stack1.push(p.left);
            }
            if (p.right != null) {
                stack1.push(p.right);
            }
        }
        while (!stack2.isEmpty()) {
            p = stack2.pop();
            result.add(p.val);
        }
    }
    return result;
}
```

## 二叉树层次遍历模板

### Java版

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) {
        return res;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while(!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> row = new ArrayList<>();
        while(size > 0) {
            TreeNode node = queue.poll();
            size--;
            row.add(node.val);
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
        if (row.size() > 0) {
            res.add(row);
        }
    }
    return res;
}
```

## 朴素并查集模板

### Java版

```java
int[] p;
public void test() {
    // 初始化，p存储每个点的父节点
    int n = 10;
    p = new int[n];
    for (int i = 0; i < n; i++) {
        p[i] = i;
    }
}
// 返回x的祖宗节点
public int find(int x) {
    if (p[x] != x) {
        // 路径压缩
        p[x] = find(p[x]);
    }
    return p[x];
}
// 合并a和b所在的两个集合
public void union(int a, int b){
    p[find(a)] = find(b);
}
```

### Python版

```python
# 初始化，p存储每个点的父节点
p = list(range(n))

# 返回x的祖宗节点
def find(x):
    if p[x] != x:
        # 路径压缩
        p[x] = find(p[x])
    return p[x]

# 合并a和b所在的两个集合
p[find(a)] = find(b)
```

## 维护size的并查集模板

### Java版

```java
int[] p;
int[] size;
public void test() {
    // 初始化，p存储每个点的父节点
    int n = 10;
    p = new int[n];
    for (int i = 0; i < n; i++) {
        p[i] = i;
    }
    // size只有当节点是祖宗节点时才有意义，表示祖宗节点所在的集合中，点的数量
    size = new int[n];
    Arrays.fill(size, 1);

}
// 返回x的祖宗节点
public int find(int x) {
    if (p[x] != x) {
        // 路径压缩
        p[x] = find(p[x]);
    }
    return p[x];
}
// 合并a和b所在的两个集合
public void union(int a, int b){
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);
}
```



### Python版

```python
# 初始化，p存储每个点的父节点，size只有当节点是祖宗节点时才有意义，表示祖宗节点所在集合中，点的数量
p = list(range(n))
size = [1] * n

# 返回x的祖宗节点
def find(x):
    if p[x] != x:
        # 路径压缩
        p[x] = find(p[x])
    return p[x]

# 合并a和b所在的两个集合
if find(a) != find(b):
    size[find(b)] += size[find(a)]
    p[find(a)] = find(b)
```

## 维护到祖宗节点距离的并查集模板

### Java版

```java
int[] p;
int[] d;
public void test() {
    // 初始化，p存储每个点的父节点
    int n = 10;
    p = new int[n];
    for (int i = 0; i < n; i++) {
        p[i] = i;
    }
    // d[x]存储x到p[x]的距离
    d = new int[n];

}
// 返回x的祖宗节点
public int find(int x) {
    if (p[x] != x) {
        int t = find(p[x]);
        d[x] += d[p[x]];
        p[x] = t;
    }
    return p[x];
}
// 合并a和b所在的两个集合
public void union(int a, int b){
    p[find(a)] = find(b);
    // d[find(a)] = distance;
}
```

### Python版

```python
# 初始化，p存储每个点的父节点，d[x]存储x到p[x]的距离
p = list(range(n))
d = [0] * n

# 返回x的祖宗节点
def find(x):
    if p[x] != x:
        t = find(p[x])
        d[x] += d[p[x]]
        p[x] = t
    return p[x]

# 合并a和b所在的两个集合
p[find(a)] = find(b)
d[find(a)] = distance
```

## 直接插入排序模板

### Java版

```java
public void insertSort(int[] nums) {
    for (int i = 1; i < nums.length; i++) {
        if (nums[i] < nums[i-1]) {
            // 哨兵，可以减少nums[i]的交换次数
            int sentry = nums[i];
            // 边找插入位置，边将前面的数往后移
            // 从i-1开始往回找到能插入nums[i]的地方
            int j = i - 1;
            while(j >= 0 && sentry < nums[j]) {
                // 前面的数往后移，可以直接覆盖后面的数
                nums[j + 1] = nums[j];
                // j往前移
                j--;
            }
            // 插入到正确位置。nums[j] <= sentry, 即最开始的nums[i]插入到sentry的后面
            nums[j + 1] = sentry;
        }
    }
}
```

## 单路快速排序模板

### Java版

```java
import java.util.Random;
private final static Random RANDOM = new Random();
// 对nums中[left, right]闭区间的元素进行快速排序（升序）
private void quickSort(int[] nums, int left, int right) {
    // 递归终止
    if (left >= right) {
        return;
    }
    // 划分，得到划分的边界索引（枢轴元素最终所在位置的索引）
    int pivotIndex = partition(nums, left, right);
    // 递归排序左边
    quickSort(nums, left, pivotIndex - 1);
    // 递归排序右边
    quickSort(nums, pivotIndex + 1, right);
}
private int partition(int[] nums, int left, int right) {
    // 选择一个随机索引对应的值作为枢轴
    // 生成[left, right]闭区间之间的随机数
    int randomIndex = left + RANDOM.nextInt(right - left + 1);
    swap(nums, left, randomIndex);
    int pivot = nums[left];
    // 循环不变量，lt是严格小于pivot的元素的索引
    int lt = left; // lt : less than,严格小于
    // [left + 1, lt] < pivot
    // (lt, i) >= pivot
    // 根军循环不变量的定义，交换值，小的交换到前面，大的不动，
    for (int i = left + 1; i <= right; i++) {
        if (nums[i] < pivot) {
            lt++;
            swap(nums, i, lt);
        }
    }
    // 最后再将枢轴元素交换到lt的位置，因为lt的值是严格小于pivot的，所以可以把lt的值交换的最前面
    swap(nums, left, lt);
    return lt;
}
private void swap(int[] nums, int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
} 
```

## 双路快速排序模板

### Java版

```java
import java.util.Random;
private final static Random RANDOM = new Random();
// 对nums中[left, right]闭区间的元素进行快速排序（升序）
private void quickSort(int[] nums, int left, int right) {
    // 递归终止
    if (left >= right) {
        return;
    }
    // 划分，得到划分的边界索引（枢轴元素最终所在位置的索引）
    int pivotIndex = partition(nums, left, right);
    // 递归排序左边
    quickSort(nums, left, pivotIndex - 1);
    // 递归排序右边
    quickSort(nums, pivotIndex + 1, right);
}
private int partition(int[] nums, int left, int right) {
    // 选择一个随机索引对应的值作为枢轴
    // 生成[left, right]闭区间之间的随机数
    int randomIndex = left + RANDOM.nextInt(right - left + 1);
    swap(nums, left, randomIndex);
    int pivot = nums[left];
    // 循环不变量
    int le = left + 1; // le : less equals, 小于等于
    int ge = right; // ge : greater equals, 大于等于
    // [left + 1, le) <= pivot
    // (ge, right] >= pivot
    // 根据循环不变量的定义，交换值
    while (true) {
        // le从左往右找到大于等于pivot的值
        while(le <= ge && nums[le] < pivot) {
            le++;
        }
        // ge从右往左找到小于等于pivot的值
        while (le <= ge && nums[ge] > pivot) {
            ge--;
        }
        // le来到了第一个大于等于pivot的值
        // ge来到了第一个小于等于pivot的值
        // 退出循环
        if (le >= ge) {
            break;
        }
        // 交换大于等于pivot的值和小于等于pivot的值
        swap(nums, le, ge);
        le++;
        ge--;
    }
    // 最后再将枢轴元素交换到ge的位置，因为ge的值是小于等于pivot，所以要把这个换到前面
    swap(nums, left, ge);
    return ge;
}
private void swap(int[] nums, int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
} 
```

## 三路快速排序模板

### Java版

```java
import java.util.Random;
private final static Random RANDOM = new Random();
// 对nums中[left, right]闭区间的元素进行快速排序（升序）
private void quickSort(int[] nums, int left, int right) {
    // 递归终止
    if (left >= right) {
        return;
    }
    // 选择随机元素作为枢轴
    int randomIndex = left + RANDOM.nextInt(right - left + 1);
    swap(nums, left, randomIndex);
    int pivot = nums[left];
    // [left + 1, lt] < pivot
    // (lt, i) = pivot
    // [gt, right] > pivot
    int lt = left;
    int gt = right + 1;
    int i = left + 1;
    while (i < gt) {
        // 小于枢轴的移到左边
        if (nums[i] < pivot) {
            lt++;
            swap(nums, i, lt);
            i++;
        } else if (nums[i] > pivot) {
            // 大于枢轴的移到右边
            gt--;
            swap(nums, i, gt);
            // 注意，由于gt的值还不知道，把gt的值换到i的位置来，i位置的值还是不知道的，这时i还不能移动
        } else {
            // nums[i] == pivot
            // 等于枢轴的不动
            i++;
        }
    }
    // lt的值是小于最开始的left的值，所以把lt换到前面去
    swap(nums, left, lt);
    // 注意相同元素很多时，这里大大减少了两侧递归的时间
    quickSort(nums, left, lt);
    quickSort(nums, gt, right);
}

private void swap(int[] nums, int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
} 
```

## 归并排序模板

### Java版

```java
// 归并排序需要借助一个临时数组
private int[] tmp = new int[n];
private void mergeSort(int[] nums, int left, int right) {
    if (left < right) {
        // 从中间划分为两个子序列
        int mid = left + (right - left) / 2;
        // 对左侧子序列递归进行归并排序
        mergeSort(nums, left, mid);
        // 对右侧子序列递归进行归并排序
        mergeSort(nums, mid + 1, right);
        // 归并
        merge(nums, left, mid, right);
    }
}
private void merge(int[] nums, int left, int mid, int right) {
    int i = left;
    int j = mid + 1;
    int k;
    // 先把nums中的元素复制到辅助数组tmp中，后面就可以直接在nums数组中合并了
    for (k = left; k <= right; k++) {
        tmp[k] = nums[k];
    }
    for (k = i; i <= mid && j <= right; k++) {
        // 比较tmp左右两段中的元素，将较小的值合并到nums中（可以直接覆盖nums中的值）
        if (tmp[i] <= tmp[j]) {
            nums[k] = tmp[i];
            i++;
        } else {
            nums[k] = tmp[j];
            j++;
        }
    }
    // 若左边未合并完，直接复制左边未合并完的部分
    while(i <= mid) {
        nums[k] = tmp[i];
        k++;
        i++;
    }
    // 若右边未合并完，直接复制右边未合并完的部分
    while(j <= right) {
        nums[k] = tmp[j];
        k++;
        j++;
    }
}
```

## 堆排序模板

### Java版

```java
private void heapSort(int[] nums) {
    int n = nums.length; 
    // 首先建堆，即，将数组调整为大顶堆
    // 将数组看成是一个完全二叉树，则最后一个非叶子结点是第n/2（向下取整）个元素，对应到数组中的索引就是n / 2 - 1，也可以等价的写成(n - 2) / 2。调整堆就从最后一个非叶子结点开始。
    for (int i = (n - 2) / 2; i >= 0; i--) {
        heapAdjust(nums, i, n);
    }
    // 循环将堆顶元素和堆的最后一个元素交换，每交换一次，就调整一次堆
    for (int j = n - 1; j >= 1; j--) {
        // 堆顶元素就是nums[0]，堆顶元素也是最大值，每次把最大值交换到数组的最后面
        swap(nums, 0, j);
        // 每次把最大值调到最后面后，堆的大小也是在减小的，只需要调整剩余的元素即可。这时是从堆顶开始调整
        heapAdjust(nums, 0, j);
    }
}
private void heapAdjust(int[] nums, int parentIndex, int size) {
    // 当前结点作为父节点
    int parent = nums[parentIndex];
    // 父节点的左孩子的下标就是2 * parentIndex + 1，右孩子的下标就是2 * parentIndex + 2
    int childIndex = 2 * parentIndex + 1;
    // size是堆的大小
    while (childIndex < size) {
        // 如果有右孩子，且右孩子大于左孩子的值，则childIndex移动到右孩子
        if (childIndex + 1 < size && nums[childIndex + 1] > nums[childIndex]) {
            childIndex++;
        }
        // 如果上一步，childIndex移动到了右孩子，如果这里父节点又大于右孩子，那么父节点就既大于左孩子又大于等于右孩子，就不用调整了，可以直接break。如果上一步i没有移动到右孩子，说明要么没有右孩子，要么左孩子大于等于右孩子，如果这里父节点又大于左孩子，那么同理，也不用调整了，可以直接break
        if (parent >= nums[childIndex]) {
            break;
        }
        // 如果上面没有break，那么childIndex就来到了左孩子和右孩子中较大的那一个了
        // 无需真正交换，可以直接把较大的孩子的值赋给父节点。因为在整个while中parent的值没有变
        nums[parentIndex] = nums[childIndex];
        // 把较大的孩子作为新的父节点
        parentIndex = childIndex;
        // 新的左孩子
        childIndex = 2 * parentIndex + 1;
    }
    // 把最开始的父节点的值赋值到新的parentIndex位置
    nums[parentIndex] = parent;
}
private void swap(int[] nums, int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}
```

# 常用解题思路和技巧

- 看到有序数组，可以考虑使用二分法。

- 如果暴力解法中出现查找效率低的时候，可以考虑使用哈希表来提高查找效率，

- 找一个满足某个条件的值，都可以考虑使用哈希表。

- 一个常用的逆向思维，判断两个元素的和等于某个值，通常转换为该值和一个元素的差是否等于另一个元素。

- 在链表的题目中，添加虚拟头结点是常用的技巧，使用双指针和快慢指针是常用的思考方向。

- 摩尔投票算法：第一遍找到可能为众数的那个数，主要就是找到major，第一遍遍历完，那个count就没有意义了。第二遍再确定第一遍找到的那个major在数组中的个数是不是大于一半。

- 在字符串的子串问题中，滑动窗口是一个常用的思考方向。

- 遇到仅包含小写字母的字符串时，可以考虑将字母映射到0-25这26个索引值，每个索引值就对应一个字母，改变对应索引下的值就可以统计每个字母的个数。（忽略大小写）

- 滑动窗口的基本思想是：进一个，出一个，维护一个固定大小的窗口，然后针对这个固定大小的窗口进行比较（这个比较过程也是一个可以优化的部分，因为每次只进一个，出一个，可以不比较整个窗口）。

- 遇到两个字符串之间的相关算法，要记得看看要不要判断两个字符串的长度关系。

- 深度优先搜索（DFS）：和栈密切相关。有递归版本和使用栈的版本。

- 广度优先搜索（BFS）：和队列紧密相连。

- 广度优先搜搜：首先将起点添加到队列，然后当队列不为空时开始循环循环，将队首元素出队，（出队后，对这个出队的元素执行一些操作），然后将与其相邻的元素（满足一定条件）入队。每次出一个，入好几个。由于BFS需要将元素入队，为了避免未被访问过的元素重复入队，通常会使用一个visited集合来记录访问过的点。

- 沉岛思想：每次找到岛屿，则直接把找到的岛屿改成0，这是传说中的沉岛思想，就是遇到岛屿就把它沉没。

- 岛屿问题，可以考虑一个一个的遍历，对每一个都进行一个BFS或DFS，但只有是1的时候，才往周围四个方向找。

- 二叉树中，对左右子树的操作通常是相同的，所以可以先只考虑对左边子树的操作，然后对右边子树的操作照着左边写即可。

- 多源点最短路径问题中的一个常见思想：添加一个超级源点，将多源点连接到这个超级源点上，或者把多源点当成一个整体。这里就是把0当做起点，1当做终点，找出每个终点到最近的起点的距离。

- 在最短路问题中，如果我们要求多个源点出发的最短路时，一般我们都会建立一个「超级源点」连向所有的源点，用「超级源点」到终点的最短路等价多个源点到终点的最短路。

- 链表本身就带有递归的特点，一些链表的题可以考虑使用递归来解决。

- 回溯法通常可以自己画个树来帮助理解dfs的过程。

- 画出回溯法的树之后，可以看出那些搜索是可以剪枝的。剪枝部分主要修改做选择的那个for循环的选择列表。注意，这个选择列表的范围的缩减与搜索起点、当前还需要选几个数、已经选了几个数有关。

- 动态规划问题，不直接考虑状态压缩的问题，直接想状态压缩想不出来，先想不压缩的情况。用一个dp[] 数组来存储每个元素的状态（选、不选），这里的dp数组就是存储到当前元素的最大金额。再回过头来观察，发现dp[k]只和dp[k-1],dp[k-2]有关，即，只和其前两个状态有关，那么就可以用两个变量来存储其前两个状态。

- 补码：0的补码还是0，正数的补码是正数的原码，负数的补码是除符号位之外的位取反，然后加1。符号位：0表示正数，1表示负数。(补码表示方式很多，有8位2进制表示，有16位二进制补码表示形式，以及32位二进制补码表示形式，64位进制补码表示形式等。每一种补码表示形式都只能表示有限的数字。以下都使用8位2进制来表示)：-5用补码表示的过程就是：10000101 ->（取反）11111010 -> （加1）11111011。-8用补码表示的过程就是：10001000 -> 11110111->11111000。

- 位运算：若`n & (n - 1) == 0`，则n为2的幂。

- 位运算：若`n & (-n) == n`，则n为2的幂。

- 位运算：当检查第 i位时，我们可以让 n 与 2^i进行与运算，当且仅当 n的第 i 位为 1时，运算结果不为 0。

- 位运算：注意`n & (n - 1)`这个位运算的特点，每运算一次，会将n（二进制表示）中的最低位的1变为0。

- 位运算：`n & 1` ：取n二进制表示下的最后一位。如`0010 & 0001 = 0000`，`0011 & 0001 = 0001`。n为十进制下的奇数，则 `n & 1` 的结果为1；n为十进制下的偶数，则 `n & 1` 的结果为0。

- 位运算：`n & (-n)`：n为偶数，则`n&(-n)=n`；n为奇数，则`n&(-n)=1`。

- 异或运算：不同为1，相同为0。

- 任何数和0做异或运算，结果仍然是原来的数，即`a ^ 0 = a`。

- 任何数和其自身做异或运算，结果是 0，即`a ^ a = 0`。

- 异或运算满足交换律和结合律，即`a ^ b ^ a = b ^ a ^ a = b ^ (a ^ a) = b ^ 0 = b`。

- 解决重复元素的问题可以考虑使用哈希表。

- 当遇到`1 ≤ a[i] ≤ n （n为数组长度）`这种条件时，可以考虑采用原地修改的办法，因为数组中每一个元素值-1后都不超过数组的索引，所以可以利用这个特点对数组进行原地修改。常用的办法是遍历一遍数组，遍历过程中将索引为当前的遍历值减一的数组元素`*-1`，表示当前的元素已经遍历过，再次遇到的时候，如果数组元素小于0，则表示该元素已经出现过。

- 除了哈希表之外，哈希集合也是一个常用的工具。

- 看到有序数组就要想到二分法。

- 用栈：要学会利用栈这种数据结构，对一些删除、修改、撤销等操作，可以考虑使用栈来解决。

- 滑动窗口：右边的一直走，左边的满足条件时进入while开始缩小。

- 看到没有重复元素就要想到用哈希表。

- 寻找下一个更大元素就是单调栈的典型应用场景。

- 对于循环数组，一个常用的思路就是将数组复制一份，再将两个数组拼到一起。

- 对于循环数组的另一个常用做法是对下标取余来遍历。

- 去除一个数的最高位和最低位的方法：`x = (x % div) / 10;`。其中div是最高位的位数。比如，x=1221,则div=1000。

- 括号的配对问题是栈的典型应用。

- 求最值、最优解的问题，可以尝试动态规划。

- Java中char类型的字符相减是字符对应的ASCII码相减。'1'的ASCII码是49， '0'的ASCII码是48，'1' - '0' = 49-48=1。

- Java中的StringBuilder可以直接append int、char、String等类型。

- 看见两个序列，就要想到使用双指针。

- 二叉树的中序遍历递归算法：（在当前节点不为空的情况下进行）

  1. 中序遍历左子树
  2. 访问（当前）根节点
  3. 中序遍历右子树

- 二叉树的中序遍历非递归算法：**借助栈来实现**。（在当前节点不为空的情况下进行）
  算法思想：

  1. 先将根入栈，再到左孩子。
  2. 把左孩子当作当前的根入栈，再到当前根的左孩子（有的话）。
  3. 一直到没有左孩子，然后将栈顶出栈，并访问。
  4. 再访问其右孩子，当作当前根，回到1，重复。

- 由于二叉树的递归特性，在二叉树的题目中，采用递归解法是一个常用的思路。

- 二叉树的广度优先搜索：利用队列。入队时，要把每一层的元素全部入队，出队时，要把每一层的元素全部出队。在把当前层全部出队前，可以通过`int size = queue.size()`获取到当前层的元素个数（二叉树的广度优先搜索中的一个重要技巧）。然后每出队一个元素，就把size减一，size减到了0就表示当前层都出队了（这时队列里是下一层的全部元素）。一层都出队完了，深度就加一。

- 计算中点的写法：`int m = left +  (right - left)/2;`等价于`int m = (left + right)/2`。为了避免后后者中的left+right的结果可能出现超出int范围导致的越界，通常采用前者。这种写法是取中点靠左的点。取中点靠右的点:`int m = left + (right - left + 1)/2`等价于`int m = (left + right + 1)/2`，通常采用前者。

- 要构建一个二叉搜索树的话，就需要满足二叉搜索树的性质（简单来说是“左小右大”）。由于数组是严格递增（升序）的，那么从中间选择分割点，分割点作为根节点，左区间构造左子树，右区间构造右子树，刚好可以满足二叉搜索树的性质。

- 从数组构建二叉树，一个常用的思路就是从数组中间开始构建，然后分两个区间，对两个区间作为子数组来构建，是一个递归构建的过程。

- 二叉搜索树中一般认为没有相等的值，对BST中序遍历可得到一个递增的序列。

- 高度平衡的二叉搜索树，即：既是平衡二叉树（AVL树）又是二叉搜索树（BST）。

- 二叉平衡树（AVL树）：（递归定义）、

  - 空树是二叉平衡树
  - 若非空，则：它的左右子树均是AVL树；左右子树的高（深）度差的绝对值不超过1。（只能为-1,0,1）。

- 二叉搜索树（BST）：（递归定义）

  - 空树是二叉搜索树
  - 若非空，则：其左子树的所有节点的值均小于它的根节点的值；其右子树的所有节点的值均大于它的根节点的值；它的左右子树也分别为二叉搜索树。

- 节点的深度：从根节点开始自顶向下逐层累加，根的深度为1。

- 节点的高度：从叶子节点开始自底向上逐层累加，叶子节点高度为1。

- 求和的问题转换为求差的问题也是一个常用的思路。

- 动态规划的常用步骤：

  1. 从最优策略的最后一步来划分子问题。
  2. 将子问题的定义改写成状态转移方程。
  3. 确定初始条件。
  4. 确定计算顺序。

- 找不同可以使用异或。

- 异或：相同为0，不同为1

- 二进制下用1表示真，0表示假，则异或的运算法则为：0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1）

- 异或的性质：

  1. 归零律：`a ^ a = 0`
  2. 恒等律：`a ^ 0 = a`
  3. 交换律： `a ^ b = b ^ a`
  4. 结合律： `a ^ b ^ c = a ^ ( b ^ c)  = (a ^ b ) ^ c`
  5. 自反：`a ^ b ^ a = b`

- 异或技巧：

  - 当 mid 是偶数时，`mid + 1 = mid ^ 1`；
  - 当 mid 是奇数时，`mid - 1 = mid ^ 1`。

- 快慢指针：快指针走两步，慢指针走一步。如果有环，快指针一定可以追上慢指针，追上了，说明有环，就返回true，跳出循环，如果没追上，则，快指针会先到终点，为空，然后自己出循环，说明没有环，返回false。

- 哈希集合：把访问过的节点保存到哈希集合中，如果节点已经保存过，说明有环。

- 递归-前序遍历：（根左右）（是一个递归定义）

  - 访问根结点
  - 前序遍历左子树
  - 前序遍历右子树

- 迭代-前序遍历：（借助栈来完成）
  算法思想：

  1. 先把根结点入栈，然后在栈非空的情况下，对子数进行遍历。
  2. 先把根结点出栈，然后根据出栈的结点，访问该节点（输出访问节点的值）。
  3. 再将当前结点的右孩子入栈（如果有的话），再将当前根结点的左孩子入栈（如果有的话）。【注意：实现入栈右孩子，再入栈左孩子，这样可以先访问先出栈的左孩子，符合先序遍历】。
  4. 左右都入栈后，再将当前栈顶的元素出栈，并访问这个结点。
  5. 重复上述操作，直至栈空。

- 递归-后序遍历：（左右根）

  - 后序遍历左子树
  - 后序遍历右子树
  - 访问根结点

- 迭代-后序遍历：（借助两个栈来实现）
  算法思想：

  1. 先把根入栈1。
  2. 再把栈1的栈顶压入栈2.
  3. 从栈1出栈时，将其左右压入栈2.
  4. 再到3，重复，直至把右边都压入到栈2的下面，左边都压入到栈1的上面。
  5. 再把栈2中的依次出栈。

- 使用HashSet判断是否包含某个元素比ArrayList要快很多。

- 指针对齐是双指针应用中的一个重要思想，尤其是需要遍历长度不同的链表时，可以先计数之后，找到长度差，然后让两个指针对齐，即使需要遍历的长度相同。

- A 的ASCII码是65，Z的ASCII码是90。

- Java中字符+整型，会将字符转为对应的十进制ASCII码运算。使用(char)num强转类型可以将整型转为对应的ASCII码。

- 摩尔投票：众数个数**至少**比非众数多一，把count加减当作一个众数抵消掉一个非众数，剩下的一定是众数。

- MySQL中连接的使用：你可以在 SELECT, UPDATE 和 DELETE 语句中使用 Mysql 的 JOIN 来联合多表查询。
  JOIN 按照功能大致分为如下三类：
  INNER JOIN（内连接,或等值连接）：获取两个表中字段匹配关系的记录。
  LEFT JOIN（左连接）：获取左表所有记录，即使右表没有对应匹配的记录。
  RIGHT JOIN（右连接）： 与 LEFT JOIN 相反，用于获取右表所有记录，即使左表没有对应匹配的记录。

- inner join：2表值都存在。outer join：附表中值可能存在null的情况。
  总结：

  1. A inner join B：取交集
  2. A left join B：取A全部，B没有对应的值，则为null
  3. A right join B：取B全部，A没有对应的值，则为null
  4. A full outer join B：取并集，彼此没有对应的值为null
     上述4种的对应条件，在on后填写。

- 用where：自关联查询。

- 用Join：JOIN 是一个更常用也更有效的将表连起来的办法，我们使用 ON 来指明条件。

- 向 GROUP BY 添加条件的一种更常用的方法是使用 HAVING 子句，该子句更为简单高效。

- 优先顺序：where > group by > having > order by。

- 查询没有的时候可以考虑用not in。

- DATEDIFF() 函数返回两个日期之间的天数。

- 对于循环问题可以考虑使用快慢指针：快指针算两次，慢指针算一次。如果有环，一定会相遇。

- 哈希表本身就是反映映射关系的，看到映射关系就要想到哈希表。

- 看到类似这种`abs(i - j) <= k`表示一个区间的，就可以考虑使用滑动窗口。

- 二叉搜索树（BST）：（递归定义）

  - 空树是二叉搜索树
  - 若非空，则：其左子树的所有节点的值均小于它的根节点的值；其右子树的所有节点的值均大于它的根节点的值；它的左右子树也分别为二叉搜索树。

- 在二叉搜索树中可以快速找到某个结点以及从根结点到该节点的路径，例如我们需要找到节点 p：

  - 我们从根节点开始遍历；
  - 如果当前节点就是 p，那么成功地找到了节点；
  - 如果当前节点的值大于 p的值，说明 p应该在当前节点的左子树，因此将当前节点移动到它的左子节点；
  - 如果当前节点的值小于 p 的值，说明 p应该在当前节点的右子树，因此将当前节点移动到它的右子节点。
    在寻找节点的过程中，我们可以顺便记录经过的节点，这样就得到了从根节点到被寻找节点的路径。

- 深度优先搜索：

  - 如果当前节点不是叶子节点，则在当前的路径末尾添加该节点，并继续递归遍历该节点的每一个孩子节点。
  - 如果当前节点是叶子节点，则在当前路径末尾添加该节点后我们就得到了一条从根节点到叶子节点的路径，将该路径加入到答案即可。

- 迭代和层次遍历：结点和路径要一起操作，这样才能起到回溯的作用。

- 在Java、C、C++中，`a % b`的结果的正负和左操作数a相同，`-1 % 9 = -1`。

- 在Python中，`a % b`的结果的正负和右操作数b相同，`-1 % 9 = 8`。

- 找缺失数、找出现一次数都是异或的经典应用。

- 任何数异或0都是自己。

- HashMap中的`map.containsValue()`是比较耗时的。

- 巴什博弈： 只有一堆n个物品，两个人轮流从这堆物品中取物， 规定每次至少取一个，最多取m个。最后取光者得胜。 只要 n 不能整除 m+1 ,那么必然是先手取胜，否则后手取胜 。

- 位运算：`n & (n - 1)`这个位运算的特点，每运算一次，会将n（二进制表示）中的最低位的1变为0。运算几次变为0，n的二进制表示就有几个1。

- Java的库函数`Integer.bitCount(i)`可以统计一个int型数字的二进制表示的1的个数

- `x / 2 = x >> 1`，`x % 2 = x & 1`。

- & 与运算符的优先级 比 == 等等于号的优先级要低。

- 如果 n 是 4的幂，那么它可以表示成 4^x的形式，我们可以发现它除以3的余数一定为 1。

- 遇到只有小写字母组成，就可以考虑使用一个int[26]的数组来代替HashMap计数，下标表示字符与小写字母a的ASCII码相减，值表示该字符出现的次数。

- Java中的空字符：`char c = '\u0000';`。

- 在子序列中的相关问题，使用动态规划时，关于dp数组的定义，数组的下标通常是字符串中字符的下标，`dp[i]`通常表示一个长度。两个字符串，那一般会使用二维的dp数组，第一维的下标是一个字符串中字符的下标，第二维的下标也是一个字符串中字符的下标。`dp[i][j]`是表示一个长度。

- 判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。

- Java中`>>`和`>>>`的区别：

  - `>>`：带符号右移。正数右移高位补0，负数右移高位补1。比如：
    `4 >> 1`，结果是2；`-4 >> 1`，结果是-2。`-2 >> 1`，结果是-1。
  - `>>>`：无符号右移。无论是正数还是负数，高位通通补0。
    对于正数而言，`>>`和`>>>`没区别。
    对于负数而言，`-2 >>> 1`，结果是2147483647（Integer.MAX_VALUE），`-1 >>> 1`，结果是2147483647（Integer.MAX_VALUE）。

- 常用ASCII码的范围：

  - 0-9的十进制ASCII码是：48-57
  - A-Z的十进制ASCII码是：65-90
  - a-z的十进制ASCII码是：97-122

- 回文字符串的长度：偶数对 字符的个数 * 2 + 1（如果至少有一个字符的个数为奇数）。

- 想清楚局部最优，想清楚全局最优，感觉局部最优是可以推出全局最优，**并想不出反例**，那么就试一试贪心。

- 一个数`a & 1`可以取出a的最后一位。

- 每次执行`s = s & (s - 1);`都会移除s中最低位的一个1。

- num右移i位和1相与等于0就说明num的第i位是0，把第i位的0变成1就是把1左移i位。

- 位运算中有一个运算符` ~ `表示取反。

- Java中的取反：

  ```java
  >>> Integer.toBinaryString(5)
  101
  >>> Integer.toBinaryString(~5)
  11111111111111111111111111111010
  ```

  我们看到，虽然 5 的二进制 101 被取反了，但是其前导 0 也被取反。

- 用二维数组当HashMap，记录值和其索引。用二维数组，可以直接使用Arrays.sort()对二维数组进行降序排列。

- 滑动窗口的基本思想：右边一直往右，窗口内的元素满足某些条件时（需要滑动窗口时），移除窗口左边的元素，左边开始往右，直到窗口内的元素不满足某些条件，然后右边继续往右。

- 满足某些条件的子串问题、子数组问题通常可以考虑使用滑动窗口。

- Java中Integer类型的比较要使用equals。当我们比较包装类的时候，如果范围在【-128，127】之间，可以直接用==比较，超出这个范围要用equals，进行比较。

  ```java
  @Test
  public void test1(){
      Integer i = 100;
      Integer i2 = 100;
  
      Integer i3 = 300;
      Integer i4 = 300;
  
      System.out.println(i == i2); // 输出 true
      System.out.println(i3 == i4); // 输出 false
  }
  ```

- 超过整数范围的判断要放在`res = res * 10 + digit;`之前，否则，计算过程中会出现越界。

- 对于逆序处理应该首先想到栈。

- 对于链表的逆序处理，还可以想到头插法建立链表。

- 链表自带递归特性，利用递归可以将链表反向输出。

- 利用栈也可以解决很多倒序的问题。

- 快慢指针：快指针是一直移动，然后在遇到相同元素时加速移动，慢指针在没有删除重复元素时才正常移动。

- 归并排序：时间复杂度：O(nlogn),可以在链表上进行归并排序，有递归版本和非递归版本。

- 头插法可以满足链表问题中的倒序和翻转，反转等问题。

- 利用栈可以倒着遍历。

- 用ArrayList可以直接访问下标。

- 层次遍历中，利用size记录当前层的元素个数是个好办法。

- 从前序和中序遍历序列中构造二叉树：

  - 思路：在前序遍历序列中确定根结点，然后在中序遍历序列中找到根结点的索引，进而确定左子树中结点的个数（根结点索引左边的元素个数）和右子树中结点的个数（根结点索引右边的元素个数），根据元素个数，可以在前序遍历序列中划分出两个子区间，这两个子区间分别是左子树的元素和右子树的元素。然后对这两个子区间，分别递归构建左子树和右子树。最后返回根结点。
  - 细节：在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希表来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1) 的时间对根节点进行定位了。

- 从中序和后序遍历序列中构造二叉树：

  - 思路：在后序遍历序列中确定根结点，然后在中序遍历序列中找到根结点的索引，进而确定左子树中结点的个数（根结点索引左边的元素个数）和右子树中结点的个数（根结点索引右边的元素个数），根据元素个数，可以在后序遍历序列中划分出两个子区间，这两个子区间分别是左子树的元素和右子树的元素。然后对这两个子区间，分别递归构建左子树和右子树。最后返回根结点。
  - 细节：在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希表来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1) 的时间对根节点进行定位了。

- 基本计算器实现技巧：

  - 在前面加上一个`+`号
  - 先算乘除
  - `-`后面的数字，存其相反数
  - 最后在全部加起来。

- 子串一定是连续的，子序列不一定是连续的。

- 子串dp数组定义用bool类型，子序列dp数组定义用长度。

- 子序列，子串的常用动态规划思路是讨论s.charAt(i)和s.charAt(j)是否相等，相等时的状态转移方程是什么什么，不相等时的状态转移方程是什么什么。

- 当看到题目是给定一些「物品」，让我们从中进行选择，以达到「最大价值」或者「特定价值」时，我们应该联想到「背包问题」。

- 背包问题中：如果求组合数就是外层for循环遍历物品，内层for遍历背包。如果求排列数就是外层for遍历背包，内层for循环遍历物品。

- 采用`i - j * j`的方式，就可以确保把i拆成一个数和一个完全平方数。

- 对于回文串的常见处理思路是：找中心然后向两边扩散看是不是对称的就可以了。

- 双指针，中心扩展法：首先确定回文串，就是找中心然后向两边扩散看是不是对称的就可以了。在遍历中心点的时候，要注意中心点有两种情况：一个元素可以作为中心点，两个元素也可以作为中心点。

- 运用动态规划算法的一个重要条件：子问题必须独立。

- 对于这个戳气球问题，如果想用动态规划，**必须巧妙地定义 dp 数组的含义，避免子问题产生相关性**，才能推出合理的状态转移方程。

- LRU缓存设计：使用一个双向链表和一个哈希表实现。双向链表头部放最近访问的元素，尾部放最久未访问的元素，哈希表保存键和对应的结点，这样可以快速根据键找到访问的结点，然后将其移动。

- 字典树：是一个有根多叉树。每个结点有一个数组和一个标识，这个数组也是字典树类型，即数组中的每一个值都可以表示一个字典树，这个标识表示当前结点是否是某个字符串的结尾（当前结点的父节点中有这个字符串的最后一个字符，从根结点到当前结点的父节点的路径中有该字符串）。 

- 链地址法：数组+链表，数组中存储链表的头指针，出现冲突的记录存在同一个线性链表中。

- 并查集：可以通过并查集寻找附加的边。初始时，每个节点都属于不同的连通分量。遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量。

  - 如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。
  - 如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。

- 直接插入排序：先用哨兵记录当前元素，然后找当前元素的插入位置，边找插入位置，边将前面的数往后移，即从i-1开始往回找到能插入nums[i]的地方。最后将哨兵插入到正确的位置。

- 单路快排：小往前，大不动。

- 双路快排：主要目的是让等于pivot的元素均匀的分到数组的两边，所以，lt和gt遇到等于pivot的元素时都要停下来（lt遇到大于的时候也要停下来，gt遇到小于的时候也要停下来），然后交换它们的值，虽然交换相等的元素没有什么意义，但是这样的操作会把等于pivot的元素均匀的分到数组的两边，避免一边的数组很长，另一边的很短。
  从左往右找到大于等于pivot的值，从右往左找到小于等于pivot的值，交换大于等于pivot的值和小于等于pivot的值。最后再将枢轴元素交换到gt的位置，因为gt的值是小于等于pivot，所以要把这个换到前面。

- 三路快排：小于枢轴的移到左边，大于枢轴的移到右边，等于枢轴的不动。在三路快排中，partition会得到两个切分点，左边和右边各一个，如果把partition写成函数，要返回一个数组。在这里实现的时候，就直接把partition的部分写在了quickSort中，这样就不用返回一个数组了。

- 归并排序：需要一个额外的辅助空间。先从中间划分为两个子序列，然后对左侧子序列递归进行归并排序，然后对右侧子序列递归进行归并排序，然后合并左右两边。

- 堆排序：首先建堆，即，将数组调整为大顶堆，将数组看成是一个完全二叉树，则最后一个非叶子结点是第n/2（向下取整）个元素，对应到数组中的索引就是n / 2 - 1，也可以等价的写成(n - 2) / 2。调整堆就从最后一个非叶子结点开始。循环将堆顶元素和堆的最后一个元素交换，每交换一次，就调整一次堆。
  调整堆：把当前结点作为父节点，然后把当前结点，当前结点的左孩子，当前结点的右孩子，中的最大值交换到父节点。然后继续调整那个被交换的孩子结点。

- 排序算法总结：

  - 直接插入排序：时间复杂度：O(n^2)，空间复杂度：O（1），稳定，顺+链。
  - 快速排序：时间复杂度：O(nlogn)，空间复杂度：O（logn），不稳定，顺+链。
  - 归并排序：时间复杂度：O(nlogn)，空间复杂度：O(n)，稳定。顺+链。
  - 堆排序：时间复杂度：O（nlogn），空间复杂度：O（1），不稳定，顺+链。

- Java中定义的char数组中的默认字符是空字符，其ASCII码是0。

- 字符串匹配类的问题，通常用动态规划解决。